<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>有用的站点</title>
    <url>/2023/11/e719517baf70/</url>
    <content><![CDATA[<p>清华镜像</p>
<p><a href="http://mirrors.tuna.tsinghua.edu.cn/">http://mirrors.tuna.tsinghua.edu.cn/</a> (IPv4+IPv6)</p>
<p><a href="http://mirrors.6.tuna.tsinghua.edu.cn/">http://mirrors.6.tuna.tsinghua.edu.cn/</a>  (IPv6 only)</p>
<p><a href="http://mirrors.4.tuna.tsinghua.edu.cn/">http://mirrors.4.tuna.tsinghua.edu.cn/</a> (IPv4 only)</p>
<p>我告诉你（windows工具站</p>
<p><a href="https://msdn.itellyou.cn/?ang=2h-cn">https://msdn.itellyou.cn/?ang=2h-cn</a></p>
]]></content>
  </entry>
  <entry>
    <title>MySQL报错与解决方案</title>
    <url>/2023/11/21af1bc8b692/</url>
    <content><![CDATA[<h1 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h1><h2 id="报错内容"><a href="#报错内容" class="headerlink" title="报错内容"></a>报错内容</h2><p>无法往mysql中插入 0000-00-00 00:00:00的空时间</p>
<blockquote>
<p>Error 1292 (22007): Incorrect datetime value: ‘0000-00-00’ for column ‘login_time’ at row 1 [9.386ms] [rows:0] INSERT INTO <code>user_basic</code> (<code>created_at</code>,<code>updated_at</code>,<code>deleted_at</code>,<code>name</code>,<code>password</code>,<code>phone</code>,<code>email</code>,<code>identity</code>,<code>client_ip</code>,<code>client_port</code>,<code>login_time</code>,<code>heartbeat_time</code>,<code>login_out_time</code>,<code>is_login_out</code>,<code>device_info</code>) VALUES (‘2023-09-05 10:04:15.45’,’2023-09-05 10:04:15.45’,NULL,’chenjie’,’’,’’,’’,’’,’’,’’,’0000-00-00 00:00:00’,’0000-00-00 00:00:00’,’0000-00-00 00:00:00’,false,’’)</p>
</blockquote>
<h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;sql_mode&#x27;;</span><br><span class="line">    -&gt; ;</span><br><span class="line">+---------------+-----------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Variable_name | Value                                                                                                                 |</span><br><span class="line">+---------------+-----------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| sql_mode      | ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION |</span><br><span class="line">+---------------+-----------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到sql_mode字段有NO_ZERO_IN_DATE，NO_ZERO_DATE，都删除即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global sql_mode=&#x27;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#x27;;</span><br></pre></td></tr></table></figure>



<h1 id="错误2"><a href="#错误2" class="headerlink" title="错误2"></a>错误2</h1><h2 id="错误内容："><a href="#错误内容：" class="headerlink" title="错误内容："></a>错误内容：</h2><blockquote>
<p>SQL_ERROR_INFO: “Expression #3 of SELECT list is not in GROUP BY clause and contains nonaggregated column ‘practice_record.submit_time’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode&#x3D;only_full_group_by”</p>
</blockquote>
<p><a href="https://www.nowcoder.com/practice/f6b4770f453d4163acc419e3d19e6746?tpId=240&tqId=2183006&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj">月总刷题数和日均刷题数_牛客题霸_牛客网 (nowcoder.com)</a></p>
<blockquote>
<p>ONLY_FULL_GROUP_BY的语义就是确定select list中的值要么是来自于聚合函数（sum、avg、max等）的结果，要么是来自于group by list中的表达式的值，在计算日均刷题数的时候，使用了day( last_day( submit_time))，这个数据是临时定义的，它即不来自聚合函数又不来自group by list，所以会报错。</p>
</blockquote>
<h2 id="解决方式-1"><a href="#解决方式-1" class="headerlink" title="解决方式"></a>解决方式</h2><p>MySQL提供了 <strong>any_value()</strong> 函数来抑制ONLY_FULL_GROUP_BY值被拒绝</p>
<p>any_value()会选择被分到同一组的数据里第一条数据的指定列值作为返回数据。在计算日均刷题数的时候，选择submit_month作为返回数据，这样就忽略了分母中的day( last_day( submit_time))，从而避免ONLY_FULL_GROUP_BY 报错。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>VMvare+CentOS7的安装+桥接模式下的静态ip设置</title>
    <url>/2023/11/a6aff7c01e18/</url>
    <content><![CDATA[<h2 id="VMvare-17下载、安装、配置"><a href="#VMvare-17下载、安装、配置" class="headerlink" title="VMvare 17下载、安装、配置"></a>VMvare 17下载、安装、配置</h2><p><a href="https://blog.csdn.net/qq_45037155/article/details/123589403">https://blog.csdn.net/qq_45037155/article/details/123589403</a></p>
<p>如果本机以前安装过，安装前要把原来的vmvare的注册表信息清空。</p>
<p>官网：<a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html">https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html</a></p>
<p>密钥：MC60H-DWHD5-H80U9-6V85M-8280D</p>
<p>配置：内存8g，4核CPU</p>
<h2 id="centos-7下载与设置"><a href="#centos-7下载与设置" class="headerlink" title="centos 7下载与设置"></a>centos 7下载与设置</h2><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><a href="https://mirrors6.tuna.tsinghua.edu.cn/centos/7.9.2009/isos/x86_64/">https://mirrors6.tuna.tsinghua.edu.cn/centos/7.9.2009/isos/x86_64/</a></p>
<p>电脑配置够可以不装mini版本，因为缺失了一些基本功能比如ifconfig，再安装浪费时间。</p>
<h3 id="centOS设置静态ip"><a href="#centOS设置静态ip" class="headerlink" title="centOS设置静态ip"></a>centOS设置静态ip</h3><p>此处不止要设置静态ip，还要将虚拟机的ip归属到主机ip所属的子网，它们之间可以相互ping通。</p>
<h4 id="获取windows主机子网、网关信息"><a href="#获取windows主机子网、网关信息" class="headerlink" title="获取windows主机子网、网关信息"></a>获取windows主机子网、网关信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231123194830334.png" alt="image-20231123194830334"></p>
<p>网关、子网掩码显而易见，子网为<code>172.31.226.0</code></p>
<h4 id="VMware网络模式简单了解"><a href="#VMware网络模式简单了解" class="headerlink" title="VMware网络模式简单了解"></a>VMware网络模式简单了解</h4><ul>
<li><p>桥接模式（本文选择）<br>桥接模式就是将虚拟机的虚拟网卡利用虚拟网桥与主机的物理网卡进行通信。这时虚拟机与物理主机就相当于在同一个局域网内，它们所使用的IP 地址也是同一个网段，与在办公室里多安装了一台电脑一样，分配给它的IP 与这个局域网内的其它IP 相同会引起冲突，这种方式适用于IP 地址分配较为宽裕的网络环境。</p>
</li>
<li><p>主机共享模式<br>虚拟机通过VMnet1 虚拟网卡直接与主机的网卡进行通信，这种方式将虚拟机与外网隔离，只可以通过物理主机来访问虚拟机资源，而虚拟机也不可以访问互联网的资源，这种模式适用于复杂的网络环境进行学习和测试使用</p>
</li>
<li><p>NAT模式（原本选择，本文暂未解决NAT模式下的静态ip）<br>在NAT 模式中，主机网卡直接与虚拟机的虚拟NAT 设备相连接，然后虚拟机的NAT 设备与虚拟机的虚拟DHCP 服务器一起连接到虚拟网卡VMnet8 上。这时虚拟机与物理主机就不在同一个局域网内，它主要是通过VMnet8 虚拟网卡与主机进行通信，这种方式适用于IP 地址分配较为紧张的网络环境。</p>
</li>
</ul>
<p>原文链接：<a href="https://blog.csdn.net/qq_44654974/article/details/127347478">https://blog.csdn.net/qq_44654974/article/details/127347478</a></p>
<h4 id="vmvare设置"><a href="#vmvare设置" class="headerlink" title="vmvare设置"></a>vmvare设置</h4><p>右键centOS&gt;设置&gt;网络适配器&gt;桥接模式 即可</p>
<p><em><strong>以下步骤是NAT模式下设置的，虚拟机可以ping通外网，但发现虚拟机并不能被主机ping通</strong></em></p>
<p><del>编辑&gt;虚拟网络编辑器&gt;VMnet8，设置子网IP+子网掩码</del> </p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231123195029701.png" alt="image-20231123195029701"></p>
<p><del>然后进入NAT设置，设置网关</del></p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231123195215541.png" alt="image-20231123195215541"></p>
<h4 id="CentOS设置"><a href="#CentOS设置" class="headerlink" title="CentOS设置"></a>CentOS设置</h4><p>随后进入CentOS，查看网卡名称，确定哪个网卡用于静态ip。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure>

<p>随后进入CentOS，进入网卡文件配置目录，编辑网卡ens33对应文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>  /etc/sysconfig/network-scripts</span><br><span class="line">vim ifcfg-ens33</span><br></pre></td></tr></table></figure>

<p>根据前几步所涉及的子网、子网掩码、网关信息，新增&#x2F;修改如下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOTRPROTO=&quot;static&quot;  // none/static表示静态网卡，通常是dhcp即动态分配</span><br><span class="line">ONBOOT=&quot;yes</span><br><span class="line"></span><br><span class="line">IPADDR=172.31.226.34  // 一个未被使用的ip地址，属于子网172.31.226.0即可</span><br><span class="line">NETMASK=225.225.225.0  // 子网掩码</span><br><span class="line">172.31.226.33         // 网关</span><br><span class="line">DNS1=114.114.114.114  // 电信DNS服务器，可修改为其他</span><br><span class="line">DNS2=8.8.8.8          // 谷歌DNS服务器，可修改为其他</span><br></pre></td></tr></table></figure>



<p>重启执行网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>

<p>使用ping检测网络连接是否正常，并检查ip地址是否是自己配置的那个地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping baidu.com</span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<p>虚拟机和主机相互ping检查是否正常。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="ens33网卡不见"><a href="#ens33网卡不见" class="headerlink" title="ens33网卡不见"></a>ens33网卡不见</h3><p>解决方式：重启网络服务即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop NetworkManager</span><br><span class="line">systemctl <span class="built_in">disable</span> NetworkManager</span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>

<h3 id="ens网卡没有ipv4地址"><a href="#ens网卡没有ipv4地址" class="headerlink" title="ens网卡没有ipv4地址"></a>ens网卡没有ipv4地址</h3><p>这时候问题比较奇怪，网卡配置文件已经配置成了静态网卡，但是ifconfig命令中ens33网卡只显示inet6地址，没有找到比较好的解决方案。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231201102733496.png" alt="image-20231201102733496"></p>
<p>临时的解决方案，在重启网络&#x2F;重启机器后，会失效，要重新设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig ens33 172.31.226.34</span><br></pre></td></tr></table></figure>

<p>最后是将<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code>文件重写了才解决。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static </span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33    </span><br><span class="line">UUID=f5e37a10-3da9-47af-8dbb-370b7bf24509</span><br><span class="line">DEVICE=ens33  </span><br><span class="line">ONBOOT=yes  </span><br><span class="line">IPADDR=172.31.226.34    </span><br><span class="line">GATEWAY=172.31.226.33    </span><br><span class="line">NETMASK=255.255.255.0   </span><br><span class="line">DNS1=114.114.114.114  </span><br><span class="line">DNS2=8.8.8.8</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>基础教程</title>
    <url>/2023/11/0d12653e139c/</url>
    <content><![CDATA[<p>DBMS - （执行）-&gt; SQL -(操作) -&gt; DB</p>
<p>增删改查 CRUD: create retrieve update delete</p>
<h1 id="表："><a href="#表：" class="headerlink" title="表："></a>表：</h1><ul>
<li>行-数据&#x2F;记录 data</li>
<li>列：字段<ul>
<li>每个字段包括：字段名、数据类型、约束</li>
</ul>
</li>
</ul>
<p>	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; mysql -uroot -p123  // 登录mysql</span><br><span class="line">mysql&gt; show databases;  // 查看有哪些数据库</span><br><span class="line">mysql&gt; create database database1; // 创建数据库</span><br><span class="line">mysql&gt; use database1;  // 使用该数据库</span><br><span class="line">mysql&gt; show tables;  // 查看有哪些表</span><br><span class="line">mysql&gt; sources  E:\BaiduNetdiskDownload\05-MySQL\bjpowernode.sql // 导入文件</span><br><span class="line">mysql&gt; drop database database1</span><br></pre></td></tr></table></figure>

<p>表结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+----------------+</span><br><span class="line">| Tables_in_dljd |</span><br><span class="line">+----------------+</span><br><span class="line">| dept           |</span><br><span class="line">| emp            |</span><br><span class="line">| salgrade       |</span><br><span class="line">+----------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc dept;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| DEPTNO | int         | NO   | PRI | NULL    |       | # 部门编号</span><br><span class="line">| DNAME  | varchar(14) | YES  |     | NULL    |       | # 部门名</span><br><span class="line">| LOC    | varchar(13) | YES  |     | NULL    |       | # 部门位置</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc emp;</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field    | Type        | Null | Key | Default | Extra |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| EMPNO    | int         | NO   | PRI | NULL    |       |</span><br><span class="line">| ENAME    | varchar(10) | YES  |     | NULL    |       |</span><br><span class="line">| JOB      | varchar(9)  | YES  |     | NULL    |       |</span><br><span class="line">| MGR      | int         | YES  |     | NULL    |       |</span><br><span class="line">| HIREDATE | date        | YES  |     | NULL    |       |</span><br><span class="line">| SAL      | double(7,2) | YES  |     | NULL    |       |</span><br><span class="line">| COMM     | double(7,2) | YES  |     | NULL    |       |</span><br><span class="line">| DEPTNO   | int         | YES  |     | NULL    |       |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc salgrade;</span><br><span class="line">+-------+------+------+-----+---------+-------+</span><br><span class="line">| Field | Type | Null | Key | Default | Extra |</span><br><span class="line">+-------+------+------+-----+---------+-------+</span><br><span class="line">| GRADE | int  | YES  |     | NULL    |       | # 薪资等级</span><br><span class="line">| LOSAL | int  | YES  |     | NULL    |       |</span><br><span class="line">| HISAL | int  | YES  |     | NULL    |       | # 最高薪资</span><br><span class="line">+-------+------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>查看创建该表时的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show create table salgrade;</span><br><span class="line">#-----------------------------------------</span><br><span class="line">CREATE TABLE `salgrade` (</span><br><span class="line">  `GRADE` int DEFAULT NULL,</span><br><span class="line">  `LOSAL` int DEFAULT NULL,</span><br><span class="line">  `HISAL` int DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure>

<h1 id="sql-语句"><a href="#sql-语句" class="headerlink" title="sql 语句"></a>sql 语句</h1><h2 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h2><ul>
<li>DQL（数据查询语言）：查询语句</li>
<li>DML（数据操作语言）：增删改查</li>
<li>DDL（数据定义语言）：对表结构增删改查</li>
<li>TCL （事务控制语言）：commit提交事务，rollback回滚事务</li>
<li>DCL（数据控制语言）：grant授权、revoke撤销授权</li>
</ul>
<p>不区分大小写</p>
<h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><p>基础用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select field_name1, field_name2 from table_name;</span><br><span class="line">select * from table_name; # 开发中不建议使用，效率低</span><br></pre></td></tr></table></figure>

<p>字段参与运算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select field_name1 * 12 as field_name3, field_name2 from table_name;</span><br><span class="line">select ename, sal * 12 as yearsal from emp;  # as 可省略</span><br><span class="line">select ename, sal * 12 as &#x27;年薪&#x27; from emp;  # 单引号括起作为字符串，不要用双引号，因为不通用</span><br></pre></td></tr></table></figure>

<p>条件查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename from emp where sal = 5000;</span><br><span class="line">select sal from emp where ename = &#x27;king&#x27;;</span><br><span class="line">select ename from emp where sal &lt;&gt; 5000;  # 不等于号 也可以用!=</span><br><span class="line">select ename from emp where sal &gt;= 1000 and sal &lt;= 3000;</span><br><span class="line">select ename from emp where sal between 1000 and 3000;  # 闭区间，且左小右大</span><br><span class="line">select ename from emp where ename between &#x27;A&#x27; and &#x27;B&#x27;;  # 左闭右开，只比了第一个字符</span><br></pre></td></tr></table></figure>

<ul>
<li><p>null不是值，条件查询时不能用等号，只能用<code>is null</code>或<code>is not null</code>，虽然TURNER的comm是0，但不为null	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select ename, comm from emp where comm is not null;</span><br><span class="line">+--------+---------+</span><br><span class="line">| ename  | comm    |</span><br><span class="line">+--------+---------+</span><br><span class="line">| ALLEN  |  300.00 |</span><br><span class="line">| WARD   |  500.00 |</span><br><span class="line">| MARTIN | 1400.00 |</span><br><span class="line">| TURNER |    0.00 |</span><br><span class="line">+--------+---------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>and优先级大于or，也可以使用小括号给小括号。</p>
</li>
<li><p>in  等同于 or，判断 in 后的的几种值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename from emp where sal = 1000 and sal = 3000;</span><br><span class="line">select ename from emp where sal in (1000, 3000, 2000);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="模糊查询Like"><a href="#模糊查询Like" class="headerlink" title="模糊查询Like"></a>模糊查询Like</h3><ul>
<li>%：表示任意多个字符</li>
<li>_：表示任意一个字符</li>
<li>也可以使用转义字符，查询以上两个字符本身。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select ename from emp where ename like &#x27;%o%&#x27;; # 找到名字带o的</span><br><span class="line">+-------+</span><br><span class="line">| ename |</span><br><span class="line">+-------+</span><br><span class="line">| JONES |</span><br><span class="line">| SCOTT |</span><br><span class="line">| FORD  |</span><br><span class="line">+-------+</span><br><span class="line">mysql&gt; select ename from emp where ename like &#x27;_A%&#x27;; # 找到名字第二个字母为a的</span><br><span class="line">+--------+</span><br><span class="line">| ename  |</span><br><span class="line">+--------+</span><br><span class="line">| WARD   |</span><br><span class="line">| MARTIN |</span><br><span class="line">| JAMES  |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure>

<h3 id="数据排序-order-by"><a href="#数据排序-order-by" class="headerlink" title="数据排序 order by"></a>数据排序 order by</h3><p>注意：排序发生在分组之后。</p>
<p>升序asc（默认） &#x2F; 降序desc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认升序</span><br><span class="line">mysql&gt; select ename,sal from emp order by sal;</span><br><span class="line"># 关键词指定升序降序</span><br><span class="line">mysql&gt; select ename,sal from emp order by sal asc;</span><br><span class="line">mysql&gt; select ename,sal from emp order by sal desc;</span><br><span class="line"># 分段排序，先升序排序sal，若sal相同，则降序排序asc。</span><br><span class="line">select ename,sal from emp order by sal, ename asc;</span><br><span class="line">+--------+---------+</span><br><span class="line">| ename  | sal     |</span><br><span class="line">+--------+---------+</span><br><span class="line">| SMITH  |  800.00 |</span><br><span class="line">| JAMES  |  950.00 |</span><br><span class="line">| ADAMS  | 1100.00 |</span><br><span class="line">| MARTIN | 1250.00 |</span><br><span class="line">| WARD   | 1250.00 |</span><br><span class="line">| MILLER | 1300.00 |</span><br><span class="line">| TURNER | 1500.00 |</span><br><span class="line">| ALLEN  | 1600.00 |</span><br><span class="line">| CLARK  | 2450.00 |</span><br><span class="line">| BLAKE  | 2850.00 |</span><br><span class="line">| JONES  | 2975.00 |</span><br><span class="line">| FORD   | 3000.00 |</span><br><span class="line">| SCOTT  | 3000.00 |</span><br><span class="line">| KING   | 5000.00 |</span><br><span class="line">+--------+---------+</span><br><span class="line"># 先from 后 where 最后 order</span><br><span class="line">select ename, sal from emp where job = &#x27;salesman&#x27; order by sal desc;</span><br><span class="line"># 验证执行顺序</span><br><span class="line">select ename, job, sal as salary from emp where job = &#x27;salesman&#x27; order by salary desc;</span><br></pre></td></tr></table></figure>

<h3 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h3><p><strong>分组函数会自动忽略null</strong>。又称为多行执行函数，输入多行输出一行，只有如下五种：</p>
<ul>
<li>sum</li>
<li>avg</li>
<li>max&#x2F;min</li>
<li>count</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select count(*) from emp; #</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|       14 |</span><br><span class="line">+----------+</span><br><span class="line"># 分组函数自动忽略null，所以count(comm)只有4个。</span><br><span class="line">mysql&gt; select count(comm), sum(comm), avg(comm) from emp;</span><br><span class="line">+-------------+-----------+------------+</span><br><span class="line">| count(comm) | sum(comm) | avg(comm)  |</span><br><span class="line">+-------------+-----------+------------+</span><br><span class="line">|           4 |   2200.00 | 550.000000 |</span><br><span class="line">+-------------+-----------+------------+</span><br><span class="line"># 多余的操作：</span><br><span class="line">mysql&gt; select count(comm) from emp where comm is not null;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>区别</p>
<ul>
<li><code>count(comm)</code>统计某个字段的非空数据。</li>
<li><code>count(*)</code>一定是统计总记录条数，而不是某个字段中数据的个数，即与某字段无关，即使为所有字段值都为null。</li>
</ul>
<p>单行处理函数中null的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 任何数据库，null参与数据运算，最后结果都是null</span><br><span class="line">mysql&gt; select ename, (sal+comm) * 12 as yearsal from emp;</span><br><span class="line">+--------+----------+</span><br><span class="line">| ename  | yearsal  |</span><br><span class="line">+--------+----------+</span><br><span class="line">| SMITH  |     NULL |</span><br><span class="line">| ALLEN  | 22800.00 |</span><br><span class="line">| WARD   | 21000.00 |</span><br><span class="line">| JONES  |     NULL |</span><br><span class="line">| MARTIN | 31800.00 |</span><br><span class="line">| BLAKE  |     NULL |</span><br><span class="line">| CLARK  |     NULL |</span><br><span class="line">| SCOTT  |     NULL |</span><br><span class="line">| KING   |     NULL |</span><br><span class="line">| TURNER | 18000.00 |</span><br><span class="line">| ADAMS  |     NULL |</span><br><span class="line">| JAMES  |     NULL |</span><br><span class="line">| FORD   |     NULL |</span><br><span class="line">| MILLER |     NULL |</span><br><span class="line">+--------+----------+</span><br><span class="line"># 解决方式，ifnull()函数</span><br><span class="line">	# 用法：ifnull(可能是空的数据，若是空被替换的数据)</span><br><span class="line">mysql&gt; select ename, (sal+ifnull(comm,0)) * 12 as yearsal from emp;</span><br><span class="line">+--------+----------+</span><br><span class="line">| ename  | yearsal  |</span><br><span class="line">+--------+----------+</span><br><span class="line">| SMITH  |  9600.00 |</span><br><span class="line">| ALLEN  | 22800.00 |</span><br><span class="line">| WARD   | 21000.00 |</span><br><span class="line">| JONES  | 35700.00 |</span><br><span class="line">| MARTIN | 31800.00 |</span><br><span class="line">| BLAKE  | 34200.00 |</span><br><span class="line">| CLARK  | 29400.00 |</span><br><span class="line">| SCOTT  | 36000.00 |</span><br><span class="line">| KING   | 60000.00 |</span><br><span class="line">| TURNER | 18000.00 |</span><br><span class="line">| ADAMS  | 13200.00 |</span><br><span class="line">| JAMES  | 11400.00 |</span><br><span class="line">| FORD   | 36000.00 |</span><br><span class="line">| MILLER | 15600.00 |</span><br><span class="line">+--------+----------+</span><br></pre></td></tr></table></figure>

<h4 id="group-by-和-having"><a href="#group-by-和-having" class="headerlink" title="group by 和 having"></a>group by 和 having</h4><ul>
<li>group by： 按照某个&#x2F;些字段进行分组</li>
<li>having：对分组后的数据再次过滤，<ul>
<li><u>作用和where类似，但having一定和group by一起用。</u></li>
<li><u>where在group by执行前执行，having则在group by执行后执行。</u></li>
<li><u>为了效率尽量使用where先过滤 而非having后过滤。</u></li>
</ul>
</li>
</ul>
<h5 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h5><p><em><u>当一条语句有group by分组，select后只能跟分组函数和参与分组的字段</u>。</em></p>
<p>见问题与解决方法.md文件的错误2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找出每个工作岗位的最高薪资</span><br><span class="line">mysql&gt; select max(sal), job from emp group by job;</span><br><span class="line">+----------+-----------+</span><br><span class="line">| max(sal) | job       |</span><br><span class="line">+----------+-----------+</span><br><span class="line">|  1300.00 | CLERK     |</span><br><span class="line">|  1600.00 | SALESMAN  |</span><br><span class="line">|  2975.00 | MANAGER   |</span><br><span class="line">|  3000.00 | ANALYST   |</span><br><span class="line">|  5000.00 | PRESIDENT |</span><br><span class="line">+----------+-----------+</span><br><span class="line"></span><br><span class="line"># 找出每个工作岗位的最高薪资, 多查询了ename字段，Oracle会报错，mysql可执行但无意义，数据是错误的（此处新版本会报错）</span><br><span class="line">mysql&gt; select ename, max(sal), job from emp group by job;</span><br><span class="line"># 当一条语句有group by，select后只能跟分组函数和参与分组的字段。</span><br></pre></td></tr></table></figure>

<p>多个字段联合分组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select deptno, job, sal from emp order by deptno, job;</span><br><span class="line">+--------+-----------+---------+</span><br><span class="line">| deptno | job       | sal     |</span><br><span class="line">+--------+-----------+---------+</span><br><span class="line">|     10 | CLERK     | 1300.00 |</span><br><span class="line">|     10 | MANAGER   | 2450.00 |</span><br><span class="line">|     10 | PRESIDENT | 5000.00 |</span><br><span class="line">|     20 | ANALYST   | 3000.00 |</span><br><span class="line">|     20 | ANALYST   | 3000.00 |</span><br><span class="line">|     20 | CLERK     |  800.00 |</span><br><span class="line">|     20 | CLERK     | 1100.00 |</span><br><span class="line">|     20 | MANAGER   | 2975.00 |</span><br><span class="line">|     30 | CLERK     |  950.00 |</span><br><span class="line">|     30 | MANAGER   | 2850.00 |</span><br><span class="line">|     30 | SALESMAN  | 1600.00 |</span><br><span class="line">|     30 | SALESMAN  | 1250.00 |</span><br><span class="line">|     30 | SALESMAN  | 1250.00 |</span><br><span class="line">|     30 | SALESMAN  | 1500.00 |</span><br><span class="line">+--------+-----------+---------+</span><br><span class="line"># 找出每个部门deptno中，不同工作岗位job最高薪资</span><br><span class="line">mysql&gt; select deptno, job, max(sal) from emp group by deptno,job order by deptno, job;</span><br><span class="line">+--------+-----------+----------+</span><br><span class="line">| deptno | job       | max(sal) |</span><br><span class="line">+--------+-----------+----------+</span><br><span class="line">|     10 | CLERK     |  1300.00 |</span><br><span class="line">|     10 | MANAGER   |  2450.00 |</span><br><span class="line">|     10 | PRESIDENT |  5000.00 |</span><br><span class="line">|     20 | ANALYST   |  3000.00 |</span><br><span class="line">|     20 | CLERK     |  1100.00 |</span><br><span class="line">|     20 | MANAGER   |  2975.00 |</span><br><span class="line">|     30 | CLERK     |   950.00 |</span><br><span class="line">|     30 | MANAGER   |  2850.00 |</span><br><span class="line">|     30 | SALESMAN  |  1600.00 |</span><br><span class="line">+--------+-----------+----------+</span><br></pre></td></tr></table></figure>

<h5 id="having"><a href="#having" class="headerlink" title="having"></a>having</h5><p>为了过滤分组后的数据而存在，不可以单独出现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找出每个部分的最高薪资，要求显示薪资大于2900的数据</span><br><span class="line"># having</span><br><span class="line">mysql&gt; select max(sal), deptno from emp group by deptno having max(sal) &gt; 2900;</span><br><span class="line">+----------+--------+</span><br><span class="line">| max(sal) | deptno |</span><br><span class="line">+----------+--------+</span><br><span class="line">|  3000.00 |     20 |</span><br><span class="line">|  5000.00 |     10 |</span><br><span class="line">+----------+--------+</span><br><span class="line"># where</span><br><span class="line">mysql&gt; select max(sal), deptno from emp where sal &gt; 2900 group by deptno;</span><br><span class="line">+----------+--------+</span><br><span class="line">| max(sal) | deptno |</span><br><span class="line">+----------+--------+</span><br><span class="line">|  3000.00 |     20 |</span><br><span class="line">|  5000.00 |     10 |</span><br><span class="line">+----------+--------+</span><br></pre></td></tr></table></figure>

<ul>
<li>此处having效率比where低，因为where对过滤的数据分组，再执行分组函数；而having执行了分组函数后，才进行过滤。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找出每个部门的平均薪资，要求显示薪资大于2000的数据</span><br><span class="line">mysql&gt; select avg(sal), deptno from emp group by deptno having avg(sal) &gt; 2000;</span><br><span class="line">+-------------+--------+</span><br><span class="line">| avg(sal)    | deptno |</span><br><span class="line">+-------------+--------+</span><br><span class="line">| 2175.000000 |     20 |</span><br><span class="line">| 2916.666667 |     10 |</span><br><span class="line">+-------------+--------+</span><br></pre></td></tr></table></figure>

<ul>
<li>此处只能用having，而无法使用where过滤，原因如下：</li>
</ul>
<h5 id="分组函数不能直接使用在where语句。"><a href="#分组函数不能直接使用在where语句。" class="headerlink" title="分组函数不能直接使用在where语句。"></a><strong>分组函数不能直接使用在where语句。</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找出工资大于平均工资的员工</span><br><span class="line">select ename, sal from emp where sal &gt; avg(sal);  # ERROR 1111 (HY000): Invalid use of group function</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<ul>
<li>执行顺序为：where-&gt;group by-&gt;分组函数，<strong>分组函数一般都会和group by 联合使用，并在group by执行后执行</strong>，可以认为没用group by时，整张表也会使用一个默认的group by自成一组。所以where内不能用分组函数，因为还没有group by分组。</li>
</ul>
<p>解决方法：使用子查询语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找出工资大于平均工资的员工</span><br><span class="line">mysql&gt; select ename, sal from emp where sal &gt; (select avg(sal) from emp);</span><br><span class="line">+-------+---------+</span><br><span class="line">| ename | sal     |</span><br><span class="line">+-------+---------+</span><br><span class="line">| JONES | 2975.00 |</span><br><span class="line">| BLAKE | 2850.00 |</span><br><span class="line">| CLARK | 2450.00 |</span><br><span class="line">| SCOTT | 3000.00 |</span><br><span class="line">| KING  | 5000.00 |</span><br><span class="line">| FORD  | 3000.00 |</span><br><span class="line">+-------+---------+</span><br></pre></td></tr></table></figure>

<h3 id="去重distinct"><a href="#去重distinct" class="headerlink" title="去重distinct"></a>去重distinct</h3><p>只能出现在所有字段最前面，表示对后面的字段联合去重，联合起来的字段一起相同才会被去除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select distinct job from emp;</span><br><span class="line">+-----------+</span><br><span class="line">| job       |</span><br><span class="line">+-----------+</span><br><span class="line">| CLERK     |</span><br><span class="line">| SALESMAN  |</span><br><span class="line">| MANAGER   |</span><br><span class="line">| ANALYST   |</span><br><span class="line">| PRESIDENT |</span><br><span class="line">+-----------+</span><br><span class="line"># distinct 只能出现在所有字段最前面，表示对后面的字段联合去重</span><br><span class="line">mysql&gt; select distinct deptno, job from emp order by deptno;</span><br><span class="line">+--------+-----------+</span><br><span class="line">| deptno | job       |</span><br><span class="line">+--------+-----------+</span><br><span class="line">|     10 | CLERK     |</span><br><span class="line">|     10 | MANAGER   |</span><br><span class="line">|     10 | PRESIDENT |</span><br><span class="line">|     20 | ANALYST   |</span><br><span class="line">|     20 | CLERK     |</span><br><span class="line">|     20 | MANAGER   |</span><br><span class="line">|     30 | CLERK     |</span><br><span class="line">|     30 | MANAGER   |</span><br><span class="line">|     30 | SALESMAN  |</span><br><span class="line">+--------+-----------+</span><br><span class="line"># 统计岗位的数量，distinct输出是多行，所以可以直接交给分组函数</span><br><span class="line">mysql&gt; select count(distinct job) from emp;</span><br><span class="line">+---------------------+</span><br><span class="line">| count(distinct job) |</span><br><span class="line">+---------------------+</span><br><span class="line">|                   5 |</span><br><span class="line">+---------------------+ </span><br></pre></td></tr></table></figure>



<h2 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h2><p>CAST函数用于将值从一种数据类型转换为表达式中指定的另一种数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CAST(value AS datatype)</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230914000048586.png" alt="image-20230914000048586"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT CAST(&#x27;2022-04-27&#x27; AS DATETIME); </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>实际开发中一般是多表联合查询出最终的结果</p>
<h3 id="连接查询分类"><a href="#连接查询分类" class="headerlink" title="连接查询分类"></a>连接查询分类</h3><ul>
<li>语法<ul>
<li>SQL92</li>
<li>SQL99</li>
</ul>
</li>
<li>连接方式<ul>
<li>内连接<ul>
<li>等值连接</li>
<li>非等值连接</li>
<li>自连接</li>
</ul>
</li>
<li>外连接<ul>
<li>左外&#x2F;左连接</li>
<li>右外&#x2F;有链接</li>
</ul>
</li>
<li>全连接（很少用</li>
</ul>
</li>
</ul>
<p>表连接的现象：笛卡尔积现象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 两张表联合查询没有限制条件，结果的条数是两张表条 数的乘积</span><br><span class="line">mysql&gt; select ename,dname from emp,dept;</span><br></pre></td></tr></table></figure>

<p>避免笛卡尔积现象的直接方式是使用条件过滤，但不会减少记录的匹配次数，只会显示有效的记录。</p>
<p>此外此处使用了表的别名，执行效率高，可读性高</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找出每个员工的姓名与部门名</span><br><span class="line">mysql&gt; select e.ename, d.dname from emp e, dept d where e.deptno = d.deptno;  #sql92写法，不使用</span><br><span class="line">+--------+------------+</span><br><span class="line">| ename  | dname      |</span><br><span class="line">+--------+------------+</span><br><span class="line">| SMITH  | RESEARCH   |</span><br><span class="line">| ALLEN  | SALES      |</span><br><span class="line">| WARD   | SALES      |</span><br><span class="line">| JONES  | RESEARCH   |</span><br><span class="line">| MARTIN | SALES      |</span><br><span class="line">| BLAKE  | SALES      |</span><br><span class="line">| CLARK  | ACCOUNTING |</span><br><span class="line">| SCOTT  | RESEARCH   |</span><br><span class="line">| KING   | ACCOUNTING |</span><br><span class="line">| TURNER | SALES      |</span><br><span class="line">| ADAMS  | RESEARCH   |</span><br><span class="line">| JAMES  | SALES      |</span><br><span class="line">| FORD   | RESEARCH   |</span><br><span class="line">| MILLER | ACCOUNTING |</span><br><span class="line">+--------+------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<h3 id="内连接——等值连接：条件是等量关系"><a href="#内连接——等值连接：条件是等量关系" class="headerlink" title="内连接——等值连接：条件是等量关系"></a>内连接——等值连接：条件是等量关系</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> # sql99语法，where和连接的条件分离了，更常用</span><br><span class="line"> # 语法： mysql&gt; ... A join B on 连接条件 where ...</span><br><span class="line">mysql&gt; select e.ename, d.dname from emp e join dept d on e.deptno = d.deptno;</span><br><span class="line"> # inner可以省略，带着inner可读性更好</span><br><span class="line">mysql&gt; select e.ename, d.dname from emp e inner join dept d on e.deptno = d.deptno;</span><br></pre></td></tr></table></figure>

<h3 id="内连接——非等值连接"><a href="#内连接——非等值连接" class="headerlink" title="内连接——非等值连接"></a>内连接——非等值连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找出每个员工的工资等级，要求显示员工名，工资，工资等级</span><br><span class="line">mysql&gt; select e.ename,e.sal,s.grade from emp e inner join salgrade s on e.sal between s.losal and s.hisal;</span><br><span class="line">+--------+---------+-------+</span><br><span class="line">| ename  | sal     | grade |</span><br><span class="line">+--------+---------+-------+</span><br><span class="line">| SMITH  |  800.00 |     1 |</span><br><span class="line">| ALLEN  | 1600.00 |     3 |</span><br><span class="line">| WARD   | 1250.00 |     2 |</span><br><span class="line">| JONES  | 2975.00 |     4 |</span><br><span class="line">| MARTIN | 1250.00 |     2 |</span><br><span class="line">| BLAKE  | 2850.00 |     4 |</span><br><span class="line">| CLARK  | 2450.00 |     4 |</span><br><span class="line">| SCOTT  | 3000.00 |     4 |</span><br><span class="line">| KING   | 5000.00 |     5 |</span><br><span class="line">| TURNER | 1500.00 |     3 |</span><br><span class="line">| ADAMS  | 1100.00 |     1 |</span><br><span class="line">| JAMES  |  950.00 |     1 |</span><br><span class="line">| FORD   | 3000.00 |     4 |</span><br><span class="line">| MILLER | 1300.00 |     2 |</span><br><span class="line">+--------+---------+-------+</span><br></pre></td></tr></table></figure>

<h3 id="自连接：一张表看成两张表，自己连接自己。"><a href="#自连接：一张表看成两张表，自己连接自己。" class="headerlink" title="自连接：一张表看成两张表，自己连接自己。"></a>自连接：一张表看成两张表，自己连接自己。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找出每个员工上级领导，要求显示员工名和对应领导名</span><br><span class="line">mysql&gt; select a.ename,b.ename from emp a inner join emp b on a.mgr = b.empno;</span><br><span class="line">+--------+-------+</span><br><span class="line">| ename  | ename |</span><br><span class="line">+--------+-------+</span><br><span class="line">| SMITH  | FORD  |</span><br><span class="line">| ALLEN  | BLAKE |</span><br><span class="line">| WARD   | BLAKE |</span><br><span class="line">| JONES  | KING  |</span><br><span class="line">| MARTIN | BLAKE |</span><br><span class="line">| BLAKE  | KING  |</span><br><span class="line">| CLARK  | KING  |</span><br><span class="line">| SCOTT  | JONES |</span><br><span class="line">| TURNER | BLAKE |</span><br><span class="line">| ADAMS  | SCOTT |</span><br><span class="line">| JAMES  | BLAKE |</span><br><span class="line">| FORD   | JONES |</span><br><span class="line">| MILLER | CLARK |</span><br><span class="line">+--------+-------+</span><br><span class="line"># a是员工表，b是领导表，实际上是一张表，因为员工和领导都在一张表里</span><br><span class="line"># 因此join的条件是 a.mgr领导编号 = b.empno 员工编号</span><br></pre></td></tr></table></figure>

<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>A B表内连接时：</p>
<ul>
<li>内连接：凡是A和B匹配的记录就能被查询出来，AB没有主副之分，两表平等</li>
<li>外连接：有主副之分，主要查询主表，如果副表中的数据没有和主表匹配上，副表自动模拟出NULL与之匹配。<ul>
<li>左外连接：左边表是主表</li>
<li>右外连接：右表是主表</li>
<li>左连接会有右连接的写法，右连接会有左连接的写法</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找出每个员工的上级领导，没有上级领导时该字段为null。</span><br><span class="line">mysql&gt; select a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27; from emp a left join emp b on a.mgr = b.empno;  </span><br><span class="line">+--------+-------+</span><br><span class="line">| 员工   | 领导  |</span><br><span class="line">+--------+-------+</span><br><span class="line">| SMITH  | FORD  |</span><br><span class="line">| ALLEN  | BLAKE |</span><br><span class="line">| WARD   | BLAKE |</span><br><span class="line">| JONES  | KING  |</span><br><span class="line">| MARTIN | BLAKE |</span><br><span class="line">| BLAKE  | KING  |</span><br><span class="line">| CLARK  | KING  |</span><br><span class="line">| SCOTT  | JONES |</span><br><span class="line">| KING   | NULL  |  # king是老板，所以没有上级领导</span><br><span class="line">| TURNER | BLAKE |</span><br><span class="line">| ADAMS  | SCOTT |</span><br><span class="line">| JAMES  | BLAKE |</span><br><span class="line">| FORD   | JONES |</span><br><span class="line">| MILLER | CLARK |</span><br><span class="line">+--------+-------+</span><br><span class="line">mysql&gt; select a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27; from emp a left outer join emp b on a.mgr = b.empno;  # outer可以省略</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找出没有员工的部门</span><br><span class="line"># 左连接</span><br><span class="line">mysql&gt; select d.deptno, d.dname from dept d left outer join emp e on d.deptno = e.deptno where e.empno is null;</span><br><span class="line">+--------+------------+</span><br><span class="line">| deptno | dname      |</span><br><span class="line">+--------+------------+</span><br><span class="line">|     40 | OPERATIONS |</span><br><span class="line">+--------+------------+</span><br><span class="line"># 右连接</span><br><span class="line">mysql&gt; select d.deptno, d.dname from emp e right outer join dept d on d.deptno = e.deptno where e.empno is null;</span><br><span class="line">+--------+------------+</span><br><span class="line">| deptno | dname      |</span><br><span class="line">+--------+------------+</span><br><span class="line">|     40 | OPERATIONS |</span><br><span class="line">+--------+------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三张表连接"><a href="#三张表连接" class="headerlink" title="三张表连接"></a>三张表连接</h3><p><code>select ...from A join B on ... join C on ...</code> ，A先跟B再跟C连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找出每个员工的部门名称 以及 工资等级</span><br><span class="line">mysql&gt; select e.ename, d.dname, s.grade </span><br><span class="line">from emp e </span><br><span class="line">join dept d on e.deptno = d.deptno </span><br><span class="line">join salgrade s on e.sal between s.losal and s.hisal;</span><br><span class="line">+--------+------------+-------+</span><br><span class="line">| ename  | dname      | grade |</span><br><span class="line">+--------+------------+-------+</span><br><span class="line">| SMITH  | RESEARCH   |     1 |</span><br><span class="line">| ALLEN  | SALES      |     3 |</span><br><span class="line">| WARD   | SALES      |     2 |</span><br><span class="line">| JONES  | RESEARCH   |     4 |</span><br><span class="line">| MARTIN | SALES      |     2 |</span><br><span class="line">| BLAKE  | SALES      |     4 |</span><br><span class="line">| CLARK  | ACCOUNTING |     4 |</span><br><span class="line">| SCOTT  | RESEARCH   |     4 |</span><br><span class="line">| KING   | ACCOUNTING |     5 |</span><br><span class="line">| TURNER | SALES      |     3 |</span><br><span class="line">| ADAMS  | RESEARCH   |     1 |</span><br><span class="line">| JAMES  | SALES      |     1 |</span><br><span class="line">| FORD   | RESEARCH   |     4 |</span><br><span class="line">| MILLER | ACCOUNTING |     2 |</span><br><span class="line">+--------+------------+-------+</span><br><span class="line"># 找出每个员工的部门名称、 工资等级、 以及上级领导</span><br><span class="line">mysql&gt; select e.ename, d.dname, s.grade, ee.ename &#x27;领导&#x27;</span><br><span class="line">    -&gt; from emp e</span><br><span class="line">    -&gt; join dept d on e.deptno = d.deptno</span><br><span class="line">    -&gt; join salgrade s on e.sal between s.losal and s.hisal</span><br><span class="line">    -&gt; left join emp ee on e.mgr = ee.empno;</span><br><span class="line">+--------+------------+-------+-------+</span><br><span class="line">| ename  | dname      | grade | 领导  |</span><br><span class="line">+--------+------------+-------+-------+</span><br><span class="line">| SMITH  | RESEARCH   |     1 | FORD  |</span><br><span class="line">| ALLEN  | SALES      |     3 | BLAKE |</span><br><span class="line">| WARD   | SALES      |     2 | BLAKE |</span><br><span class="line">| JONES  | RESEARCH   |     4 | KING  |</span><br><span class="line">| MARTIN | SALES      |     2 | BLAKE |</span><br><span class="line">| BLAKE  | SALES      |     4 | KING  |</span><br><span class="line">| CLARK  | ACCOUNTING |     4 | KING  |</span><br><span class="line">| SCOTT  | RESEARCH   |     4 | JONES |</span><br><span class="line">| KING   | ACCOUNTING |     5 | NULL  |</span><br><span class="line">| TURNER | SALES      |     3 | BLAKE |</span><br><span class="line">| ADAMS  | RESEARCH   |     1 | SCOTT |</span><br><span class="line">| JAMES  | SALES      |     1 | BLAKE |</span><br><span class="line">| FORD   | RESEARCH   |     4 | JONES |</span><br><span class="line">| MILLER | ACCOUNTING |     2 | CLARK |</span><br><span class="line">+--------+------------+-------+-------+</span><br></pre></td></tr></table></figure>

<h3 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h3><p>实际上是外连接时，左右表都实行左右外联，使得如果 “left_table” 表中的行在 “right_table” 中没有匹配或者 “right_table” 表中的行在</p>
<p>“left_table” 表中没有匹配，也会列出这些行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># key word：</span><br><span class="line">full join</span><br></pre></td></tr></table></figure>





<p>insert into student_table values(‘1009’ , ‘李四’, ‘2000-01-01’, ‘男’);<br>insert into student_table values(‘1010’ , ‘李四’, ‘2001-01-01’, ‘男’);<br>insert into student_table values(‘1006’ , ‘王五’, ‘2000-08-06’ , ‘女’);<br>insert into student_table values(‘1008’ , ‘张三’, ‘2002-12-01’, ‘女’);<br>insert into student_table values(‘1012’ , ‘张三’, ‘2001-12-01’, ‘女’);<br>insert into student_table values(‘1011’ , ‘李四’, ‘2002-08-06’ , ‘女’);<br>insert into student_table values(‘1013’ , ‘赵六’ ,’2000-09-06’ , ‘男’);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from</span><br><span class="line"></span><br><span class="line">select t1.*,t2.*</span><br><span class="line">from (</span><br><span class="line">select * from student_table where sex = &#x27;男&#x27; ) t1 </span><br><span class="line">left join </span><br><span class="line">(select * from student_table where sex = &#x27;女&#x27;) t2 </span><br><span class="line">on t1.name = t2.name </span><br><span class="line"></span><br><span class="line">union all</span><br><span class="line"></span><br><span class="line">select t1.*,t2.*</span><br><span class="line">from (</span><br><span class="line">select * from student_table where sex = &#x27;男&#x27; ) t1 </span><br><span class="line">right join </span><br><span class="line">(select * from student_table where sex = &#x27;女&#x27;) t2 </span><br><span class="line">on t1.name = t2.name;</span><br></pre></td></tr></table></figure>



<p>select t1.<em>,t2.</em><br>from (<br>select * from student_table where sex &#x3D; ‘男’ ) t1<br>left join<br>(select * from student_table where sex &#x3D; ‘女’)t2<br>on t1.name &#x3D; t2.name<br>union<br>select t1.<em>,t2.</em><br>from (<br>select * from student_table where sex &#x3D; ‘男’ ) t1<br>right join<br>(select * from student_table where sex &#x3D; ‘女’)t2<br>on t1.name &#x3D; t2.name;</p>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>select中嵌套select，被嵌套的select语句称为子查询。理解为：select后就是一张临时的新表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">	..(select)..</span><br><span class="line">from</span><br><span class="line">	..(select)..  # 查询结果将会当成临时表</span><br><span class="line">where</span><br><span class="line">	..(select)..</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># where：找出高于平均薪资的员工信息</span><br><span class="line">mysql&gt; select * from emp where sal &gt; (select avg(sal) from emp);</span><br><span class="line"># from：找出每个部门平均薪水的薪资等级</span><br><span class="line">select a.avgsal, s.grade </span><br><span class="line">from (select avg(sal) avgsal from emp group by deptno) a </span><br><span class="line">join salgrade s </span><br><span class="line">where a.avgsal between s.losal and s.hisal ;</span><br><span class="line">+-------------+-------+</span><br><span class="line">| avgsal      | grade |</span><br><span class="line">+-------------+-------+</span><br><span class="line">| 2175.000000 |     4 |</span><br><span class="line">| 1566.666667 |     3 |</span><br><span class="line">| 2916.666667 |     4 |</span><br><span class="line">+-------------+-------+</span><br><span class="line"></span><br><span class="line"># 找出每个部门平均的薪资等级</span><br><span class="line"># 正确结果，但错误写法，因为没必要from后当成临时表</span><br><span class="line">mysql&gt; select avg(tmp.grade) </span><br><span class="line">	from </span><br><span class="line">(select e.ename, s.grade, e.deptno from emp e join salgrade s on e.sal between s.losal and s.hisal) tmp </span><br><span class="line">	group by tmp.deptno;</span><br><span class="line">+----------------+</span><br><span class="line">| avg(tmp.grade) |</span><br><span class="line">+----------------+</span><br><span class="line">|         2.8000 |</span><br><span class="line">|         2.5000 |</span><br><span class="line">|         3.6667 |</span><br><span class="line">+----------------+</span><br><span class="line"># select时，s.grade，e.deptno信息已经存在，没必要当成临时表tmp再嵌套</span><br><span class="line">select avg(s.grade), e.deptno from emp e join salgrade s on e.sal between s.losal and s.hisal group by e.deptno;</span><br></pre></td></tr></table></figure>



<h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><p>可以将查询结果集相加，默认去重</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找出工作岗位是SALESMAN和MANAGER的员工</span><br><span class="line">select * from emp where job = &#x27;MANAGER&#x27; or job = &#x27;SALESMAN&#x27;;</span><br><span class="line">select * from emp where job in (&#x27;MANAGER&#x27;, &#x27;SALESMAN&#x27;);</span><br><span class="line"></span><br><span class="line">select * from emp where job = &#x27;MANAGER&#x27; </span><br><span class="line">union</span><br><span class="line">select * from emp where job = &#x27;SALESMAN&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ...</span><br><span class="line">union all # 不去重</span><br><span class="line">select ...</span><br></pre></td></tr></table></figure>



<p>union可以解决 or 和 in 无法解决的：两张不相干的表中数据拼接在一起，虽然可能意义不大。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 没有意义，但能拼接，列数不同不能拼接</span><br><span class="line">select ename from emp</span><br><span class="line">union</span><br><span class="line">select dname from dept;</span><br></pre></td></tr></table></figure>



<p>union中只能在最后有一个order by排序，除非对其中一个select加括号，将order by放入其中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 不合法</span><br><span class="line">select ... order by ...</span><br><span class="line">union</span><br><span class="line">select ... order by ...</span><br><span class="line"># 合法，先对第一个select的排序，然后对union后的整体排序</span><br><span class="line">(select ... order by ...)</span><br><span class="line">union</span><br><span class="line">select ... order by ...</span><br><span class="line"># 合法，先括号子查询，后union</span><br><span class="line">(select ... order by ...)</span><br><span class="line">union</span><br><span class="line">(select ... order by ...)</span><br><span class="line">order by ...</span><br></pre></td></tr></table></figure>



<h2 id="limit（特有）"><a href="#limit（特有）" class="headerlink" title="limit（特有）"></a>limit（特有）</h2><p>作用：取部分数据。</p>
<p>mysql特有，也是sql语句最后执行的环节，oracle有相同的机制<code>rownum</code>，分页查询用。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit startIndex, length</span><br><span class="line"># startIndex表示起始位置</span><br><span class="line"># length表示取几个</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找出工资前五名的员工</span><br><span class="line">mysql&gt; select ename, sal from emp order by sal desc limit 0, 5;</span><br><span class="line">+-------+---------+</span><br><span class="line">| ename | sal     |</span><br><span class="line">+-------+---------+</span><br><span class="line">| KING  | 5000.00 |</span><br><span class="line">| SCOTT | 3000.00 |</span><br><span class="line">| FORD  | 3000.00 |</span><br><span class="line">| JONES | 2975.00 |</span><br><span class="line">| BLAKE | 2850.00 |</span><br><span class="line">+-------+---------+</span><br><span class="line"># 默认从0开始</span><br><span class="line">mysql&gt; select ename, sal from emp order by sal desc limit 5;</span><br></pre></td></tr></table></figure>

<p>每页显示pageSize条记录：<code>( pageNo - 1) * pageSize, pageSize</code></p>
<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><p>1、LOCATE(substr , str )：返回子串 substr 在字符串 str 中第一次出现的位置，如果字符substr在字符串str中不存在，则返回0；</p>
<p>2、POSITION(substr IN str )：返回子串 substr 在字符串 str 中第一次出现的位置，如果字符substr在字符串str中不存在，与LOCATE函数作用相同；</p>
<p>3、LEFT(str, length)：从左边开始截取str，length是截取的长度；</p>
<p>4、RIGHT(str, length)：从右边开始截取str，length是截取的长度；</p>
<p>5、SUBSTRING_INDEX(str ,substr ,n)：</p>
<ul>
<li><p>当n&gt;0，返回字符substr在str中从左到右第n次出现位置之前的字符串;</p>
</li>
<li><p>当n&lt;0，返回字符substr在str中从右到左第n次出现位置之后的字符串;</p>
</li>
<li><p><a href="https://www.nowcoder.com/practice/a5475ed3b5ab4de58e2ea426b4b2db76?tpId=240&tqId=2202382&ru=/practice/255aa1863fe14aa88694c09ebbc1dbca&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj">修复串列了的记录_牛客题霸_牛客网 (nowcoder.com)</a></p>
</li>
</ul>
<p>6、SUBSTRING(str ,n ,m)：返回字符串str从第n个字符截取到第m个字符；</p>
<p>7、REPLACE(str, n, m)：将字符串str中的n字符替换成m字符；</p>
<p>8、LENGTH(str)：计算字符串str的长度。</p>
<p>9、CONCAT(字段A, 分隔符, 字段B)</p>
<p>10、GROUP_CONCAT(字段名 SEPARATOR ‘;’) 和GROUP_BY一起使用，将同一组内同一字段的所有数据连接，默认以逗号作为分隔符，若要指定分隔符 加上<code>SEPARATOR &#39;;&#39;</code>即可，注意没有逗号。</p>
<ul>
<li><a href="https://www.nowcoder.com/practice/46cb7a33f7204f3ba7f6536d2fc04286?tpId=240&tqId=2183007&ru=/practice/f6b4770f453d4163acc419e3d19e6746&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj">	未完成试卷数大于1的有效用户_牛客题霸_牛客网 (nowcoder.com)</a></li>
</ul>
<h1 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">    字段名1 数据类型,</span><br><span class="line">    字段名2 数据类型,</span><br><span class="line">    字段名3 数据类型,</span><br><span class="line">    ....);</span><br></pre></td></tr></table></figure>

<p>关于MySQL当中字段的数据类型？</p>
<ul>
<li>int		整数型</li>
<li>bigint	长整型</li>
<li>float		浮点型</li>
<li>char		定长字符串<strong>（字段长度定长时，如性别、日期1999-01-01等）</strong></li>
<li>varchar	可变长字符串<strong>（字段长度不确定时，如姓名等）</strong></li>
<li>date		日期类型 </li>
<li>BLOB		二进制大对象（存储图片、视频等流媒体信息） </li>
<li>CLOB		字符大对象（存储较大文本，比如，可以存储4G的字符串。）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建学生表：学号、姓名、性别、班级编号、生日</span><br><span class="line">create table t_student(</span><br><span class="line">    no bigint,</span><br><span class="line">    name varchar(255),</span><br><span class="line">    sex char(1) default,</span><br><span class="line">    classno varchar(255),</span><br><span class="line">    birth char(10)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>建表后单独加外键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 </span><br><span class="line">ADD CONSTRAINT 外键名 </span><br><span class="line">FOREIGN KEY (本表外键列名) </span><br><span class="line">REFERENCES 主表名(主表主键列名)</span><br></pre></td></tr></table></figure>





<h1 id="插入Insert"><a href="#插入Insert" class="headerlink" title="插入Insert"></a>插入Insert</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 插入时，指定字段</span><br><span class="line">insert into table1 (file1, file2, ...) values (value1, value2, ...);</span><br><span class="line"># 插入时，指定字段，插入多行</span><br><span class="line">insert into table1 (file1, file2, ...) values (value1, value2, ...),(value1, value2, ...),(value1, value2, ...);</span><br><span class="line"># 省略字段</span><br><span class="line">insert into table1 values (value1, value2, ...);</span><br></pre></td></tr></table></figure>

<p>指定字段插入时，value 和 file的类型要一一对应，可以颠倒字段顺序；如果此时某些file没填入，value则为字段的默认值，如果未指定默认值则为<code>NULL</code>。</p>
<p>当字段省略时，所有的value都要填入，否则报错。主键可以设置为null，因为会自增。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">replace into</span><br></pre></td></tr></table></figure>

<p>语法和insert into一致，作用是试图插入，若其中某个value的对应字段是unique的话且value重复的话，则找到这个value对应的记录，并update；否则执行插入操作。</p>
<h1 id="表的复制"><a href="#表的复制" class="headerlink" title="表的复制"></a>表的复制</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 根据select的查询结果当作表，创建出table1</span><br><span class="line">create table table1 as select * from t_student;</span><br></pre></td></tr></table></figure>

<h1 id="查询结果插入到另一个表中"><a href="#查询结果插入到另一个表中" class="headerlink" title="查询结果插入到另一个表中"></a>查询结果插入到另一个表中</h1><p>字段数要相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into t_tmp select * from t_student;</span><br></pre></td></tr></table></figure>



<h1 id="修改数据update"><a href="#修改数据update" class="headerlink" title="修改数据update"></a>修改数据update</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update t_table set 字段名1=值1, 字段名2=值2, ... where 条件;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将部门10的loc修改为shanghai，将部门名称改为renshibu</span><br><span class="line">update tmp_dept set loc = &#x27;shanghai&#x27;, dname = &#x27;renshibu&#x27; where deptno = 10;</span><br><span class="line"># 没有where条件时更新所有记录</span><br><span class="line">update tmp_dept set loc = &#x27;x&#x27;, dname = &#x27;y&#x27;;</span><br></pre></td></tr></table></figure>



<h1 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from t_table where 条件;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 条件删除</span><br><span class="line">delete from tmp_dept where deptno = 10;</span><br><span class="line"># 删除全部表记录</span><br><span class="line">delete from tmp_dept;</span><br></pre></td></tr></table></figure>

<p>如果表数据庞大，使用delete删除要很久，因为它没有释放数据，可以回滚记录。</p>
<p>因此使用<code>truncate</code>语句删除大表，表被截断，不可回滚，永久丢失</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">truncate table tmp_dept; </span><br></pre></td></tr></table></figure>

<p>1.DELETE 可以加where 条件，truncate 不能加</p>
<p>2.truncate删除，效率高一些</p>
<p>3.假如要删除的表中有自增长列，如果用delete 删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始</p>
<p>4.truncate删除后没有返回值，delete 删除有返回值</p>
<p>5.truncate 删除后不能回滚，delete 删除可以回滚</p>
<p>1.DROP TABLE　清除数据并且销毁表，是一种数据库定义语言(DDL Data Definition Language), 执行后不能撤销，被删除表格的关系，索引，权限等等都会被永久删除。</p>
<p>2.TRUNCATE TABLE　只清除数据，保留表结构，列，权限，索引，视图，关系等等，相当于清零数据，是一种数据库定义语言(DDL Data Definition Language)，执行后不能撤销。</p>
<p>3.DELETE TABLE　删除（符合某些条件的）数据，是一种数据操纵语言(DML Data Manipulation Language)，执行后可以撤销。</p>
<h1 id="删表"><a href="#删表" class="headerlink" title="删表"></a>删表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table t_student; # 通用写法</span><br><span class="line">drop table if exists t_student; # mysql写法</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h1><p>1.添加列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 add column 列名 类型 【first|after 字段名】;</span><br></pre></td></tr></table></figure>

<p>2.修改列的类型或约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 modify column 列名 新类型 【新约束】;</span><br></pre></td></tr></table></figure>

<p>3.修改列名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 change column 旧列名 新列名 类型;</span><br></pre></td></tr></table></figure>

<p>4 .删除列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop column 列名;</span><br></pre></td></tr></table></figure>

<p>5.修改表名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 rename 【to】 新表名;</span><br></pre></td></tr></table></figure>

<p>6.将某一列放到第一列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 modify column 列名 类型 first;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>题目：<a href="https://www.nowcoder.com/practice/d08209df6f464cebafda5dfd5de03fce?tpId=240&tqId=2223567&ru=/practice/a61ee5519d14444aa99e530309a8e043&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/company">https://www.nowcoder.com/practice/d08209df6f464cebafda5dfd5de03fce?tpId=240&amp;tqId=2223567&amp;ru=%2Fpractice%2Fa61ee5519d14444aa99e530309a8e043&amp;qru=%2Fta%2Fsql-advanced%2Fquestion-ranking&amp;sourceUrl=%2Fexam%2Fcompany</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE user_info ADD COLUMN school VARCHAR(15) AFTER level;</span><br><span class="line">ALTER TABLE user_info CHANGE COLUMN job profession VARCHAR(10);</span><br><span class="line">ALTER TABLE user_info MODIFY COLUMN achievement INT(11) default 0;  # 新类型必须要</span><br></pre></td></tr></table></figure>



<h1 id="约束constraint"><a href="#约束constraint" class="headerlink" title="约束constraint"></a>约束constraint</h1><p>约束测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table t_user;</span><br><span class="line">create table t_user(</span><br><span class="line">	id int primary key,</span><br><span class="line">    email varchar(255),</span><br><span class="line">    username varchar(255) </span><br><span class="line">);</span><br><span class="line">insert into t_user(id, username, email) values(1,&#x27;cj1&#x27;,&#x27;123@qq.com&#x27;);</span><br><span class="line">insert into t_user(id, username, email) values(2,&#x27;cj2&#x27;,&#x27;234@qq.com&#x27;);</span><br><span class="line">insert into t_user(id, username, email) values(3,&#x27;cj3&#x27;,&#x27;345@qq.com&#x27;);</span><br></pre></td></tr></table></figure>

<p>保证表内数据的合法性、有效性、完整性，例如某些</p>
<ul>
<li>非空约束（not null）：不能为空</li>
<li>唯一约束（unique）：不能重复</li>
<li>主键约束（primary key）：既不能为null，也不能重复</li>
<li>外键约束（foreign key, FK）：</li>
<li>检查约束（check）：mysql无，oracle有。</li>
</ul>
<h2 id="非空约束-not-nll"><a href="#非空约束-not-nll" class="headerlink" title="非空约束 not nll"></a>非空约束 not nll</h2><p>只能在字段后面添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_user(</span><br><span class="line">	id int,</span><br><span class="line">    username varchar(255) not null,  # 非空</span><br><span class="line">    password varchar(255) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="唯一性约束-unique"><a href="#唯一性约束-unique" class="headerlink" title="唯一性约束 unique"></a>唯一性约束 unique</h2><p>可以为null</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_user(</span><br><span class="line">	id int,</span><br><span class="line">    usercode varchar(255) unique# 不能重复 （列级约束）</span><br><span class="line">    username varchar(255) unique# 不能重复 （列级约束）</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>联合unique，not null 没有此写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_user(</span><br><span class="line">	id int,</span><br><span class="line">    usercode varchar(255) </span><br><span class="line">    username varchar(255) </span><br><span class="line">	unique(usercode, username) # 联合unique，两个字段的值不能同时相同 （表级约束）</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="主键约束-primary-key"><a href="#主键约束-primary-key" class="headerlink" title="主键约束 primary key"></a>主键约束 primary key</h2><h3 id="相关术语："><a href="#相关术语：" class="headerlink" title="相关术语："></a>相关术语：</h3><p>主键约束（primary key本身）、主键字段（有primary key的字段）、主键值（主键字段的值）</p>
<ul>
<li>只要主键不一样，就认为是不一样的记录，是表里的唯一表示。</li>
<li>表的设计三范式中，第一范式就是任何一张表都应该有主键，任何一张表只能有一个主键。</li>
</ul>
<h3 id="主键分类："><a href="#主键分类：" class="headerlink" title="主键分类："></a>主键分类：</h3><ul>
<li>根据主键字段数量来划分<ul>
<li>单一主键</li>
<li>复合主键（不建议使用，违背三范式）：多个字段联合起来添加一个主键约束</li>
</ul>
</li>
<li>根据主键性质来划分<ul>
<li>自然主键</li>
<li>业务主键（不建议使用）：身份证、银行卡号</li>
</ul>
</li>
</ul>
<h3 id="主键自增"><a href="#主键自增" class="headerlink" title="主键自增"></a>主键自增</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table t_user;</span><br><span class="line">create table t_user(</span><br><span class="line">	id int primary key auto_increment, # 自动维护一个以1开始自增的</span><br><span class="line">    username varchar(255)</span><br><span class="line">);</span><br><span class="line">insert into t_user(username) values(&#x27;a&#x27;);</span><br><span class="line">insert into t_user(username) values(&#x27;b&#x27;);</span><br><span class="line">select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | a        |</span><br><span class="line">|  2 | b        |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure>

<p>oracle提供了一种自增机制：sequence序列</p>
<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><p>主键约束（primary key本身）、主键字段（有primary key的字段）、主键值（主键字段的值）</p>
<h3 id="业务背景："><a href="#业务背景：" class="headerlink" title="业务背景："></a>业务背景：</h3><p>设计数据库表，维护学生和班级的信息，区分出班级表和学生表</p>
<pre><code>                t_class 班级表
--------------------------------------------------------
cno(pk)		cname
--------------------------------------------------------
101			北京大兴区经济技术开发区亦庄二中高三1班
102			北京大兴区经济技术开发区亦庄二中高三2班
--------------------------------------------------------

                t_student 学生表
--------------------------------------------------------
sno(pk)		sname		classno(该字段添加外键约束fk)
--------------------------------------------------------
1			zs1			101
2			zs2			101
3			zs3			102
4			zs4			102
5			zs5			102
--------------------------------------------------------
</code></pre>
<p>加上了外键约束后，classno的值只能来自于t_class的cno。</p>
<ul>
<li>t_student中的clasno字段引用 t_class表中的cno字段。此时t_student是子表，t_class为父表。<ul>
<li>删除数据的时候，先删除子表，再删除父表。</li>
<li>添加数据的时候，先添加父表，在添加子表。</li>
<li>创建表的时候，先创建父表，再创建子表。</li>
<li>删除表的时候，先删除子表，在删除父表。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_student;</span><br><span class="line">drop table if exists t_class;</span><br><span class="line">#</span><br><span class="line">create table t_class(</span><br><span class="line">	cno int primary key,</span><br><span class="line">    cname varchar(255),</span><br><span class="line">);</span><br><span class="line">#</span><br><span class="line">create table t_student(</span><br><span class="line">	sno int primary key,</span><br><span class="line">    sname varchar(255),</span><br><span class="line">    classno int,</span><br><span class="line">    foreign key(classno) references t_class(cno)</span><br><span class="line">);</span><br><span class="line">insert into t_class values(101,&#x27;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#x27;);</span><br><span class="line">insert into t_class values(102,&#x27;yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy&#x27;);</span><br><span class="line"></span><br><span class="line">insert into t_student values(1,&#x27;zs1&#x27;,101);</span><br><span class="line">insert into t_student values(2,&#x27;zs2&#x27;,101);</span><br><span class="line">insert into t_student values(3,&#x27;zs3&#x27;,102);</span><br><span class="line">insert into t_student values(4,&#x27;zs4&#x27;,102);</span><br><span class="line">insert into t_student values(5,&#x27;zs5&#x27;,102);</span><br><span class="line">insert into t_student values(6,&#x27;zs6&#x27;,102);</span><br><span class="line">select * from t_class;</span><br><span class="line">select * from t_student;</span><br><span class="line"></span><br><span class="line">insert into t_student values(7,&#x27;zs6&#x27;,103); # 103在t_class.cno不存在</span><br><span class="line">ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`dljd`.`t_student`, CONSTRAINT `t_student_ibfk_1` FOREIGN KEY (`classno`) REFERENCES `t_class` (`cno`))</span><br><span class="line">insert into t_student values(8,&#x27;zs6&#x27;); # 插入成功，外键可以为null</span><br></pre></td></tr></table></figure>

<ul>
<li>外键可以为null</li>
<li>被引用的字段不一定是主键，但至少具有unique约束，也就是能找到一个唯一的记录，如t_class里cno可以不是主键，但不能有两个101的记录。</li>
</ul>
<h1 id="存储引擎（了解即可）"><a href="#存储引擎（了解即可）" class="headerlink" title="存储引擎（了解即可）"></a>存储引擎（了解即可）</h1><p>存储引擎只在mysql存在。oracle也有对应机制，只称为：存储方式。</p>
<p>每种存储引擎都只有自己有缺点，对应一种存储方式。</p>
<p>完整的建表语句，还要指定存储引擎、字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `t_x` (</span><br><span class="line">    `id` int(11) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"># 飘号 ``， mysql可用但不通用，最好不用</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看mysql支持的存储引擎</span><br><span class="line">show engines \G </span><br></pre></td></tr></table></figure>

<p>常见的存储引擎：</p>
<pre><code>Engine: MyISAM
Support: YES
Comment: MyISAM storage engine
Transactions: NO
XA: NO
Savepoints: NO

MyISAM这种存储引擎不支持事务。
MyISAM是mysql最常用的存储引擎，但是这种引擎不是默认的。
MyISAM采用三个文件组织一张表：
    xxx.frm（存储格式的文件）
    xxx.MYD（存储表中数据的文件）
    xxx.MYI（存储表中索引的文件）
优点：可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。
缺点：不支持事务。

-----------------------------------------------------------------------------

Engine: InnoDB
Support: DEFAULT
Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
XA: YES
Savepoints: YES

优点：支持事务、行级锁、外键等。这种存储引擎数据的安全得到保障。

表的结构存储在xxx.frm文件中
数据存储在tablespace这样的表空间中（逻辑概念），无法被压缩，无法转换成只读。
这种InnoDB存储引擎在MySQL数据库崩溃之后提供自动恢复机制。
InnoDB支持级联删除和级联更新。
    
-------------------------------------------------------------------------------------

Engine: MEMORY
Support: YES
Comment: Hash based, stored in memory, useful for temporary tables
Transactions: NO
XA: NO
Savepoints: NO

缺点：不支持事务。数据容易丢失。因为所有数据和索引都是存储在内存当中的。
优点：查询速度最快。
以前叫做HEPA引擎。
</code></pre>
<h1 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h1><p>一个事务是完整的业务逻辑单元，不可再分，例如银行账户A向账户B转账，需要执行两条upda语句，不允许一条成功，一条失败。</p>
<ul>
<li><p>如何保证这两条DML语句全部成功：事务机制。和事务相关的语句只有DML语句（insert delete update），因为这三个语句都与数据相关。</p>
</li>
<li><p>当只有一条DML语句时，不需要事务机制。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert -&gt; update -&gt;delete</span><br><span class="line">开启事务机制（开始）</span><br><span class="line">执行insert语句-&gt; insert执行成功后，记录到数据库的历史操作，不修改硬盘数据。</span><br><span class="line">执行update语句-&gt; update执行成功后，记录到数据库的历史操作，不修改硬盘数据。</span><br><span class="line">执行delete语句-&gt; delete执行成功后，记录到数据库的历史操作，不修改硬盘数据。</span><br><span class="line">提交事务或回滚事务（结束）# SQL语句分类中的 TCL（事务控制语言）：commit提交事务，rollback回滚事务</span><br></pre></td></tr></table></figure>

<h2 id="事务四大特性ACID"><a href="#事务四大特性ACID" class="headerlink" title="事务四大特性ACID"></a>事务四大特性ACID</h2><ul>
<li>A：原子性，事务是最小的工作单元，不可再分</li>
<li>C：一致性，事务必须保证多条DML语句同时成功或同时失败</li>
<li>I：隔离性，事务A与B之间具有隔离<ul>
<li>第一级别：读未提交（read uncommitted)：对方事务还没提交，当前事务可用读取到未提交的数据，<ul>
<li>问题：存在脏读（dirty read）现象，表示读到了未在硬盘的数据。</li>
</ul>
</li>
<li>第二级别：读提交（read committed)：对方事务提交后的数据，我方可用读到。解决脏读问题。<ul>
<li>问题：不可重复读取，如果有其他事务一直在修改，每次数据读出来不一样。</li>
</ul>
</li>
<li>第三级别：可重复读（repeatable read）：读到的永远是开启事务前的数据，即便其他用户已经修改或删除了数据，读取的仍是备份数据。解决了不可重复读问题<ul>
<li>问题：读取到的是过期数据。</li>
</ul>
</li>
<li>第四级别：序列化读&#x2F;串行化读：两个事务不能并发。解决以上问题。<ul>
<li>问题：效率低，事务排队。</li>
</ul>
</li>
</ul>
</li>
<li>D：持久性，最终处理的数据必须持久化到硬盘文件中，事务才算成功结束</li>
</ul>
<p>oracle默认的隔离级别是第二级别起步，mysql则是第三级别。</p>
<h2 id="演示事务"><a href="#演示事务" class="headerlink" title="演示事务"></a>演示事务</h2><p>准备表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_user;</span><br><span class="line">create table t_user(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">    username varchar(255)</span><br><span class="line">);</span><br><span class="line">insert into t_user(username) values(&#x27;cj1&#x27;);</span><br></pre></td></tr></table></figure>

<p>mysql事务自动提交，即只要执行一次DML提交一次。</p>
<p>使用<code>start transaction</code>关闭自动提交机制，开启事务机制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 事务开始</span><br><span class="line">mysql&gt; start transaction;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"># 连续的两条插入</span><br><span class="line">mysql&gt; insert into t_user(username) values(&#x27;cj2&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; insert into t_user(username) values(&#x27;cj3&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | cj1      |</span><br><span class="line">|  2 | cj2      |</span><br><span class="line">|  3 | cj3      |</span><br><span class="line">+----+----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"># rollback回滚到事务开始前</span><br><span class="line">mysql&gt; rollback;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | cj1      |</span><br><span class="line">+----+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"># 再插入，发现主键不从2开始了</span><br><span class="line">mysql&gt; insert into t_user(username) values(&#x27;cj4&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | cj1      |</span><br><span class="line">|  4 | cj4      |</span><br><span class="line">+----+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>设置全局隔离权限</p>
<p>测试权限时，可以开启cmd连接数据库，一个修改数据，另一个查看数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 演示第1级别：读未提交</span><br><span class="line">set global transaction isolation level read uncommitted;</span><br><span class="line"># 演示第2级别：读已提交</span><br><span class="line">set global transaction isolation level read committed;</span><br><span class="line"># 演示第3级别：可重复读</span><br><span class="line">set global transaction isolation level repeatable read;</span><br><span class="line"># 序列化读</span><br><span class="line">set global transaction isolation level  serializable;</span><br></pre></td></tr></table></figure>

<p>查看全局隔离权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mysql&gt; select @@global.tx_isolation; # 旧版的方法</span><br><span class="line">mysql&gt; select @@global.transaction_isolation;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@global.transaction_isolation |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| READ-COMMITTED                 |</span><br><span class="line">+--------------------------------+</span><br></pre></td></tr></table></figure>



<h1 id="索引（底层是红黑树）"><a href="#索引（底层是红黑树）" class="headerlink" title="索引（底层是红黑树）"></a>索引（底层是红黑树）</h1><p>查询一张表的时候有两种检索方式：</p>
<ul>
<li>全表扫描</li>
<li>根据索引检索（效率很高）</li>
</ul>
<p>索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中的对象，需要数据库不断的维护。是有维护成本的</p>
<p>什么情况索引更好?</p>
<ul>
<li>数据量庞大</li>
<li>该字段很少DML操作，为数据一旦修改，索引需要重新排序，进行维护。</li>
<li>该字段经常出现在where子句中。</li>
</ul>
<p>注意：</p>
<ul>
<li>主键和具有unique的字段自动有索引，因此根据主键索引效率更高。</li>
<li>当模糊查询时，第一个通配符是%时，索引会失效。</li>
</ul>
<h1 id="创建索引和删除索引"><a href="#创建索引和删除索引" class="headerlink" title="创建索引和删除索引"></a>创建索引和删除索引</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建索引对象</span><br><span class="line">create index index_name on table1(field1);</span><br><span class="line"># 删除索引对象</span><br><span class="line">drop index index_name on table1; # mysql</span><br><span class="line">drop index index_name; #oracle</span><br></pre></td></tr></table></figure>

<h3 id="创建索引例题"><a href="#创建索引例题" class="headerlink" title="创建索引例题"></a>创建索引例题</h3><blockquote>
<p><a href="https://www.nowcoder.com/practice/f2ea9ccf33c740d58576608940981807?tpId=240&tqId=2223570&ru=/practice/f2ea9ccf33c740d58576608940981807&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/company">https://www.nowcoder.com/practice/f2ea9ccf33c740d58576608940981807?tpId=240&amp;tqId=2223570&amp;ru=%2Fpractice%2Ff2ea9ccf33c740d58576608940981807&amp;qru=%2Fta%2Fsql-advanced%2Fquestion-ranking&amp;sourceUrl=%2Fexam%2Fcompany</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_duration ON examination_info(duration); # 普通索引</span><br><span class="line">CREATE FULLTEXT INDEX full_idx_tag ON examination_info(tag);  # 全文索引</span><br><span class="line">CREATE UNIQUE INDEX uniq_idx_exam_id ON examination_info(exam_id); # 唯一性索引</span><br></pre></td></tr></table></figure>

<h3 id="删除索引例题"><a href="#删除索引例题" class="headerlink" title="删除索引例题"></a>删除索引例题</h3><blockquote>
<p><a href="https://www.nowcoder.com/practice/4963f6d63dde48d787aaa2b43460fb4b?tpId=240&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/company">https://www.nowcoder.com/practice/4963f6d63dde48d787aaa2b43460fb4b?tpId=240&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=%2Fexam%2Fcompany</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX uniq_idx_exam_id ON examination_info;</span><br><span class="line">DROP INDEX full_idx_tag ON examination_info;</span><br></pre></td></tr></table></figure>





<p>对比是否使用索引的查询方式和查询数据量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 解释语句的执行过程</span><br><span class="line">mysql&gt; explain select * from emp where sal = 5000;</span><br><span class="line"># type字段为all，表示全表扫描；rows=14，表示扫描了14行才扫到。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 为sal字段创建索引</span><br><span class="line">mysql&gt; create index emp_sal_index on emp(sal);</span><br><span class="line">Query OK, 0 rows affected (0.08 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line">mysql&gt; explain select * from emp where sal = 5000;</span><br><span class="line"># type字段为ref，表示索引扫描；rows=1，表示扫描了1行就扫到了。</span><br></pre></td></tr></table></figure>

<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><blockquote>
<p><a href="https://www.nowcoder.com/practice/f2ea9ccf33c740d58576608940981807?tpId=240&tqId=2223570&ru=/practice/f2ea9ccf33c740d58576608940981807&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/company">https://www.nowcoder.com/practice/f2ea9ccf33c740d58576608940981807?tpId=240&amp;tqId=2223570&amp;ru=%2Fpractice%2Ff2ea9ccf33c740d58576608940981807&amp;qru=%2Fta%2Fsql-advanced%2Fquestion-ranking&amp;sourceUrl=%2Fexam%2Fcompany</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_duration ON examination_info(duration); # 普通索引</span><br><span class="line">CREATE FULLTEXT INDEX full_idx_tag ON examination_info(tag);  # 全文索引</span><br><span class="line">CREATE UNIQUE INDEX uniq_idx_exam_id ON examination_info(exam_id); # 唯一性索引</span><br></pre></td></tr></table></figure>



<h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230830192308964.png" alt="image-20230830192308964"></p>
<p>通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”，最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据。<br>            select ename from emp where ename &#x3D; ‘SMITH’;<br>            通过索引转换为：<br>            select ename from emp where 物理地址 &#x3D; 0x3;</p>
<h2 id="索引分类（了解）"><a href="#索引分类（了解）" class="headerlink" title="索引分类（了解）"></a>索引分类（了解）</h2><ul>
<li>单一索引：单个字段</li>
<li>复合索引：多个字段</li>
<li>主键索引：</li>
<li>唯一索引：</li>
</ul>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>只是表的保密表现形式。</p>
<p>作用：视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，程序员只对视图对象进行CRUD。</p>
<p>视图对象只能用上述的DQL语句创建出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建视图</span><br><span class="line">create view myview as select 字段1,字段2 from 表;</span><br><span class="line"># 删除视图</span><br><span class="line">drop view myview;</span><br></pre></td></tr></table></figure>

<p>对视图进行增删改查CRUD会影响原表数据，但不是直接操作原表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table emp_bak as select * from emp;</span><br><span class="line">create view myview1 as select empno,ename,sal from emp_bak;</span><br><span class="line">update myview1 set ename=&#x27;hehe&#x27;,sal=1 where empno = 7369; # 通过视图修改原表数据。</span><br><span class="line">delete from myview1 where empno = 7369; # 通过视图删除原表数据。</span><br></pre></td></tr></table></figure>



<h1 id="DBA命令"><a href="#DBA命令" class="headerlink" title="DBA命令"></a>DBA命令</h1><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&gt; mysqldump 数据库名 表名（表名可省略） &gt; 路径\文件名.sql -uroot -p</span><br><span class="line">mysqldump dljd &gt; C:\Users\imcj0\Documents\export.sql -uroot -p</span><br></pre></td></tr></table></figure>

<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database dljd_tmp;  # 创建数据库</span><br><span class="line">use dljd_tmp; #</span><br><span class="line">source C:\Users\imcj0\Documents\export.sql;</span><br></pre></td></tr></table></figure>



<h1 id="数据库设计三范式（重点）"><a href="#数据库设计三范式（重点）" class="headerlink" title="数据库设计三范式（重点）"></a>数据库设计三范式（重点）</h1><p>按照三范式设计的表不会出现数据冗余，在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。</p>
<ul>
<li>第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。</li>
<li>第二范式：建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。<ul>
<li>多对多关系，使用三张表，关系表两个外键：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t_student学生表</span><br><span class="line">sno(pk)		sname</span><br><span class="line">-------------------</span><br><span class="line">1			张三</span><br><span class="line">2			李四</span><br><span class="line">3			王五</span><br><span class="line"></span><br><span class="line">t_teacher 讲师表</span><br><span class="line">tno(pk)		tname</span><br><span class="line">---------------------</span><br><span class="line">1			王老师</span><br><span class="line">2			张老师</span><br><span class="line">3			李老师</span><br><span class="line"></span><br><span class="line">t_student_teacher_relation 学生讲师关系表</span><br><span class="line">id(pk)		sno(fk)		tno(fk)</span><br><span class="line">----------------------------------</span><br><span class="line">1			1			3</span><br><span class="line">2			1			1</span><br><span class="line">3			2			2</span><br><span class="line">4			2			3</span><br><span class="line">5			3			1</span><br><span class="line">6			3			3</span><br></pre></td></tr></table></figure>

<ul>
<li><p>建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。</p>
<ul>
<li><p>一对多关系，使用两张表，多的表加外键。</p>
<p>如果不遵循第三范式，那么t_class的cname会在t_student中的cname字段，而此时该字段不依赖主键sno。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">班级t_class</span><br><span class="line">cno(pk)			cname</span><br><span class="line">--------------------------</span><br><span class="line">1				班级1</span><br><span class="line">2				班级2</span><br><span class="line"></span><br><span class="line">学生t_student</span><br><span class="line">sno(pk)			sname				classno(fk)</span><br><span class="line">---------------------------------------------</span><br><span class="line">101				张1				1</span><br><span class="line">102				张2				1</span><br><span class="line">103				张3				2</span><br><span class="line">104				张4				2</span><br><span class="line">105				张5				2</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<p>一对一设计：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t_user_login  用户登录表</span><br><span class="line">id(pk)		username		password</span><br><span class="line">--------------------------------------</span><br><span class="line">1			zs				123</span><br><span class="line">2			ls				456</span><br><span class="line"></span><br><span class="line">t_user_detail 用户详细信息表</span><br><span class="line">id(pk+fk)	realname		tel			....</span><br><span class="line">------------------------------------------------</span><br><span class="line">1			张三			1111111111</span><br><span class="line">2			李四			1111415621</span><br><span class="line"></span><br><span class="line">一对一设计有两种方案：外键唯一。</span><br><span class="line">t_user_login  用户登录表</span><br><span class="line">id(pk)		username		password</span><br><span class="line">--------------------------------------</span><br><span class="line">1			zs				123</span><br><span class="line">2			ls				456</span><br><span class="line"></span><br><span class="line">t_user_detail 用户详细信息表</span><br><span class="line">id(pk)	   realname			tel				userid(fk+unique)....</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">1			张三			1111111111			2</span><br><span class="line">2			李四			1111415621			1</span><br><span class="line">			</span><br></pre></td></tr></table></figure>



<h1 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h1><p>确定两个概念：<strong>日期和时间</strong>。</p>
<p>格式</p>
<ul>
<li>DATE：仅包含日期部分，格式为’YYYY-MM-DD’，例如’2023-07-06’。</li>
<li>TIME：仅包含时间部分，格式为’HH:MM:SS’，例如’13:30:45’。</li>
<li>DATETIME：包含日期和时间部分，格式为’YYYY-MM-DD HH:MM:SS’，例如’2023-07-06 13:30:45’。</li>
<li>TIMESTAMP：与DATETIME相似，格式为’YYYY-MM-DD HH:MM:SS’，但在存储和使用上有一些差异。</li>
</ul>
<h3 id="日期函数："><a href="#日期函数：" class="headerlink" title="日期函数："></a>日期函数：</h3><ul>
<li><p><code>CURDATE()</code> <code>CURRENT_DATE()</code>，返回当前日期</p>
</li>
<li><p><code>CURTIME()</code> <code>CURRENT_TIME()</code>，返回当前时间</p>
</li>
<li><p><code>NOW() </code> <code>CURRENT_TIMESTAMP()</code>，返回当前日期和时间</p>
</li>
<li><p><code>DATA_FORMAT()</code>，格式化符号来表示年、月、日、小时、分钟、秒。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATE_FORMAT(NOW(), &#x27;%Y-%m-%d %H:%i:%s&#x27;); </span><br><span class="line"># 2023-09-01 23:25:07</span><br><span class="line">SELECT DATE_FORMAT(NOW(), &#x27;%W, %M %e, %Y&#x27;);</span><br><span class="line"># Friday, September 1, 2023 </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="日期运算符"><a href="#日期运算符" class="headerlink" title="日期运算符"></a>日期运算符</h3><ul>
<li><p><code>DATE_ADD()</code> <code>DATE_SUB()</code>，当前日期减去一定时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATE_ADD(NOW(), INTERVAL 2 DAY); </span><br><span class="line">SELECT DATE_SUB(NOW(), INTERVAL 1 MINUTE); </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DATEDIFF()</code>，计算两个日期<strong>天数（d）</strong>之差</p>
</li>
<li><p><code>TIMEDIFF()</code>，计算两个日期<strong>时间（h,m,s）</strong>之差</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATEDIFF(DATE_SUB(NOW(), INTERVAL 10 DAY), NOW());  # -10</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>timestampdiff(unit,begin,end)</code></p>
<ul>
<li><p>TIMESTAMPDIFF函数返回begin-end的结果，其中begin和end是DATE或DATETIME表达式。</p>
<p>TIMESTAMPDIFF函数允许其参数具有混合类型，例如，begin是DATE值，end可以是DATETIME值。 如果使用DATE值，则TIMESTAMPDIFF函数将其视为时间部分为“00:00:00”的DATETIME值</p>
</li>
<li><p>unit则为返回的单位</p>
<ul>
<li>MICROSECOND</li>
<li>SECOND</li>
<li>MINUTE</li>
<li>HOUR</li>
<li>DAY</li>
<li>WEEK</li>
<li>MONTH</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="从时间中获取其中的一部分，比如只获取小时、月份等。"><a href="#从时间中获取其中的一部分，比如只获取小时、月份等。" class="headerlink" title="从时间中获取其中的一部分，比如只获取小时、月份等。"></a>从时间中获取其中的一部分，比如只获取小时、月份等。</h3><ul>
<li><p><code>YEAR() MONTH() DAY() HOUR() MINUTE() SECOND()</code>，获取日期+时间中的对应部分。</p>
</li>
<li><p><code>DATE()</code>，获取日期+时间的<strong>日期</strong>部分，格式化的数据也能获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATE(NOW()); # 成功</span><br><span class="line">SELECT DATE(DATE_FORMAT(NOW(), &#x27;%Y-%m-%d %H:%i:%s&#x27;)); # 成功</span><br><span class="line">SELECT DATE(DATE_FORMAT(NOW(), &#x27;%Y-%m&#x27;)); # null</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>TIME()</code>，获取日期+时间的<strong>时间</strong>部分</p>
</li>
<li><p><code>DATENAME()</code> <code>MONTHNAME()</code> 获取星期&#x2F;月份的全称。</p>
</li>
<li><p><code>LAST_DAY()</code>返回日期参数的某月最后一天</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>git报错与解决方案</title>
    <url>/2023/11/0643165177d6/</url>
    <content><![CDATA[<h2 id="报错1"><a href="#报错1" class="headerlink" title="报错1"></a>报错1</h2><p>当pull遇到如下错误时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; PS E:\_code\go_project\interpreter_in_Go-master&gt; git pull remote main:master</span><br><span class="line">From https://github.com/drinkwateronly/interpreter_in_Go</span><br><span class="line"> ! [rejected]        main       -&gt; master  (non-fast-forward)</span><br></pre></td></tr></table></figure>

<p>github上的肯定是最新的代码，可能的原因是本机的代码添加了无关紧要的注释，且添加前没有pull，造成的冲突导致的。</p>
<p>此时的解决方案是将remote的main分支，pull到本机新建的main branch中，然后切换到main分支，将原分支master删除。此做法只适合本机没有更新代码的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; git pull remote main:main</span><br><span class="line">&gt; git checkout main</span><br><span class="line">&gt; git branch -D master </span><br></pre></td></tr></table></figure>





<p>fatal: unable to access ‘<a href="https://github.com/drinkwateronly/gstonegames_Spider_in_Go.git/">https://github.com/drinkwateronly/gstonegames_Spider_in_Go.git/</a>‘: Recv failure: Connection was reset ：</p>
<p>git config –global http.proxy <a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a><br>git config –global https.proxy <a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -f  强推</span><br></pre></td></tr></table></figure>





<h2 id="错误-HTTP-408"><a href="#错误-HTTP-408" class="headerlink" title="错误 HTTP 408"></a>错误 HTTP 408</h2><p>主要原因：文件太大&#x2F;太多，缓存不够</p>
<blockquote>
<p><a href="https://blog.csdn.net/kanbarakun/article/details/134390526">https://blog.csdn.net/kanbarakun/article/details/134390526</a></p>
</blockquote>
<blockquote>
<p>error: RPC failed; HTTP 408 curl 22 The requested URL returned error: 408<br>send-pack: unexpected disconnect while reading sideband packet<br>fatal: the remote end hung up unexpectedly<br>Everything up-to-date<br>FATAL Something’s wrong. Maybe you can find the solution here: <a href="https://hexo.io/docs/troubleshooting.html">https://hexo.io/docs/troubleshooting.html</a><br>Error: Spawn failed<br>    at ChildProcess.<anonymous> (C:\Users\wallnut\myBlog\node_modules\hexo-deployer-git\node_modules\hexo-util\lib\spawn.js:51:21)<br>    at ChildProcess.emit (node:events:513:28)<br>    at cp.emit (C:\Users\wallnut\myBlog\node_modules\cross-spawn\lib\enoent.js:34:29)<br>    at ChildProcess._handle.onexit (node:internal&#x2F;child_process:291:12)</p>
</blockquote>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config --global http.postBuffer <span class="number">524288000</span>  </span><br><span class="line"># 或者  </span><br><span class="line">git config http.postBuffer <span class="number">524288000</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>合成大西瓜基础版本魔改+4everland部署</title>
    <url>/2023/11/b8c525c7aadb/</url>
    <content><![CDATA[<h1 id="合成大西瓜基础版本魔改-4everland部署"><a href="#合成大西瓜基础版本魔改-4everland部署" class="headerlink" title="合成大西瓜基础版本魔改+4everland部署"></a>合成大西瓜基础版本魔改+4everland部署</h1><p>仓库：<a href="https://github.com/drinkwateronly/watermelon">https://github.com/drinkwateronly/watermelon</a></p>
<p>使用本仓库的代码魔改合成大西瓜的要求</p>
<ul>
<li>会运行python代码</li>
<li>会上传代码到github仓库。</li>
</ul>
<h2 id="文件概览"><a href="#文件概览" class="headerlink" title="文件概览"></a>文件概览</h2><p>下载本仓库文件后，文件如下：</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231125134155347.png" alt="image-20231125134155347"></p>
<h2 id="魔改"><a href="#魔改" class="headerlink" title="魔改"></a>魔改</h2><p><code>src/extraSetting.js</code>中按需修改，要强调的是可以修改网页标题。</p>
<h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><p>两种处理方式，本文提供python脚本自动处理。手动处理较为繁琐，请查询网络教程，或使用他人提供的在线大西瓜图片处理工具。</p>
<h3 id="自动处理"><a href="#自动处理" class="headerlink" title="自动处理"></a>自动处理</h3><p>原本水果图片文件在<code>res/raw-assets</code>的位置、图片文件名等信息已按水果尺寸从小到大记录到<code>image_process/info.xlsx</code>中，具体如下。例如樱桃图片文件为<code>res/raw-assets/0c/0cbb3dbb-2a85-42a5-be21-9839611e5af7.png</code>。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231125104727166.png" alt="image-20231125104727166"></p>
<p>定制水果图片为想要的图片，则需要将要定制的11张图片（对应11种水果）放到<code>image_process/original</code>，并按水果尺寸从小到大的顺序命名为<code>1.jpg</code>, <code>2.jpg</code>…, <code>11.jpg</code>。</p>
<p><strong>注意，这些定制图片的尺寸最好是近似正方形，以免在后续图片处理中的缩放操作导致图片被拉伸，效果变差。</strong></p>
<p>随后运行<code>image_process/demo.py</code>即可自动将这些图片修改到原本水果图片的位置。其中该python脚本将图片先缩放到对应的正方形尺寸，并裁剪成圆形。</p>
<h3 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h3><p>略</p>
<h2 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h2><ul>
<li><p>下载并安装Node</p>
<p><a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p>
</li>
<li><p>进入命令行，检查npm是否安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令行安装serve工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g serve</span><br></pre></td></tr></table></figure>
</li>
<li><p>从合成大西瓜文件夹进入命令行，启动serve</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">serve</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成功后浏览器输访问<code>localhost:5000</code>即可</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>预览没问题后，可以开始部署上线。</p>
<ul>
<li><p><strong>首先代码要上传到github仓库</strong>。</p>
</li>
<li><p>随后使用<a href="https://dashboard.4everland.org/?invite=49TRKU2D">4everland</a>进行静态网页托管，并使用github注册即可。</p>
</li>
<li><p>注册成功后，点击<code>new project</code>，创建一个新项目</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231125111433974.png" alt="image-20231125111433974"></p>
</li>
<li><p>然后在step 1，import保存了合成大西瓜代码的github的仓库</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231125112002423.png" alt="image-20231125112002423"></p>
</li>
<li><p>step2，可选仓库的branch，意味着可以定制不同的合成大西瓜，上传到同一个仓库的不同branch管理。此处使用默认的branch，直接deploy即可。</p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231125112423795.png" alt="image-20231125112423795" style="zoom:67%;" />
</li>
<li><p>step3，耐心等待部署。完成后点击visit访问，并记录下url。首次加载该游戏可能比较慢。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231125112509144.png" alt="image-20231125112509144"></p>
<ul>
<li><p>拓展：</p>
<p><a href="https://dashboard.4everland.org/?invite=49TRKU2D">4everland</a>注册就送了1G的静态网页托管空间，一个合成大西瓜也就十几m，所以合理地管理好仓库的branch，可以上线很多个合成大西瓜游戏。</p>
</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://docs.qq.com/sheet/DS0d2VVVJYmpvZ0pZ?tab=BB08J2">魔改大西瓜可替换的素材 (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s/H9VR1MWn-9bKSC_1l_MkJw">魔改和上线你的合成大西瓜，最全教程！ (qq.com)</a></p>
<p><a href="https://www.bilibili.com/video/BV1Vy4y1n7KW/?vd_source=9883419bb9939eb61834a63a38921b19">全网最贴心的魔改合成大西瓜教程，从修改到发布！_哔哩哔哩_bilibili</a></p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
  </entry>
  <entry>
    <title>ch1-基于TCP的服务器实现</title>
    <url>/2023/04/680107d7b04b/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230414100114373.png" alt="image-20230414100114373"></p>
<h1 id="一、创建socket"><a href="#一、创建socket" class="headerlink" title="一、创建socket"></a>一、创建socket</h1><p>作用为确定连接的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数：</p>
<ul>
<li><p>domain：协议族，协议族决定了socket的地址类型,在通信中必须采用相应的地址。</p>
<ul>
<li>PF_INET：ipv4互联网协议族</li>
<li>PF_INET6：ipv6互联网协议族</li>
<li>PF_LOCAL</li>
<li>PF_PACKET</li>
<li>PF_IPX</li>
</ul>
</li>
<li><p>type: 指定socket的数据传输方式（因为domain的协议族也可能有多个传输方式）:</p>
<ul>
<li><p>SOCK_STREAM：基于TCP的流格式套接字，不存在数据边界（<strong>因为该套接字有缓冲</strong>，发送方发多少次，接收方可以只收一次）</p>
<blockquote>
<p>缓冲会不会满？会，如果read的速度比收数据的速度满，缓冲会满，但不会丢失数据，因为如果缓冲满了，套接字会停止传输。</p>
</blockquote>
</li>
<li><p>SOCK_DGRAM：基于UDP的数据报格式套接字，存在数据边界（发送方发多少次，接收方收多少次）</p>
</li>
</ul>
</li>
<li><p>protocol：实际的传输协议，第一个参数决定第三个参数可选范围。</p>
<ul>
<li>常见的协议有IPPROTO_TCP、IPPROTO_UDP、 IPPROTO_SCTP、IPPROTO_TIPC他们分别对应这TCP传输协议,UDP传输协议,STCP传输协议,TIPC传输协议。当protocol为0时，会自动选择type类型对应的默认协议。</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：成功时返回一个唯一整数【文件描述符】，失败时返回-1</p>
</li>
<li><p>注意事项<br>第三个参数大多数时候传0，即保持默认，除非遇到下面的情况：<br><code>同一协议族中存在多个 数据传输方式 相同的协议（即指定了domain和type，仍不能确定某一协议）</code></p>
</li>
<li><p>例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IPv4家族中面向连接的套接字， IPPROTO_TCP可省略填0</span></span><br><span class="line"><span class="type">int</span> tcp_socket = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP)</span><br><span class="line"><span class="comment">// IPv4家族中面向消息的套接字，同样可省略</span></span><br><span class="line"><span class="type">int</span> udp_socket = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, IPPROTO_UDP) </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二、-IP地址、端口信息存储"><a href="#二、-IP地址、端口信息存储" class="headerlink" title="二、 IP地址、端口信息存储"></a>二、 IP地址、端口信息存储</h1><p>用于存放要连接的<strong>IP地址</strong>和<strong>端口号</strong>，并指定地址族</p>
<p>此部分需要注意两种结构体<code>sockaddr</code>和<code>sockaddr_in</code>。</p>
<p>直接向<code>sockaddr</code>写入IP和端口信息较为麻烦，而设置<code>sockaddr_in</code>较为方便；但由于后续的传参要用到<code>sockaddr</code>，而两种类型是相似的，直接强制类型转换即可。</p>
<p>另外，<code>sockaddr_in</code>是表示IPv4的结构体，但为什么还要设置地址族<code>sin_family</code>。这是为了和<code>sockaddr</code>保持一致，而sockaddr并非只为IPv4设计。</p>
<h3 id="结构体成员细节"><a href="#结构体成员细节" class="headerlink" title="结构体成员细节"></a>结构体成员细节</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//早期的sockaddr，并非只为IPv4设计</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">sa_family_t</span> sa_family; <span class="comment">/* adress family: AF_XXX */</span> </span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];<span class="comment">/* 14 bytes of protocol */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IPv4的sockaddr</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family;                 <span class="comment">//地址族（Address Family），也就是地址类型</span></span><br><span class="line">    <span class="type">uint16_t</span>        sin_port;                   <span class="comment">//16位的端口号，以网络字节序保存</span></span><br><span class="line">    <span class="keyword">struct</span>            <span class="title class_">in_addr</span>  sin_addr;     <span class="comment">//32位IP地址</span></span><br><span class="line">    <span class="type">char</span>              sin_zero[<span class="number">8</span>];             <span class="comment">//不使用，一般用0填充，目的是与sockaddr结构体保持一致</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中in_addr</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">in_addr_t</span> s_addr; <span class="comment">/*32-bit IPV4 address*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>sin_family：地址族（Address Family）<ul>
<li>AF_INET：ipv4网络协议地址族</li>
<li>AF_INET6：ipv6</li>
<li>AF_LOCAL：</li>
</ul>
</li>
<li>sin_port：以<strong>网络字节序</strong>保存16位端口号</li>
<li>sin_addr：也是一个结构体，但内部只有一个32位的成员s_addr，存放的是IP地址的<strong>网络字节序</strong>。</li>
</ul>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230413123150638.png" alt="image-20230413123150638" style="zoom:50%;" />

<p>向sockaddr_in注入地址时，需要将<strong>ip地址的字符串形式</strong>和<strong>端口号的主机字节序形式</strong>转化为<strong>网络字节序</strong>的形式；而相反地，网络字节序也能转化回字符串形式和主机字节序形式。（字符串形式本质是ASCII码存储的形式，在主机也是以主机字节序存储，也要转化为网络字节序）</p>
<p><strong>值得注意的是，除了向sockaddr_in结构体填充数据外，其他情况无需考虑字节序问题。</strong></p>
<h3 id="sockaddr-in结构体设置例程"><a href="#sockaddr-in结构体设置例程" class="headerlink" title="sockaddr_in结构体设置例程"></a>sockaddr_in结构体设置例程</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">serv_addr.sin_family = AF_INET; <span class="comment">//选择协议族为IPV4 </span></span><br><span class="line">serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT); <span class="comment">//绑定我们自定义的端口号，客户端程序和我们服务器程序通讯时，就要往这个端口连接和传送数据 </span></span><br><span class="line">serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"><span class="comment">// 一个服务器可能有多块网卡，每个网卡也可能配置多个IP地址，所以用INADDR_ANY，表示服务器的所有可用IP地址，这样监听到9000端口，无论是哪个IP地址都能收到</span></span><br></pre></td></tr></table></figure>

<h2 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h2><h3 id="1-大小端"><a href="#1-大小端" class="headerlink" title="1 大小端"></a>1 大小端</h3><p>假设主机字节序中，存储是数据是0x12345678</p>
<ul>
<li>大端模式（网络字节序）：高位字节存放在内存的低地址处</li>
</ul>
<table>
<thead>
<tr>
<th>数据</th>
<th>12</th>
<th>34</th>
<th>56</th>
<th>78</th>
</tr>
</thead>
<tbody><tr>
<td>地址</td>
<td>0x00</td>
<td>0x01</td>
<td>0x02</td>
<td>0x03</td>
</tr>
</tbody></table>
<p>大端适合网络传输（流方式或者缓冲区）一次读一个字节，然后解析字节，读下一个字节。</p>
<ul>
<li>小端模式：高位字节存放在内存的高地址处</li>
</ul>
<table>
<thead>
<tr>
<th>数据</th>
<th>78</th>
<th>56</th>
<th>34</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>地址</td>
<td>0x00</td>
<td>0x01</td>
<td>0x02</td>
<td>0x03</td>
</tr>
</tbody></table>
<p>小端适合逻辑电路</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/458844566/answer/2567243550">https://www.zhihu.com/question/458844566/answer/2567243550</a></p>
</blockquote>
<h3 id="端口号的网络字节序转换"><a href="#端口号的网络字节序转换" class="headerlink" title="端口号的网络字节序转换"></a>端口号的网络字节序转换</h3><p>然后介绍4种转化字节的方法。htons中h表示主机host，n表示网络network，s表示short，所以是h、to、n、s、l的排列组合，htons解释为把short型数据从主机字节序列转化为网络字节序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">htons</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">ntohs</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">htonl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">ntohl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>转化实例</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> host_port = <span class="number">0x1234</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> net_port;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> host_port_l = <span class="number">0x12345678</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> net_port_l;</span><br><span class="line">	</span><br><span class="line">	net_port = <span class="built_in">htons</span>(host_port);</span><br><span class="line">	net_port_l = <span class="built_in">htonl</span>(host_port_l);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Host ordered port short: %#x \n&quot;</span>, host_port);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Nerwork ordered port short: %#x \n&quot;</span>, net_port);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Host ordered port long: %#xl \n&quot;</span>, host_port_l);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Nerwork ordered port long: %#xl \n&quot;</span>, net_port_l);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图小端cpu的转化结果，若是在大端CPU上，则不会变化<br><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230413115930385.png" alt="image-20230413115930385"></p>
<h3 id="ip地址的网络字节序转换"><a href="#ip地址的网络字节序转换" class="headerlink" title="ip地址的网络字节序转换"></a>ip地址的网络字节序转换</h3><p>用到的函数分别inet_addr()、inet_aton()、inet_ntoa()、inet_pton()、inet_ntop()，转化的方向如下图。</p>
<p><img src="https://github.com/drinkwateronly/Image-Host/blob/main/iimage/image-20230413115034891.png?raw=true" alt="image-20230413115034891"></p>
<h4 id="2-1-inet-addr"><a href="#2-1-inet-addr" class="headerlink" title="2.1 inet_addr()"></a>2.1 inet_addr()</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：是将一个点分十进制ipv4的IP地址转换32位大端网络字节序整数</li>
<li>参数：点分十进制的ip地址字符串ip</li>
<li>返回值：成功时返回32位大端整数，失败返回INADDR_NONE</li>
</ul>
<h4 id="2-2-inet-aton-和inet-ntoa"><a href="#2-2-inet-aton-和inet-ntoa" class="headerlink" title="2.2 inet_aton()和inet_ntoa()"></a>2.2 inet_aton()和inet_ntoa()</h4><p><code>inet_addr()</code>直接返回结果，而<code>inet_aton()</code>将转换结果直接写入传入的参数中，方便向sockaddr_in注入IP地址。<br>记法：ASCII to network &#x2F; network to ASCII</p>
<h5 id="inet-aton"><a href="#inet-aton" class="headerlink" title="inet_aton()"></a>inet_aton()</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="keyword">struct</span> in_addr *addr)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：是将一个点分十进制的ipv4的IP地址转换32位大端网络字节序整数，结果直接填入in_addr中，使用频率比<code>inet_addr()</code>多。</li>
<li>参数：</li>
</ul>
<blockquote>
<ol>
<li>string: 点分十进制的ip地址字符串ip</li>
<li>addr: 属于sockaddr_in结构体的结构体in_addr地址</li>
</ol>
</blockquote>
<ul>
<li>返回值：成功时返回1，失败返回0</li>
</ul>
<h5 id="inet-ntoa"><a href="#inet-ntoa" class="headerlink" title="inet_ntoa()"></a>inet_ntoa()</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr *addr )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：是将一个32位大端网络字节序整数转换为点分十进制的ipv4的IP地址。</li>
<li>参数：</li>
</ul>
<blockquote>
<ol>
<li>addr: 属于sockaddr_in结构体的结构体in_addr地址</li>
</ol>
</blockquote>
<ul>
<li>返回值：存放转化结果的首地址，char*指针，要提前分配空间。失败时返回-1。</li>
</ul>
<h4 id="2-3-inet-pton-inet-ntop"><a href="#2-3-inet-pton-inet-ntop" class="headerlink" title="2.3 inet_pton()inet_ntop()"></a>2.3 inet_pton()inet_ntop()</h4><p>前面的只适用于ipv4地址，这两个适用于ipv4和ipv6，因此使用时要指定地址族<br>记法：presentation to numeric &#x2F; numeric to presentation</p>
<h5 id="inet-pton"><a href="#inet-pton" class="headerlink" title="inet_pton()"></a>inet_pton()</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *ip, <span class="type">void</span> *dst)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：将ipv4或者ipv6的字符串ip地址转换为大端网络字节序整数</li>
<li>参数：</li>
</ul>
<blockquote>
<ol>
<li>af: 地址族，取值为AF_INET和AF_INET6，分别ipv4和ipv6</li>
<li>ip：要转化的ip字符串首地址</li>
<li>dst：接收转化后大端网络字节序整数结果的地址，ipv4可以用sin_addr</li>
</ol>
</blockquote>
<ul>
<li>返回值：如果函数出错将返回一个负值，并将errno设置为EAFNOSUPPORT，如果参数af指定的地址族和ip格式不对，函数将返回0。</li>
</ul>
<h5 id="inet-ntop"><a href="#inet-ntop" class="headerlink" title="inet_ntop()"></a>inet_ntop()</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> cnt)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：将为大端网络字节序整数转换为ipv4或者ipv6的字符串ip地址</li>
<li>参数：</li>
</ul>
<blockquote>
<ol>
<li>af: 地址族，取值为AF_INET和AF_INET6，分别ipv4和ipv6</li>
<li>src：大端网络字节序整数首地址地址，ipv4可以用sin_addr</li>
<li>dst：接收转化后的ip地址字符串首地址（缓冲区）</li>
<li>cnt：dst缓冲区大小</li>
</ol>
</blockquote>
<ul>
<li>返回值：<br>如果缓存区太小无法存储地址的值，则返回一个空指针，并将errno置为ENOSPC。若无错误发生，Inet_ntop()函数返回一个指向缓冲区的指针。</li>
</ul>
<h4 id="2-4例程"><a href="#2-4例程" class="headerlink" title="2.4例程"></a>2.4例程</h4><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">char</span> ip1[] = <span class="string">&quot;192.168.0.74&quot;</span>;  </span><br><span class="line">    <span class="type">char</span> fakeip[] = <span class="string">&quot;192.256.0.74&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_inet</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    inet_addr()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip %s converting\n&quot;</span>,ip1);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> net_ordered_addr = inet_addr(ip1);</span><br><span class="line">    <span class="keyword">if</span>(net_ordered_addr == INADDR_NONE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_addr() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_addr() success: network ordered integer addr: %#x \n\n&quot;</span>,</span><br><span class="line">            net_ordered_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fake ip</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake ip %s converting\n&quot;</span>, fakeip);</span><br><span class="line">    net_ordered_addr = inet_addr(fakeip);</span><br><span class="line">    <span class="keyword">if</span>(inet_aton(fakeip,&amp;addr_inet.sin_addr)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_addr() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_addr() success: network ordered integer addr: %#x \n\n&quot;</span>,</span><br><span class="line">            net_ordered_addr);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    inet_aton() and inet_ntoa()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip %s converting\n&quot;</span>,ip1);</span><br><span class="line">    <span class="keyword">if</span>(inet_aton(ip1,&amp;addr_inet.sin_addr)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_aton() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_aton() success: network ordered integer addr: %#x \n\n&quot;</span>,</span><br><span class="line">            addr_inet.sin_addr.s_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;network odered addr %#x converting\n&quot;</span>,addr_inet.sin_addr.s_addr);</span><br><span class="line">    <span class="type">char</span> *ip_new;</span><br><span class="line">    ip_new = inet_ntoa(addr_inet.sin_addr);</span><br><span class="line">    <span class="keyword">if</span>(ip_new[<span class="number">0</span>]== <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_ntoa() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_ntoa() success: ip: %s \n\n&quot;</span>, ip_new);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    inet_pton() and inet_ntop()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">char</span> ip2[] = <span class="string">&quot;255.255.255.255&quot;</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip %s converting\n&quot;</span>, ip2);</span><br><span class="line">    <span class="keyword">if</span>(!inet_pton(AF_INET, ip2, (<span class="type">void</span> *) &amp;addr_inet.sin_addr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton() success: network ordered integer addr: %#x \n\n&quot;</span>,</span><br><span class="line">            addr_inet.sin_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> ip2_new[<span class="number">16</span>];  <span class="comment">//ipv4的字符串长度为16字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;network odered addr %#x converting\n&quot;</span>, addr_inet.sin_addr.s_addr);</span><br><span class="line">    <span class="keyword">if</span>(!inet_ntop(AF_INET, (<span class="type">void</span> *) &amp;addr_inet.sin_addr, ip2_new, <span class="keyword">sizeof</span>(ip2_new)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton() success: ip: %s \n\n&quot;</span>, ip2_new);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><h1 id="三、向套接字分配网络地址"><a href="#三、向套接字分配网络地址" class="headerlink" title="三、向套接字分配网络地址"></a>三、向套接字分配网络地址</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：bind 能够将socket文件描述符、端口号和ip绑定到一起。因为socket只指明了协议。</li>
<li>返回值：成功时返回0，失败返回-1</li>
<li>参数：<ul>
<li>sockfd： 表示socket函数创建的通信文件描述符</li>
<li>addr： struct sockaddr_in或sockaddr的首地址，用于设定要绑定的ip和端口</li>
<li>addrlen： 表示所指定addr结构体的大小</li>
</ul>
</li>
</ul>
<h1 id="四、进入-等待连接请求-状态"><a href="#四、进入-等待连接请求-状态" class="headerlink" title="四、进入 等待连接请求 状态"></a>四、进入 等待连接请求 状态</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：<br>将套接字文件描述符从主动（<strong>主动向对方发送数据</strong>）转为被动文件描述符，然后用于被动监听客户端的连接</li>
<li>参数：<ul>
<li>sockfd：socket文件描述符</li>
<li>backlog：指定队列的容量，一般设置队列的容量为2，3即可。队列的最大容量需要小于30</li>
</ul>
</li>
<li>返回值：成功返回0，失败返回-1， errno被设置</li>
</ul>
<p><code>listen()</code>函数不会阻塞，它仅将该套接字和套接字对应的连接队列长度告诉 Linux 内核后结束。<strong>当客户端connect，内核自动完成TCP三次握手</strong>。然后建立好的连接会自动存储到<code>listen()</code>所创建的队列中。</p>
<p>注意，在<code>listen()</code>调用之前，客户端如果调用<code>connect()</code>会发生错误。</p>
<h2 id="4-1-listen队列剖析"><a href="#4-1-listen队列剖析" class="headerlink" title="4.1 listen队列剖析"></a>4.1 listen队列剖析</h2><h3 id="4-1-1-两个队列"><a href="#4-1-1-两个队列" class="headerlink" title="4.1.1 两个队列"></a>4.1.1 两个队列</h3><p>对于一个调用<code>listen</code>的套接字，OS会为其维护两个队列</p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230421101903025.png" alt="image-20230421101903025" style="zoom:50%;" />

<ul>
<li><p>未完成连接队列：</p>
<p>当客户端发送TCP握手第一次握手（SYN），服务器端会在未完成连接队列创建一个对应项，该项可以看作是一个半连接，状态从<code>LISTEN</code>变成<code>SYN_RCVD</code>，同时服务器向客户端第二次握手（SYN+ACK），等待来自客户端的第三次握手。</p>
</li>
<li><p>已完成连接队列</p>
<p>三次握手完成后，连接变成<code>ESTABLISHED</code>状态，放入已连接队列中</p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230421102441451.png" alt="image-20230421102441451" style="zoom: 67%;" />

<p>有两个RTT，分别针对客户端与服务器而言。三次握手需要大约187ms建立，比较慢。</p>
</li>
</ul>
<h3 id="4-1-2-出现的问题与如何避免"><a href="#4-1-2-出现的问题与如何避免" class="headerlink" title="4.1.2 出现的问题与如何避免"></a>4.1.2 出现的问题与如何避免</h3><p>可以看到客户端的<code>connect</code>是收到第二次握手包就返回了，如果客户端迟迟不发送第三个握手包，该半连接项约75s就会被OS删除。</p>
<p>如果队列已满，客户端发送来SYN请求，服务器不会回应，几次后客户端认为连接失败。</p>
<p>进而产生了一种攻击：SYN攻击，即客户端一直只发送第一个握手包，使得队列超过<code>backlog</code>，使得队列变满，正常用户无法连接。</p>
<ul>
<li>原本<code>listen</code>函数<code>backlog</code>参数的含义是以上两个队列之和</li>
<li>后来改成：<strong>指定套接字（服务器监听套接字）上内核为其排队的最大已完成连接数</strong>，也就是<code>ESTABLISHED</code>队列的长度，忽略了<code>SYN_RCVD</code>队列长度。此时程序员只需要关心尽快用<code>accept</code>（下一节内容）将连接取走腾出位置。但实际上仍有未完成连接队列，只不过OS会对他处理。</li>
</ul>
<h1 id="五、受理客户端请求"><a href="#五、受理客户端请求" class="headerlink" title="五、受理客户端请求"></a>五、受理客户端请求</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>函数功能：<br>从established 状态的连接队列头部取出一个已经完成的连接，<strong>产生用于数据IO的套接字（返回值）</strong>。</p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230414104357561.png" alt="image-20230414104357561" style="zoom: 67%;" />
</li>
<li><p>函数返回值：成功返回<strong>套接字描述符</strong>，失败返回-1</p>
</li>
<li><p>参数</p>
<ul>
<li>sockfd：表示socket创建的监听socket描述符</li>
<li>addr：用于存放发起连接请求的那个客户端的地址结构体sockaddr地址</li>
<li>addrlen：存放第二个参数addr的大小的变量地址</li>
</ul>
</li>
</ul>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul>
<li><p><strong>注意两个套接字，<code>socket()</code>生成的套接字是用于<code>bind</code>绑定和<code>listen</code>监听和<code>accept</code>受理请求，而<code>accept</code>生成的套接字用于和客户端交换数据。</strong></p>
</li>
<li><p>套接字文件描述符默认是阻塞的，即如果没有客户端请求连接的时候，此时accept会<strong>阻塞</strong>，直到有客户端连接；如果不想套接字文件描述符阻塞，则可以创建套接字 socket函数 时指定type为SOCK_NOBLOCK。</p>
</li>
<li><p>如果accept没来得及取走一个连接，由于三次握手已经完成，套接字已经创建，此时客户端发送数据过来，就会发送到套接字的接收缓冲区，缓冲区大小就是最大能接受的数据量。</p>
</li>
</ul>
<h1 id="六、数据传输"><a href="#六、数据传输" class="headerlink" title="六、数据传输"></a>六、数据传输</h1><p>此后就可以通过操作<code>accept</code>所返回套接字对客户端进行IO数据传输。可以使用系统I&#x2F;O直接对文件描述符操作，也可以将文件描述符转为FILE指针用C标准库IO操作。</p>
<h1 id="七、关闭连接"><a href="#七、关闭连接" class="headerlink" title="七、关闭连接"></a>七、关闭连接</h1><p>对客户端的服务结束后，调用<code>close</code>关闭套接字，即关闭了连接。流的概念是通过<strong>相互连接的套接字</strong>进入数据交换的状态，下图展示了TCP套接字的流。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415131850510.png" alt="image-20230415131850510"></p>
<p><code>close</code>意味着完全断开两个流，这样的关闭方式不够优雅。可以使用<code>shutdown</code>进行半关闭。这样的话在一端传递完数据半关闭连接后，另一端仍能传递数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> howto)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li>sock：要关闭的socket</li>
<li>howto：如何关闭<ul>
<li>SHUT_RD：断开输入流</li>
<li>SHUT_WR：断开输出流</li>
<li>SHUT_RDWR：同时断开</li>
</ul>
</li>
</ul>
</li>
<li>返回：成功0，失败-1</li>
</ul>
<h1 id="八、服务器代码例程"><a href="#八、服务器代码例程" class="headerlink" title="八、服务器代码例程"></a>八、服务器代码例程</h1><p>来自《C++新经典 Linux C++通信架构实战》</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9000  <span class="comment">//本服务器要监听的端口号，一般1024以下的端口很多都是属于周知端口，所以我们一般采用1024之后的数字做端口号</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">//这些演示代码的写法都是固定套路，一般都这么写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器的socket套接字【文件描述符】</span></span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>                  <span class="comment">//服务器的地址结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));        <span class="comment">//初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置本服务器要监听的地址和端口，这样客户端才能连接到该地址和端口并发送数据</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;                <span class="comment">//选择协议族为IPV4</span></span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);         <span class="comment">//绑定我们自定义的端口号，客户端程序和我们服务器程序通讯时，就要往这个端口连接和传送数据</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">//监听本地所有的IP地址；INADDR_ANY表示的是一个服务器上所有的网卡（服务器可能不止一个网卡）多个本地ip地址都进行绑定端口号，进行侦听。</span></span><br><span class="line"></span><br><span class="line">    bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));<span class="comment">//绑定服务器地址结构体</span></span><br><span class="line">    listen(listenfd, <span class="number">32</span>);     <span class="comment">//参数2表示服务器可以积压的未处理完的连入请求总个数，客户端来一个未连入的请求，请求数+1，连入请求完成，c/s之间进入正常通讯后，请求数-1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> connfd;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pcontent = <span class="string">&quot;I sent sth to client!&quot;</span>; <span class="comment">//指向常量字符串区的指针</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//卡在这里，等客户单连接，客户端连入后，该函数走下去【注意这里返回的是一个新的socket——connfd，后续本服务器就用connfd和客户端之间收发数据，而原有的lisenfd依旧用于继续监听其他连接】        </span></span><br><span class="line">        connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据包给客户端</span></span><br><span class="line">        write(connfd,pcontent,<span class="built_in">strlen</span>(pcontent)); <span class="comment">//注意第一个参数是accept返回的connfd套接字</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只给客户端发送一个信息，然后直接关闭套接字连接；</span></span><br><span class="line">        close(connfd); </span><br><span class="line">    &#125; <span class="comment">//end for</span></span><br><span class="line">    close(listenfd);     <span class="comment">//实际本简单范例走不到这里，这句暂时看起来没啥用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>ch2-基于TCP的客户端实现</title>
    <url>/2023/04/214ad3674984/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230414100114373.png" alt="image-20230414100114373"></p>
<h1 id="一、创建socket"><a href="#一、创建socket" class="headerlink" title="一、创建socket"></a>一、创建socket</h1><h1 id="二、-服务器的IP地址、端口信息结构体"><a href="#二、-服务器的IP地址、端口信息结构体" class="headerlink" title="二、 服务器的IP地址、端口信息结构体"></a>二、 服务器的IP地址、端口信息结构体</h1><h1 id="三、请求连接服务器"><a href="#三、请求连接服务器" class="headerlink" title="三、请求连接服务器"></a>三、请求连接服务器</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* server_addr, <span class="type">socklen_t</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数<ul>
<li>sockfd：套接字文件描述符</li>
<li>server_addr：sockaddr结构体指针，<strong>存放目标服务器的IP地址与端口号</strong>。我们构建的是sockaddr_id结构体，但两种结构体都是16字节，结构相似，可以进行强制类型转换。</li>
<li>addrlen：sockaddr的长度，sizeof()即可。</li>
</ul>
</li>
<li>返回值，成功0，失败-1。</li>
</ul>
<p><code>connect</code>并不意味着服务器端调用<code>accept</code>，可能会进入等待队列，<strong>这个函数的作用仅是通知 Linux 内核，让内核完成 TCP 三次握手连接。</strong></p>
<p><code>connect</code>会阻塞，直到连接成功&#x2F;失败。</p>
<p><code>connect</code>函数第二个参数保存的是目标服务器的结构体地址信息，那么客户端socket的地址信息在哪？：客户端IP地址和端口在调用<code>connect</code>时自动分配，无需<code>bind</code>，IP地址则是主机IP，端口随机。</p>
<h1 id="四、五、数据I-O与关闭连接"><a href="#四、五、数据I-O与关闭连接" class="headerlink" title="四、五、数据I&#x2F;O与关闭连接"></a>四、五、数据I&#x2F;O与关闭连接</h1><h1 id="六、服务器代码例程"><a href="#六、服务器代码例程" class="headerlink" title="六、服务器代码例程"></a>六、服务器代码例程</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9000    <span class="comment">//要连接到的服务器端口，服务器必须在这个端口上listen着</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv)</span></span>&#123;    </span><br><span class="line">    <span class="comment">//这些演示代码的写法都是固定套路，一般都这么写</span></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建客户端socket，地址家族，套接字类型，套接字协议</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置要连接到的服务器的信息</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;                <span class="comment">//选择协议族为IPV4</span></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT);         <span class="comment">//连接到的服务器端口，服务器监听这个地址</span></span><br><span class="line">    <span class="comment">//这里为了方便演示，要连接的服务器地址固定写</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">inet_pton</span>(AF_INET,<span class="string">&quot;192.168.1.126&quot;</span>,&amp;serv_addr.sin_addr) &lt;= <span class="number">0</span>)  <span class="comment">//IP地址转换函数,把第二个参数对应的ip地址转换第三个参数里边去，固定写法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;调用inet_pton()失败，退出！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;serv_addr,<span class="built_in">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;调用connect()失败，退出！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> recvline[<span class="number">1000</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(( n = <span class="built_in">read</span>(sockfd,recvline,<span class="number">1000</span>)) &gt; <span class="number">0</span>) <span class="comment">//仅供演示，非商用，所以不检查收到的宽度，实际商业代码，不可以这么写</span></span><br><span class="line">    &#123;</span><br><span class="line">        recvline[n] = <span class="number">0</span>; <span class="comment">//实际商业代码要判断是否收取完毕等等，所以这个代码只有学习价值，并无商业价值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;收到的内容为：%s\n&quot;</span>,recvline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd); <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序执行完毕，退出!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>ch4-IP地址与域名转换</title>
    <url>/2023/04/b0de70d75858/</url>
    <content><![CDATA[<h1 id="1-DNS"><a href="#1-DNS" class="headerlink" title="1 DNS"></a>1 DNS</h1><p>DNS（Domain Name System），即IP和域名相互转换的系统，核心是DNS服务器。</p>
<p>ISP服务提供者维护IP地址时可能会变更IP地址，而域名一旦注册通常不会变化，<strong>因此利用域名编写程序就不会依赖某个服务器IP地址</strong>。</p>
<p>查看本机的DNS服务器地址</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&gt; nslookup</span><br></pre></td></tr></table></figure>

<h1 id="2-通过域名获取IP地址gethostbyname"><a href="#2-通过域名获取IP地址gethostbyname" class="headerlink" title="2 通过域名获取IP地址gethostbyname()"></a>2 通过域名获取IP地址gethostbyname()</h1><h2 id="2-1-使用方法"><a href="#2-1-使用方法" class="headerlink" title="2.1 使用方法"></a>2.1 使用方法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hostname)</span></span><br></pre></td></tr></table></figure>
<p>成功返回hostent结构体地址，失败返回null指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> * h_name; </span><br><span class="line">    <span class="type">char</span> ** h_aliases;</span><br><span class="line">    <span class="type">int</span> h_addrtype;</span><br><span class="line">    <span class="type">int</span> h_length;</span><br><span class="line">    <span class="type">char</span> ** h_addr_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>h_name：官方域名</li>
<li>h_aliases：除官方域名外同样能访问的其他域名</li>
<li>h_addrtype：ip地址族类型</li>
<li>h_length：ip地址长度（IPv4是4字节，IPv6是16字节</li>
<li>h_addr_list：<strong>最重要的成员</strong>。用户多的网站会分配多个IP给一个域名，利用多个服务器进行负载均衡，所以存放多个IP地址。</li>
</ul>
</blockquote>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415154631974.png" alt="image-20230415154631974" style="zoom:67%;" />

<p>注意，<code>h_addr_list</code>是一个char指针数组（字符串地址构成的数组），但数组元素实际保存的是<code>in_addr</code>结构体变量地址值，结构体如下，s_addr保存一个网络字节序（大端）的IP整型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr; <span class="comment">/*32-bit IPV4 address*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>原因是hostent结构体并非只是为ipv4准备的（sockaddr和sockaddr_in也是有类似的关系，sockaddr并非只为ipv4准备）。</strong></p>
</li>
<li><p><strong>看起来声明为void指针数组更合适，而<code>hostent</code>结构体是在void指针标准化前就定义的，当时无法明确指出指针类型时采用char指针。</strong></p>
</li>
</ul>
<h2 id="2-2-例程"><a href="#2-2-例程" class="headerlink" title="2.2 例程"></a>2.2 例程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;addr&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取ip地址信息</span></span><br><span class="line">    host = gethostbyname(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(!host)</span><br><span class="line">        error_handling(<span class="string">&quot;gethostbyname() error&quot;</span>);</span><br><span class="line">    <span class="comment">// 其他附带的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Official name: %s \n&quot;</span>, host-&gt;h_name);      </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; host-&gt;h_aliases[i]; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Official name: %s \n&quot;</span>, host-&gt;h_aliases[i]);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address type: %s \n&quot;</span>,</span><br><span class="line">                (host-&gt;h_addrtype==AF_INET?<span class="string">&quot;AF_INET&quot;</span>:<span class="string">&quot;AF_INET6&quot;</span>));    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IP length: %d \n&quot;</span>, host-&gt;h_length);    </span><br><span class="line">    <span class="comment">// ip地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> *<span class="title">inaddr</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; host-&gt;h_addr_list[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 强制类型转化</span></span><br><span class="line">        <span class="comment">// h_addr_list是一个char指针数组（字符串地址构成的数组），但数组元素实际保存的是in_addr结构体变量地址值</span></span><br><span class="line">        inaddr = (<span class="keyword">struct</span> in_addr *)host-&gt;h_addr_list[i];</span><br><span class="line">        <span class="comment">// 查看网络字节序ip地址的整数形式</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in_addr.s_addr: %d \n&quot;</span>,inaddr-&gt;s_addr);</span><br><span class="line">        <span class="comment">// inet_ntoa转化网络字节序为字符串IP地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP address: %s \n&quot;</span>, inet_ntoa(*inaddr));  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-运行结果"><a href="#2-3-运行结果" class="headerlink" title="2.3 运行结果"></a>2.3 运行结果</h2><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415152343436.png" alt="image-20230415152343436"><br>结果中得到了<a href="http://www.baidu.com域名的ip地址信息，一个值得关注的点是，在in_addr结构体中的s_addr整数存放的是网络字节序（大端）的整数形式的IP地址。IP地址大小端存放方式与对应十进制整数的转化方式如下：">www.baidu.com域名的ip地址信息，一个值得关注的点是，在in_addr结构体中的s_addr整数存放的是网络字节序（大端）的整数形式的IP地址。IP地址大小端存放方式与对应十进制整数的转化方式如下：</a></p>
<h3 id="小端"><a href="#小端" class="headerlink" title="小端"></a>小端</h3><p>小端存放的IP地址转十进制整数的方式为：</p>
<table>
<thead>
<tr>
<th>十进制</th>
<th>182</th>
<th>61</th>
<th>200</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>二进制</td>
<td>10110110</td>
<td>00111101</td>
<td>11001000</td>
<td>00000111</td>
</tr>
<tr>
<td>地址顺序</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>串联二进制10110110001111011100100000000111 -&gt; 转为十进制3057502215</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="大端"><a href="#大端" class="headerlink" title="大端"></a>大端</h3><p>in_addr存放IP地址的方式是网络字节序（大端），即高位数据在低地址，地址顺序如上表。而电脑（小端）读取顺序从低地址开始读，先读到的是这个数的最低字节，所以读取到数据为：</p>
<table>
<thead>
<tr>
<th>7</th>
<th>200</th>
<th>61</th>
<th>182</th>
</tr>
</thead>
<tbody><tr>
<td>00000111</td>
<td>11001000</td>
<td>00111101</td>
<td>10110110</td>
</tr>
</tbody></table>
<p>串联二进制00000111110010000011110110110110-&gt; 转为十进制130563510，所以in_addr.s_addr的整数形式是130563510。</p>
<h1 id="3-通过IP获取域名信息gethostbyaddr"><a href="#3-通过IP获取域名信息gethostbyaddr" class="headerlink" title="3 通过IP获取域名信息gethostbyaddr()"></a>3 通过IP获取域名信息gethostbyaddr()</h1><h2 id="3-1-使用方法"><a href="#3-1-使用方法" class="headerlink" title="3.1 使用方法"></a>3.1 使用方法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* addr, <span class="type">socklen_t</span> len, <span class="type">int</span> family)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数<ul>
<li>addr：IP地址的网络字节序，一般是存放在in_addr结构体，并在传参的时候(char*)对结构体地址强制类型转换。（实际测试时，似乎也不需要强制类型转换）</li>
<li>len：IP地址字节长度</li>
<li>family：IP地址协议族（AF_INET或者AF_INET6）</li>
</ul>
</li>
<li>返回值：成功返回hostent结构体地址，失败返回null</li>
</ul>
<h2 id="3-2-例程"><a href="#3-2-例程" class="headerlink" title="3.2 例程"></a>3.2 例程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>,stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hostent</span> *host;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ip转为网络字节序</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sockaddr;</span><br><span class="line">    <span class="comment">/* 方法1</span></span><br><span class="line"><span class="comment">    // ip地址转网络字节序并存放在sockaddr_in的in_addr结构体</span></span><br><span class="line"><span class="comment">    sockaddr.sin_addr.s_addr = inet_addr(argv[1]);</span></span><br><span class="line"><span class="comment">    memset(&amp;sockaddr, 0, sizeof(sockaddr));</span></span><br><span class="line"><span class="comment">    host = gethostbyaddr((char*)&amp;sockaddr.sin_addr, 4, AF_INET);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 方法2</span></span><br><span class="line">    <span class="comment">// ip地址转网络字节序并存放在单独的in_addr结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> inaddr1;</span><br><span class="line">    inaddr1.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 注意(char*)</span></span><br><span class="line">    host = <span class="built_in">gethostbyaddr</span>((<span class="type">char</span>*)&amp;inaddr1, <span class="number">4</span>, AF_INET);</span><br><span class="line">    <span class="keyword">if</span>(!host)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;gethostbyname() error&quot;</span>);</span><br><span class="line">    <span class="comment">// 其他附带的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Official name: %s \n&quot;</span>, host-&gt;h_name);      </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; host-&gt;h_aliases[i]; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Official name: %s \n&quot;</span>, host-&gt;h_aliases[i]);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address type: %s \n&quot;</span>,</span><br><span class="line">                (host-&gt;h_addrtype==AF_INET?<span class="string">&quot;AF_INET&quot;</span>:<span class="string">&quot;AF_INET6&quot;</span>));    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IP length: %d \n&quot;</span>, host-&gt;h_length);    </span><br><span class="line">    <span class="comment">// ip地址信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> *inaddr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; host-&gt;h_addr_list[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        inaddr = (<span class="keyword">struct</span> in_addr *)host-&gt;h_addr_list[i];</span><br><span class="line">        <span class="comment">// 查看in_addr.s_addr的网络字节序ip地址，整数存放</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in_addr.s_addr: %u \n&quot;</span>,inaddr-&gt;s_addr);</span><br><span class="line">        <span class="comment">// inet_ntoa转化网络字节序为字符串IP地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP address: %s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(*inaddr));  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-结果"><a href="#3-3-结果" class="headerlink" title="3.3 结果"></a>3.3 结果</h2><p> <img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415153656086.png" alt="image-20230415153656086"><br>通过2小节的gethostbyname获取了baidu.com的ip地址，但对ip地址获取时出现了获取不了host信息，并不是代码出错，看到网上不少人也出现这样的问题。一个猜测是：</p>
<blockquote>
<p>gethostbyname可以通过DNS服务器通过域名获取ip地址等信息。但是gethostbyaddr输入参数时ip地址，这样无需经过dns转换，无法获取域名等信息，但是可以在hosts文件中增加一个映射，它应该会检查hosts文件。所以在host文件添加ip和域名的映射即可。<br><a href="https://bbs.csdn.net/topics/391815602">https://bbs.csdn.net/topics/391815602</a></p>
</blockquote>
<p>而获取电信dns服务器114.114.114.114的host信息是可以的<br><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415153750412.png" alt="image-20230415153750412"></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>ch5-Socket可选项</title>
    <url>/2023/04/6eb876a3f705/</url>
    <content><![CDATA[<h1 id="1-设置和读取套接字可选项"><a href="#1-设置和读取套接字可选项" class="headerlink" title="1 设置和读取套接字可选项"></a>1 设置和读取套接字可选项</h1><p>套接字可以设置出不同的特性，这里给出一部分较为重要的可选项含义与设置方法。</p>
<h2 id="1-1-使用方法"><a href="#1-1-使用方法" class="headerlink" title="1.1 使用方法"></a>1.1 使用方法</h2><h3 id="1-1-1-getsockopt"><a href="#1-1-1-getsockopt" class="headerlink" title="1.1.1 getsockopt"></a>1.1.1 getsockopt</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：读取套接字可选项</li>
<li>参数<ul>
<li>sock: 套接字</li>
<li>level：查看可选项的协议层</li>
<li>optname：查看可选项的名称</li>
<li>optval：保存读取结果的缓冲地址</li>
<li>optlen：缓冲区大小，调用后保存可选信息的字节数</li>
</ul>
</li>
<li>返回值：成功0，失败-1</li>
</ul>
<h3 id="1-1-2-setsockopt"><a href="#1-1-2-setsockopt" class="headerlink" title="1.1.2 setsockopt"></a>1.1.2 setsockopt</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：设置套接字可选项</li>
<li>参数<ul>
<li>sock: 套接字</li>
<li>level：要更改的可选项的协议层</li>
<li>optname：要更改的可选项的名称</li>
<li>optval：保存要更改信息的缓冲区地址</li>
<li>optlen：缓冲区大小</li>
</ul>
</li>
<li>返回值：成功0，失败-1</li>
</ul>
<h2 id="1-2-例程：查看TCP和UDP的套接字类型"><a href="#1-2-例程：查看TCP和UDP的套接字类型" class="headerlink" title="1.2 例程：查看TCP和UDP的套接字类型"></a>1.2 例程：查看TCP和UDP的套接字类型</h2><p>level： <code>SOL_SOCKET</code></p>
<p>optname： <code>SO_TYPE</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tcp_sock, udp_sock;</span><br><span class="line">    <span class="comment">// 存放getsockopt()返回结果</span></span><br><span class="line">    <span class="type">int</span> sock_type;</span><br><span class="line">    <span class="type">socklen_t</span> optlen;</span><br><span class="line">    optlen = <span class="keyword">sizeof</span>(sock_type);</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    tcp_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    udp_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建时指定的套接字类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SOCK_STREAM: %d \n&quot;</span>, SOCK_STREAM);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SOCK_DGRAM: %d \n&quot;</span>, SOCK_DGRAM);</span><br><span class="line">    <span class="comment">// 查看tcp的套接字类型</span></span><br><span class="line">    state = getsockopt(tcp_sock, SOL_SOCKET, SO_TYPE, (<span class="type">void</span>*)&amp;sock_type, &amp;optlen);</span><br><span class="line">    <span class="keyword">if</span>(state) <span class="comment">// getsockopt成功0，失败-1</span></span><br><span class="line">        error_handling(<span class="string">&quot;getsockopt() error&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket type one: %d\n&quot;</span>, sock_type);</span><br><span class="line">    <span class="comment">// 查看udp套接字类型</span></span><br><span class="line">    state = getsockopt(udp_sock, SOL_SOCKET, SO_TYPE, (<span class="type">void</span>*)&amp;sock_type, &amp;optlen);</span><br><span class="line">    <span class="keyword">if</span>(state) <span class="comment">// getsockopt成功0，失败-1</span></span><br><span class="line">        error_handling(<span class="string">&quot;getsockopt() error&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket type two: %d\n&quot;</span>, sock_type);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1-3-例程：设置和读取输入输出缓冲区"><a href="#1-3-例程：设置和读取输入输出缓冲区" class="headerlink" title="1.3 例程：设置和读取输入输出缓冲区"></a>1.3 例程：设置和读取输入输出缓冲区</h2><p>level： <code>SOL_SOCKET</code></p>
<p>optname：<code>SO_SNDBUF</code> &amp; <code>SO_RCVBUF</code></p>
<h3 id="1-3-1-代码"><a href="#1-3-1-代码" class="headerlink" title="1.3.1 代码"></a>1.3.1 代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> snd_buf, recv_buf;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="type">int</span> tcp_sock, udp_sock;</span><br><span class="line">    tcp_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    udp_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看tcp套接字的IO缓冲区大小</span></span><br><span class="line">    state = getsockopt(tcp_sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;snd_buf, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TCP send/Output buffer size: %d\n&quot;</span>, snd_buf);</span><br><span class="line">    state = getsockopt(tcp_sock, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;recv_buf, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TCP receive/Input buffer size: %d\n&quot;</span>, recv_buf);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 查看udp套接字的IO缓冲区大小</span></span><br><span class="line">    state = getsockopt(udp_sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;snd_buf, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP send/Output buffer size: %d\n&quot;</span>, snd_buf);</span><br><span class="line">    state = getsockopt(udp_sock, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;recv_buf, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP receive/Input buffer size: %d\n&quot;</span>, recv_buf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置tcp套接字的IO缓冲区大小</span></span><br><span class="line">    <span class="type">int</span> set_recv_buf = <span class="number">1024</span>*<span class="number">3</span>, set_snd_buf = <span class="number">1024</span>*<span class="number">4</span>;</span><br><span class="line">    state = setsockopt(tcp_sock, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;set_recv_buf, <span class="keyword">sizeof</span>(set_recv_buf));</span><br><span class="line">    state = setsockopt(tcp_sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;set_snd_buf, <span class="keyword">sizeof</span>(set_snd_buf));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看设置后tcp套接字的IO缓冲区大小</span></span><br><span class="line">    state = getsockopt(tcp_sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;snd_buf, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After setsockopt: TCP send/Output buffer size: %d\n&quot;</span>, snd_buf);</span><br><span class="line">    state = getsockopt(tcp_sock, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;recv_buf, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After setsockopt: TCP receive/Input buffer size: %d\n&quot;</span>, recv_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-结果"><a href="#1-3-2-结果" class="headerlink" title="1.3.2 结果"></a>1.3.2 结果</h3><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415222338145.png" alt="image-20230415222338145"></p>
<p>8192和6144并不是我们代码中4*1024和3*1024的大小设置，因为不会完全按照我们的要求设置，防止缓冲区被错误设置。</p>
<blockquote>
<p> 任何UDP套接字都有发送缓冲区大小，但<strong>实际上不存在UDP发送缓冲区</strong>，其大小仅仅是可写到套接字的UDP数据报的大小上限。如果一个应用进程写一个大于套接字发送缓冲区大小的数据报，内核将返回该进程一个EMSGSIZE错误。</p>
<p><a href="https://blog.csdn.net/legend050709/article/details/128437143">(19条消息) udp缓冲区_legend050709ComeON的博客-CSDN博客</a></p>
</blockquote>
<h2 id="1-4-地址再分配：SO-REUSEADDR"><a href="#1-4-地址再分配：SO-REUSEADDR" class="headerlink" title="1.4 地址再分配：SO_REUSEADDR"></a>1.4 地址再分配：SO_REUSEADDR</h2><h3 id="1-4-1-time-wait"><a href="#1-4-1-time-wait" class="headerlink" title="1.4.1 time-wait"></a>1.4.1 time-wait</h3><p>先前的只能接入一个用户的回声服务器中，服务器可以有两种中止方式：</p>
<ul>
<li>若客户端输入q后，客户端主动发送<strong>FIN</strong>断开服务器，服务器终止。这种情况下，立刻重启服务器，继续绑定上一个端口，服务器能够继续运行。</li>
<li>按ctrl+z强制关闭也会向服务器传递<strong>FIN</strong>。但如果马上在同一端口运行服务器，会出现bind() error消息。这是因为：实际上，主动断开的套接字会经过time-wait过程，而<strong>time-wait</strong>状态会占用端口号。（但无需考虑客户端的，因为客户端套接字端口号是任意指定）</li>
</ul>
<p>为什么要有time-wait状态：</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415224608984.png" alt="image-20230415224608984"></p>
<p>因为如果主机A向B传输ACK消息（<strong>上图红框</strong>）后立即消除套接字，但这条消息丢失了，B会认为自己的FIN消息没达到主机A，试图重传，而主机A已经关闭，B永远无法得到A传来的ACK消息。因此基于，先发送FIN的主机，要经过time-wait状态。</p>
<p>time-wait看似重要，但也会出问题：<br>1、若服务器紧急停止，若需要尽快重启提供服务，需要等待<br>2、Time-wait延长：</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415224946329.png" alt="image-20230415224946329"></p>
<p>解决方式就是设置套接字可选项的SO_REUSEADDR为true：</p>
<h3 id="1-3-1-SO-REUSEADDR-地址再分配"><a href="#1-3-1-SO-REUSEADDR-地址再分配" class="headerlink" title="1.3.1 SO_REUSEADDR 地址再分配"></a>1.3.1 SO_REUSEADDR 地址再分配</h3><p>level： <code>SOL_SOCKET</code></p>
<p>optname：<code>SO_REUSEADDR </code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> option = TRUE;</span><br><span class="line">optlen = <span class="keyword">sizeof</span>(option);</span><br><span class="line">setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, (<span class="type">void</span>*)&amp;option, optlen);</span><br></pre></td></tr></table></figure>

<p>SO_REUSEADDR&#x3D;true时，允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的IP地址即可。也就是说本机服务器如果有多个地址，可以在不同地址上使用相同的端口提供服务。</p>
<p>下图为21端口的socketA在time-wait时，设置SO_REUSEADDR，然后绑定21端口给socketB的所有情况。0.0.0.0表示本机所有地址</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415225250543.png" alt="image-20230415225250543"></p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/14388706/how-do-so-reuseaddr-and-so-reuseport-differ/14388707#14388707">linux - How do SO_REUSEADDR and SO_REUSEPORT differ? - Stack Overflow</a></p>
</blockquote>
<h2 id="1-5-启用Nagle算法：TCP-NODELAY"><a href="#1-5-启用Nagle算法：TCP-NODELAY" class="headerlink" title="1.5 启用Nagle算法：TCP_NODELAY"></a>1.5 启用Nagle算法：TCP_NODELAY</h2><p>level： <code>IPPROTO_TCP</code></p>
<p>optname：<code>TCP_NODELAY</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置禁用/启用Nagle算法，因为默认是启用的，所以opt_val = 0表示启用，1表示禁用。</span></span><br><span class="line">state = setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (<span class="type">void</span> *)&amp;opt_val, <span class="keyword">sizeof</span>(opt_val))</span><br></pre></td></tr></table></figure>

<p>Nagle算法：防止数据包过多导致网络过载，<strong>收到前一个包的ACK，才发送下一个数据。</strong></p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415225429654.png" alt="image-20230415225429654"></p>
<ul>
<li>实际上是控制发送方发送使得缓冲区存到一定程度再发生。若发送方产生数据太慢，这种方式可以让发送方的数据进入缓冲区一部分再发送，不至于一字节一字节发送而数据包泛滥（数据包头）。当然这是一种极端情况。</li>
<li>在发送大文件时，缓冲区也会很快被填满然后发送，不会无端增加数据包数量，不使用Nagle算法会更快。</li>
<li><strong>TCP套接字默认使用Nagle算法</strong>，未判断数据特性时，不应禁用Nagle算法。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>ch3-基于UDP的服务器实现</title>
    <url>/2023/04/a9dd82130ebb/</url>
    <content><![CDATA[<h1 id="一、UDP"><a href="#一、UDP" class="headerlink" title="一、UDP"></a>一、UDP</h1><ul>
<li>UDP不会像TCP那样发送ACK，或者对包进行SEQ排序，可靠性虽然不及TCP，但在性能有时会更好，因为数据损毁的情况并没有想象中那么容易发生。所以在追求性能而非可靠性时UDP是更好的选择。</li>
<li>TCP为了提供可靠性，在不可靠的IP层进行<strong>流控制</strong>；UDP正是缺少流控制机制。这也是区分它们的重要标志。</li>
<li>UDP最重要的作用是根据端口号，将传输到目标主机的数据包交付给最终的UDP套接字。而主机A到主机B的传送由IP层完成。</li>
<li>TCP不存在数据边界：即数据传输过程中调用I&#x2F;O次数不具有任何意义；UDP数据边界：输入函数的调用次数和输出函数调用次数完全一致。</li>
</ul>
<h1 id="二、实现UDP服务器-客户端"><a href="#二、实现UDP服务器-客户端" class="headerlink" title="二、实现UDP服务器&#x2F;客户端"></a>二、实现UDP服务器&#x2F;客户端</h1><p>UDP服务器没有TCP的<code>listen</code>和<code>accept</code>，即没有连接过程，<strong>只有创建socket和数据交换过程。</strong></p>
<p>TCP服务器中套接字应该是一对一，除了监听的那个套接字，若要向10个客户端提供服务，还需要10个套接字。UDP中服务器只需要一个套接字，收发都是通过这个套接字。</p>
<p>某种意义上，无法区分TCP服务器和客户端。</p>
<h2 id="2-1基于UDP的IO函数"><a href="#2-1基于UDP的IO函数" class="headerlink" title="2.1基于UDP的IO函数"></a>2.1基于UDP的IO函数</h2><h3 id="2-1-1-sendto"><a href="#2-1-1-sendto" class="headerlink" title="2.1.1 sendto()"></a>2.1.1 sendto()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sock, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">struct</span> sockaddr *to, <span class="type">socklen_t</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：向目标IP的端口以UDP方式传输数据</li>
<li>参数：<ul>
<li>sock：客户端套接字</li>
<li>buff：待传输数据的缓冲区地址</li>
<li>nbytes：待传输数据的字节数</li>
<li>flags：可选参数，暂未深入，设为0即可</li>
<li>to：目标的sockaddr结构体地址</li>
<li>addrlen：目标的sockaddr结构体的字节长度</li>
</ul>
</li>
<li>返回值：失败返回-1，成功返回发送的字节数</li>
</ul>
<h3 id="2-1-2-recvfrom"><a href="#2-1-2-recvfrom" class="headerlink" title="2.1.2 recvfrom()"></a>2.1.2 recvfrom()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sock, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">struct</span> sockaddr *to, <span class="type">socklen_t</span> *addrlen)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：接收UDP方式传来的数据，并获取发送方地址信息的sockaddr结构体</li>
<li>参数：<ul>
<li>sock：客户端套接字</li>
<li>buff：接收数据的缓冲区地址</li>
<li>nbytes：缓冲区的字节数</li>
<li>flags：可选参数，暂未深入，设为0即可</li>
<li>from：来自发送方的sockaddr结构体（额外存放，并非接收方的sockaddr结构体）</li>
<li>addrlen：存放来自发送方的sockaddr结构体长度的地址</li>
</ul>
</li>
<li>返回值：失败返回-1，成功返回接收的字节数</li>
</ul>
<h2 id="2-2-回声服务器-客户端例程"><a href="#2-2-回声服务器-客户端例程" class="headerlink" title="2.2 回声服务器&#x2F;客户端例程"></a>2.2 回声服务器&#x2F;客户端例程</h2><h3 id="2-2-1-服务器"><a href="#2-2-1-服务器" class="headerlink" title="2.2.1 服务器"></a>2.2.1 服务器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 20</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意是生成UDP的socket</span></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_sock == <span class="number">-1</span>) </span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="comment">// 有bind()</span></span><br><span class="line">    <span class="keyword">if</span>(bind(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    <span class="comment">// 数据交换</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        <span class="comment">// recvfrom</span></span><br><span class="line">        str_len = recvfrom(serv_sock, message, BUF_SIZE, <span class="number">0</span>, </span><br><span class="line">                    (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">        <span class="comment">// sendto</span></span><br><span class="line">        sendto(serv_sock, message, str_len,<span class="number">0</span>,</span><br><span class="line">                    (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, clnt_adr_sz);</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-2-2-客户端"><a href="#2-2-2-客户端" class="headerlink" title="2.2.2 客户端"></a>2.2.2 客户端</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">from_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock == <span class="number">-1</span>) </span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="type">socklen_t</span> from_adr_len;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input message Q to quit: &quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">        fgets(message, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// printf(&quot;%d&quot;, strlen(message));</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(message,<span class="string">&quot;q\n&quot;</span>)||!<span class="built_in">strcmp</span>(message,<span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        sendto(sock, message, <span class="keyword">sizeof</span>(message),<span class="number">0</span>,</span><br><span class="line">                    (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line"></span><br><span class="line">        from_adr_len = <span class="keyword">sizeof</span>(from_adr);</span><br><span class="line">        str_len = recvfrom(sock,message, BUF_SIZE, <span class="number">0</span>,</span><br><span class="line">                    (<span class="keyword">struct</span> sockaddr *)&amp;from_adr, &amp;from_adr_len);</span><br><span class="line">        </span><br><span class="line">        message[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-sendto-中的地址分配与注册"><a href="#2-3-sendto-中的地址分配与注册" class="headerlink" title="2.3 sendto()中的地址分配与注册"></a>2.3 sendto()中的地址分配与注册</h2><h3 id="2-3-1-本机套接字地址分配"><a href="#2-3-1-本机套接字地址分配" class="headerlink" title="2.3.1 本机套接字地址分配"></a>2.3.1 本机套接字地址分配</h3><p>可以看到UDP服务器使用了<code>bind</code>分配<strong>本机</strong>的IP和端口（必须指定，否则客户端无法访问），而<code>bind</code>不区分TCP和UDP。而UDP客户端没有。</p>
<p>在UDP，如果在<code>sendto()</code>时，发现没有分配地址信息，则在首次调用<code>sendto</code>时自动给套接字分配本机IP和端口直到程序结束（自动完成，和TCP客户端的<code>connect()</code>一样）。</p>
<h3 id="2-3-2目标套接字地址注册"><a href="#2-3-2目标套接字地址注册" class="headerlink" title="2.3.2目标套接字地址注册"></a>2.3.2目标套接字地址注册</h3><h4 id="未连接套接字（默认）"><a href="#未连接套接字（默认）" class="headerlink" title="未连接套接字（默认）"></a>未连接套接字（默认）</h4><p>UDP套接字socket无需<strong>注册</strong>目标IP和端口号，也就是一个套接字并不和一个目标地址绑定，每次传输是一个新的socket，因为<code>sendto</code>的内部传输过程为三步</p>
<ol>
<li>向UDP套接字注册目标IP和端口号</li>
<li>传输数据</li>
<li>删除UDP套接字中的目标地址信息</li>
</ol>
<p>每次调用<code>sendto</code>都会重复上述过程，因此可以<strong>只用一个套接字向不同目标传输数据</strong>。这种套接字称为<strong>未连接套接字</strong>。</p>
<h4 id="已连接套接字"><a href="#已连接套接字" class="headerlink" title="已连接套接字"></a>已连接套接字</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* server_addr, <span class="type">socklen_t</span> addrlen)</span></span><br></pre></td></tr></table></figure>

<p>但如果只向一个目标发送数据，每次都重复上述的过程显得低效，所以可以使用<code>connect</code>建立<strong>有连接套接字</strong>。</p>
<blockquote>
<p>注意，这里的有连接并不是指UDP是有连接的，只是针对套接字而言是有连接。</p>
</blockquote>
<p>此时可以用<code>write</code>和<code>read</code>代替<code>sendto</code>和<code>recvfrom</code>。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>ch6-并发服务器实现——多进程服务器端</title>
    <url>/2023/04/90b99e55cdaa/</url>
    <content><![CDATA[<p>几种并发服务器端的实现方式</p>
<ul>
<li><strong>多进程服务器：通过创建多个进程提供服务（本章内容）</strong></li>
<li>多路复用服务器：通过捆绑并统一管理I&#x2F;O对象提供服务</li>
<li>多线程服务器：通过生成与客户端等量的线程提供服务</li>
</ul>
<h1 id="一、多进程前置知识"><a href="#一、多进程前置知识" class="headerlink" title="一、多进程前置知识"></a>一、多进程前置知识</h1><h2 id="1-进程与fork"><a href="#1-进程与fork" class="headerlink" title="1 进程与fork"></a>1 进程与fork</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 成功返回进程ID，失败返回-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> gval = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> lval = <span class="number">20</span>;</span><br><span class="line">    gval++, lval+=<span class="number">5</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        gval+=<span class="number">2</span>, lval+=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        gval-=<span class="number">2</span>, lval-=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child: [gval,lval]=[%d,%d] \n&quot;</span>,gval,lval);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent: [gval,lval]=[%d,%d] \n&quot;</span>,gval,lval);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415231151489.png" alt="image-20230415231151489"></p>
<p>fork后，父进程复制出子进程，父子进程只是共享同一代码，各自拥有完全独立的内存结构。</p>
<h2 id="2-进程和僵尸进程"><a href="#2-进程和僵尸进程" class="headerlink" title="2 进程和僵尸进程"></a>2 进程和僵尸进程</h2><h3 id="2-1-产生僵尸进程的原因"><a href="#2-1-产生僵尸进程的原因" class="headerlink" title="2.1 产生僵尸进程的原因"></a>2.1 产生僵尸进程的原因</h3><blockquote>
<p><strong>子进程终止时，其返回值会返回给OS，该子进程会作为僵尸进程存在，直到返回值被父进程接收为止。</strong></p>
</blockquote>
<p>子进程可以有两种返回方式：<strong>传递参数调用exit()<strong>或</strong>main中执行return并返回值</strong>。</p>
<p>这些值和参数会传递给OS，但OS不会终止子进程，直到这些值被传到这些子进程的父进程。换言之，若父进程未主动要求获得子进程的结束状态，子进程将长期处在僵尸状态。</p>
<h4 id="例程zombie-c"><a href="#例程zombie-c" class="headerlink" title="例程zombie.c"></a>例程zombie.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is child process\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is parent process, chile PID %d\n&quot;</span>,pid);</span><br><span class="line">        sleep(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行后会显示子进程pid，通过<code>ps au | grep pid</code>或<code>ps au</code>可以观察到子进程的僵尸状态。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230416143951444.png" alt="image-20230416143951444"></p>
<h3 id="2-2-销毁僵尸进程"><a href="#2-2-销毁僵尸进程" class="headerlink" title="2.2 销毁僵尸进程"></a>2.2 销毁僵尸进程</h3><h4 id="2-2-1-方式1-wait函数"><a href="#2-2-1-方式1-wait函数" class="headerlink" title="2.2.1 方式1 wait函数"></a>2.2.1 方式1 wait函数</h4><p>注意，调用wait函数时，如果没有已终止的进程，程序会阻塞，直到有，谨慎使用！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statloc)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数：</p>
<ul>
<li><p>statloc：存放状态的地址，要用宏分离信息</p>
<ul>
<li><p><code>WIFEXITED</code>  子进程是否正常终止</p>
</li>
<li><p><code>WEXITSTATUS</code>子进程终止返回值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WIFEXITED(statloc);  </span><br><span class="line"><span class="comment">// 子进程正常终止返回真</span></span><br><span class="line">WEXITSTATUS(statloc);</span><br><span class="line"><span class="comment">// 返回子进程返回值（exit或return的）</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：成功返回子进程pid，失败返回-1</p>
</li>
</ul>
<h5 id="例程wait-c"><a href="#例程wait-c" class="headerlink" title="例程wait.c"></a>例程wait.c</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;this is child process 1&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;child process 1 end&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>); <span class="comment">// 子进程调用exit返回值3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is parent process, chile 1 PID %d\n&quot;</span>,pid);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;this is child process 2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;this is parent process, chile 2 PID %d\n&quot;</span>,pid);</span><br><span class="line">            <span class="type">pid_t</span> returnpid;</span><br><span class="line">            <span class="type">int</span> state;</span><br><span class="line">            returnpid = wait(&amp;state);</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(state))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;the PID %d return value: %d\n&quot;</span>,returnpid ,WEXITSTATUS(state));</span><br><span class="line">            returnpid = wait(&amp;state);</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(state))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;the PID %d return value: %d\n&quot;</span>,returnpid ,WEXITSTATUS(state));  </span><br><span class="line">            sleep(<span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;child process 2 end&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;parent process end&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 子进程2的在main中return返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230416144735514.png" alt="image-20230416144735514"></p>
<h4 id="2-2-2-方式2-waitpid函数"><a href="#2-2-2-方式2-waitpid函数" class="headerlink" title="2.2.2 方式2 waitpid函数"></a>2.2.2 方式2 waitpid函数</h4><p>wait()导致进程阻塞，waitpid()不会阻塞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pit_t</span> pid, <span class="type">int</span>* statloc, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数<ul>
<li>pid：等待终止的目标子进程pid，若为-1，则是任意子进程pid。</li>
<li>statloc：存放状态的地址，要用用宏<code>WIFEXITED(statloc);</code>  和<code>WEXITSTATUS(statloc);</code>分离信息，得知进程是否正常终止以及进程终止返回值</li>
<li>options：传递头文件sys&#x2F;wait.h的<code>WNOHANG</code>，即使没有终止子进程也不会阻塞，而是返回0退出函数。</li>
<li>返回值：成功返回终止的子进程pid，失败-1。options传递<code>WNOHANG</code>时，若没有子进程终止，则返回0。</li>
</ul>
</li>
</ul>
<h5 id="例程waitpid-c"><a href="#例程waitpid-c" class="headerlink" title="例程waitpid.c"></a>例程waitpid.c</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">15</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!waitpid(<span class="number">-1</span>, &amp;status, WNOHANG))</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;sleep 3sec.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child exit with %d \n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每3秒调用一次<code>waitpid</code>查看有没有子进程终止，而子进程运行15s后终止，所以循环了5次<code>waitpid</code>。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230416151109123.png" alt="image-20230416151109123"></p>
<h2 id="3-信号处理"><a href="#3-信号处理" class="headerlink" title="3 信号处理"></a>3 信号处理</h2><p>子进程终止的识别者是操作系统，父进程往往非常繁忙，不能经常调用waitpid等待子进程终止，所以操作系统可以通过<strong>信号</strong>告知父进程，父进程再调用waitpid。</p>
<h3 id="3-1-信号与signal函数"><a href="#3-1-信号与signal函数" class="headerlink" title="3.1 信号与signal函数"></a>3.1 信号与signal函数</h3><h4 id="3-1-1-signal"><a href="#3-1-1-signal" class="headerlink" title="3.1.1 signal"></a>3.1.1 signal</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signo, <span class="type">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>函数名：signal</li>
<li>功能：<strong>信号注册</strong>。即遇到特殊情况signo时（操作系统告知），调用func函数处理，<strong>该signo会被作为参数传入func中</strong>。</li>
<li>参数：<ul>
<li>signo：特殊情况信息<ul>
<li>SIGALRM：已经通过调用<code>alarm</code>函数注册的时间</li>
<li>SIGINT：输入CTRL+C</li>
<li>SIGCHLD：子进程终止</li>
</ul>
</li>
<li>void(* func)(int)：参数为int，返回值为void的函数指针</li>
</ul>
</li>
<li>返回值：参数为int，返回值为void的函数指针。</li>
</ul>
<p>使用方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子进程结束，调用mychild函数</span></span><br><span class="line">signal(SIGCHLD, mychild);</span><br><span class="line"><span class="comment">// 已到alarm函数注册的时间，调用timeout函数</span></span><br><span class="line">signal(SIGALRM, timeout);</span><br><span class="line"><span class="comment">// 输入了CTRL+C，调用keyctrl函数</span></span><br><span class="line">signal(SIGINT, keyctrl);</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-alarm"><a href="#3-1-2-alarm" class="headerlink" title="3.1.2 alarm"></a>3.1.2 alarm</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">unsgigned <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span><br></pre></td></tr></table></figure>
<p>根据参数seconds，相应时间后将产生SIGALRM信号。如果seconds为0，则之前对SIGALRM信号的预约取消。</p>
<blockquote>
<p>若未指定信号处理函数，则（通过调用signal函数）终止进程，无任何处理。</p>
</blockquote>
<h4 id="3-1-3-例程-signal-c"><a href="#3-1-3-例程-signal-c" class="headerlink" title="3.1.3 例程 signal.c"></a>3.1.3 例程 signal.c</h4><ul>
<li>例程<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timeout</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sig == SIGALRM)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;time out!&quot;</span>);</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">keyctrl</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sig == SIGINT)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;ctrl pressed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    signal(SIGALRM,timeout);</span><br><span class="line">    signal(SIGINT,keyctrl);</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wait......&quot;</span>);</span><br><span class="line">        sleep(<span class="number">100</span>); <span class="comment">// 100 sec.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
代码中main里循环了3次，每次100s，但实际上程序的执行大约6秒。</li>
</ul>
<p>这是因为alarm(2)只预约了2秒，2秒到达后信号到达，进入timeout()处理函数。而进程处于睡眠时，是无法调用处理函数的，所以当信号来到，进程会被立马唤醒，不会再进入先前的睡眠状态，程序继续运行（进入下一次睡眠）。若连续ctrl+z，程序会更快结束。</p>
<h3 id="3-2-sigaction函数"><a href="#3-2-sigaction函数" class="headerlink" title="3.2 sigaction函数"></a>3.2 sigaction函数</h3><p>sigaction函数完全可以替代signal，且更稳定。</p>
<blockquote>
<p>signal函数在UNIX系列不同OS可能存在区别，sigaction则完全相同</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signo, <span class="type">const</span> <span class="keyword">struct</span> sigaction *acr, <span class="keyword">struct</span> sigaction* oldact)</span> </span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数</p>
<ul>
<li>signo：传递信号信息</li>
<li>act：根据signo需要调用的<strong>信号处理函数</strong>信息</li>
<li>oldact：获取之前注册的<strong>信号处理函数</strong>信息，不需要则传0</li>
</ul>
</li>
<li><p>成功返回0，失败返回-1</p>
<p>信号处理函数信息都在<code>sigaction</code>结构体中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">    <span class="type">int</span> sa_flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>成员<ul>
<li>sa_handler：信号处理函数指针</li>
<li>sa_mask, sa_flags用于指定信号相关的选项和特性，暂时用不到，置为0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="例程-remove-zombie-c"><a href="#例程-remove-zombie-c" class="headerlink" title="例程 remove_zombie.c"></a>例程 remove_zombie.c</h4><p> 利用信号处理技术消灭僵尸进程（回收子进程），具体流程是，注册子进程结束信号SIGCHLD，子进程结束时调用处理函数read_childproc，该函数内使用waitpid回收子进程。<br> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 处理终止子进程，读取其pid和返回值信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_childproc</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> id = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);</span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;remove proc id: %d\n&quot;</span>, id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child send: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// struct sigaction赋值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = read_childproc; <span class="comment">// 注册信号处理函数信息</span></span><br><span class="line">    sigemptyset(&amp;act.sa_mask); <span class="comment">// sa_mask置为0</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>; <span class="comment">// sa_flags置为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册信号</span></span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;this is child proc&quot;</span>);</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12</span>; <span class="comment">// 返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child proc id: %d\n&quot;</span>,pid);</span><br><span class="line">        pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;this is child proc&quot;</span>);</span><br><span class="line">            sleep(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">24</span>;  <span class="comment">// 返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child proc id: %d\n&quot;</span>,pid);</span><br><span class="line">            <span class="keyword">for</span>(i =<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">                sleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>父进程等待25秒结束，子进程1和2都sleep10秒结束。过程中，子进程结束时，产生SIGCHLD信号，父进程（若在sleep，会立刻唤醒）调用信号处理函数获取子进程结束返回值。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230416171834676.png" alt="image-20230416171834676"></p>
<h1 id="二、多进程服务器端"><a href="#二、多进程服务器端" class="headerlink" title="二、多进程服务器端"></a>二、多进程服务器端</h1><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230417091705079.png" alt="image-20230417091705079" style="zoom:67%;" />

<p>从上图可以看出任务被分离：父进程负责建立与客户端的连接，子进程负责与客户端通信。若同时有5个客户端接入，服务器端一共会有一个父进程和五个子进程处理。</p>
<h2 id="echo-mpserv-c-代码："><a href="#echo-mpserv-c-代码：" class="headerlink" title="echo_mpserv.c 代码："></a>echo_mpserv.c 代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有子进程退出的信号时的调用函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_childproc</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> id = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG); <span class="comment">// waitpid</span></span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;remove proc id: %d\n&quot;</span>, id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child send: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = read_childproc;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_sock == <span class="number">-1</span>) </span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(listen(serv_sock, <span class="number">5</span>)==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        clnt_sock = accept(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">        <span class="keyword">if</span>(clnt_sock==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;new client connected...\n&quot;</span>);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123; <span class="comment">// fork()失败</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;fork() error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">// 子进程进行数据传递</span></span><br><span class="line">        &#123;</span><br><span class="line">            close(serv_sock); <span class="comment">// 子进程后续不需要接入新客户端(不归该子进程管)，关闭serv_socket</span></span><br><span class="line">            <span class="keyword">while</span>((str_len=read(clnt_sock, message, BUF_SIZE))!=<span class="number">0</span>) </span><br><span class="line">                write(clnt_sock, message, str_len);</span><br><span class="line">            close(clnt_sock); <span class="comment">// 只要ste_len=0，说明客户端发送了EOF断开连接</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;client disconnected...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            close(clnt_sock);  <span class="comment">// 父进程不与客户端通信，关闭clnt_socket</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码上可以看出，</p>
<ul>
<li><p>子进程只负责通信，当客户端断开连接，子进程终止。</p>
</li>
<li><p>父进程只负责客户端连接，每当有一个客户端连接完成，fork一个子进程处理，自己继续下一次的连接。</p>
</li>
</ul>
<h2 id="通过fork函数复制文件描述符"><a href="#通过fork函数复制文件描述符" class="headerlink" title="通过fork函数复制文件描述符"></a>通过fork函数复制文件描述符</h2><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230417092935974.png" alt="image-20230417092935974"></p>
<p>fork后，子进程会拥有父进程的所有资源，包括文件描述符。其实子进程与父进程已经是两个不同的进程了，只是这两个进程都拥有相同的指向同一文件的文件描述符，因此如果不使用某个文件描述符，需要及时关闭。</p>
<p><strong>在多进程服务器中，处理数据传输的子进程关闭了<code>serv_sock</code>，处理客户端连接的父进程关闭了<code>clnt_sock</code>（他们都用不上）。</strong>因为复制的是socket文件描述符，一个socket可以有多个文件描述符，当这些文件描述符都终止时，socket才会被销毁。所以若忘记关闭，socket将会一直被占用。</p>
<h1 id="三、多进程客户端：分离TCP的I-O"><a href="#三、多进程客户端：分离TCP的I-O" class="headerlink" title="三、多进程客户端：分离TCP的I&#x2F;O"></a>三、多进程客户端：分离TCP的I&#x2F;O</h1><p>使用两个进程分割回声客户端的I&#x2F;O，优点：</p>
<ul>
<li><p>程序编写更简单，因为一个进程同时实现IO需要考虑更多细节</p>
</li>
<li><p>提高数据交换的效率。</p>
<p>（这里容易产生混淆，实际上回声客户端没有分离IO的必要）</p>
<ul>
<li>分离IO前，客户端的数据流动方式是，在收到上一条的回声后，下一条数据才发送，期待下一条的回声。这很符合回声的定义。</li>
<li>分离IO后，客户端不用等到上一条的回声，就可以发送下一条的数据，<strong>所以可以提高数据交换的效率</strong>。</li>
</ul>
<p>分离IO更适合场景是：不需要收到一方的数据也可以发送，比如聊天室，客户端A发送信息，服务器收到后，将该信息发给客户端BCD，此时客户端BCD若分离了IO，他不需要等到客户端A的信息，也可以发送信息）</p>
</li>
</ul>
<h2 id="echo-mpclient-c-代码"><a href="#echo-mpclient-c-代码" class="headerlink" title="echo_mpclient.c 代码"></a>echo_mpclient.c 代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_sockaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_sockaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_sockaddr));</span><br><span class="line">    serv_sockaddr.sin_family = AF_INET;</span><br><span class="line">    serv_sockaddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_sockaddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">if</span>(connect(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_sockaddr, <span class="keyword">sizeof</span>(serv_sockaddr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">// 父进程写、子进程读</span></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        write_routine(sock, buf);</span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">        read_routine(sock,buf);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> str_len = read(sock, buf, BUF_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(str_len==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        buf[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 从stdin输入流读取一行</span></span><br><span class="line">        fgets(buf, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(buf,<span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            shutdown(sock, SHUT_WR);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(sock, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h2><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230417092435698.png" alt="image-20230417092435698"></p>
<p>运行了 1个多进程回声服务器<code>echo_mpserv </code>和  2个多进程分离IO回声客户端<code>echo_mpclient</code>，进程的数量为7个。</p>
<h1 id="四、进程间通信"><a href="#四、进程间通信" class="headerlink" title="四、进程间通信"></a>四、进程间通信</h1><p>（与构建服务器端暂无关系，仅做拓展，此部分可以忽略）</p>
<p>若想完成进程间通信，OS应当提供两个进程可以同时访问的内存空间，而进程有完全独立的内存空间，fork中的父子进程也是如此，因此需要以特殊的方式通信。</p>
<blockquote>
<p>这让我想到上一节的echo_mpclient，将IO分离成两个进程，只是这两个进程不需要通信，因为他们处理的数据无关；如果是echo_mpserv分离IO，应该是需要的，因为输入进程读取到的数据，要发送给输出进程。</p>
</blockquote>
<h2 id="4-1-管道PIPE"><a href="#4-1-管道PIPE" class="headerlink" title="4.1 管道PIPE"></a>4.1 管道PIPE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> filedes[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数：<ul>
<li>filedes[0]：通过管道<strong>接收</strong>数据的文件描述符，管道<strong>出口</strong></li>
<li>filedes[1]：通过管道<strong>发送</strong>数据的文件描述符，管道<strong>入口</strong></li>
</ul>
</li>
<li>成功返回0，失败返回-1。</li>
</ul>
<p>数据进入管道后会成为<strong>无主数据</strong>，也就是谁都可以读取，所以要注意编写进程读写的逻辑，自己写入后确保其他进程读取完毕，自己进程才有读的机会。有另一种解决方式：创建两个管道。</p>
<blockquote>
<p>管道属于IPC技术：<a href="https://blog.csdn.net/Linuxhus/article/details/125572872">深刻理解 Linux 进程间七大通信（IPC）_linux ipc_Linux服务器开发的博客-CSDN博客</a></p>
</blockquote>
<h3 id="4-1-1-例程-管道的单向通信"><a href="#4-1-1-例程-管道的单向通信" class="headerlink" title="4.1.1 例程 管道的单向通信"></a>4.1.1 例程 管道的单向通信</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;who are you&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    pipe(fds); <span class="comment">// 创建管道</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;this is parent proc.&quot;</span>);</span><br><span class="line">        write(fds[<span class="number">1</span>], str, <span class="keyword">sizeof</span>(str)); <span class="comment">// 父进程往管道入口写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is child proc: %d\n&quot;</span>, pid);</span><br><span class="line">        read(fds[<span class="number">0</span>], buf, BUF_SIZE); <span class="comment">// 子进程往管道出口读</span></span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230417103134796.png" alt="image-20230417103134796"></p>
<h3 id="4-1-2-例程-管道的双向通信"><a href="#4-1-2-例程-管道的双向通信" class="headerlink" title="4.1.2 例程 管道的双向通信"></a>4.1.2 例程 管道的双向通信</h3><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230417103406184.png" alt="image-20230417103406184"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;who are you&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;I&#x27;m Jimmy Mcnulty &quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    pipe(fds);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;this is parent proc.&quot;</span>);</span><br><span class="line">        write(fds[<span class="number">1</span>], str1, <span class="keyword">sizeof</span>(str1));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        若不sleep，由于管道数据是无主数据，</span></span><br><span class="line"><span class="comment">        如果父进程write后比子进程更快read，</span></span><br><span class="line"><span class="comment">        那么子进程会read不到，进而一直阻塞等待管道</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">        sleep(<span class="number">2</span>); </span><br><span class="line">        read(fds[<span class="number">0</span>], buf, BUF_SIZE);</span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is child proc: %d\n&quot;</span>, pid);</span><br><span class="line">        read(fds[<span class="number">0</span>], buf, BUF_SIZE);</span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">        write(fds[<span class="number">1</span>], str2, <span class="keyword">sizeof</span>(str2));</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-保存消息的回升服务器端"><a href="#4-2-保存消息的回升服务器端" class="headerlink" title="4.2 保存消息的回升服务器端"></a>4.2 保存消息的回升服务器端</h2><p>比之前的回升服务器多了个功能：新建一个子进程将来自（一个或多个）回声客户端的数据保存在echmsg.txt中。需要用到管道，因为接收来自客户端数据是由另一个进程完成的且，只用到了单向的管道。</p>
<ul>
<li><input disabled="" type="checkbox"> 问题是负责写文件的子进程无法关闭管道与文件，暂未处理。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_childproc</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> id = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);</span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;remove proc id: %d\n&quot;</span>, id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child send: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = read_childproc;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_sock == <span class="number">-1</span>) </span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(listen(serv_sock, <span class="number">5</span>)==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pipe(fds);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="comment">// 写入文件的子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fds[<span class="number">1</span>]);</span><br><span class="line">        close(serv_sock);</span><br><span class="line">        FILE *fp = fopen(<span class="string">&quot;echmsg.txt&quot;</span>, <span class="string">&quot;wt&quot;</span>);</span><br><span class="line">        <span class="type">char</span> msgbuf[BUF_SIZE];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">// 往文件写入保存来自客户端的数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            len = read(fds[<span class="number">0</span>], msgbuf, BUF_SIZE);</span><br><span class="line">            fwrite((<span class="type">void</span>*)msgbuf, <span class="number">1</span>, len, fp);</span><br><span class="line">            fflush(fp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有bug，因为下面的语句无法运行</span></span><br><span class="line">        close(fds[<span class="number">0</span>]);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        clnt_sock = accept(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">        <span class="keyword">if</span>(clnt_sock==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;new client connected...\n&quot;</span>);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fds[<span class="number">0</span>]);</span><br><span class="line">            close(serv_sock);</span><br><span class="line">            <span class="keyword">while</span>((str_len=read(clnt_sock, message, BUF_SIZE))!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                write(clnt_sock, message, str_len);</span><br><span class="line">                write(fds[<span class="number">1</span>], message, str_len); <span class="comment">// 只多了这一句</span></span><br><span class="line">            &#125;</span><br><span class="line">            close(clnt_sock);</span><br><span class="line">            close(fds[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;client disconnected...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            close(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="comment">// 最后再关闭管道</span></span><br><span class="line">    close(fds[<span class="number">0</span>]);</span><br><span class="line">    close(fds[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>C++</category>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>ch7-并发服务器实现——IO复用服务器端</title>
    <url>/2023/04/1a00876ed5a5/</url>
    <content><![CDATA[<p>几种并发服务器端的实现方式</p>
<ul>
<li>多进程服务器：通过创建多个进程提供服务（创建进程代价极大，且进程间通信提高编程难度）</li>
<li><strong>多路复用服务器：通过捆绑并统一管理I&#x2F;O对象提供服务（本章内容）</strong></li>
<li>多线程服务器：通过生成与客户端等量的线程提供服务</li>
</ul>
<h1 id="一、理解复用技术"><a href="#一、理解复用技术" class="headerlink" title="一、理解复用技术"></a>一、理解复用技术</h1><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230417121700203.png" alt="image-20230417121700203"></p>
<p>相较于多进程服务器端，IO复用服务器端只需要父进程，复用多个IO即可。</p>
<p>简单理解就是：<strong>监听多个套接字文件描述符，当有哪些需要文件描述符发生了事件，如传输数据，处理即可。</strong></p>
<h1 id="二、select"><a href="#二、select" class="headerlink" title="二、select"></a>二、select</h1><p>是IO多路复用的函数，允许程序监控多个文件描述符是否准备好，即不再阻塞可以用于IO了，包括可读可写或发生异常。可以使我们同时等待多个文件缓冲区，减少IO等待时间，</p>
<h2 id="2-1-select流程"><a href="#2-1-select流程" class="headerlink" title="2.1 select流程"></a>2.1 select流程</h2><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230417123505515.png" alt="image-20230417123505515" style="zoom:67%;" />

<h3 id="2-1-1-步骤一：设置文件描述符"><a href="#2-1-1-步骤一：设置文件描述符" class="headerlink" title="2.1.1 步骤一：设置文件描述符"></a>2.1.1 步骤一：设置文件描述符</h3><p>将要监控的文件描述符放到fd_set中。其本质是一个位图，一个位表示一个文件描述符，最多1024位对应1024个文件描述符。对<strong>fd_set</strong>的操作有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD_ZERO(fd_set *fdset); <span class="comment">// 清空fdset</span></span><br><span class="line">FD_SET(<span class="type">int</span> fd,fd_set *fdset); <span class="comment">// 将给定文件描述符加入到fdset中（监控）</span></span><br><span class="line">FD_CLR(<span class="type">int</span> fd,fd_set *fdset); <span class="comment">// 将给定文件描述符从fdset中删除（不再监控）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>; <span class="comment">// 检测fd在fdset中状态是否发生变化</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-步骤一：指定监视范围与超时"><a href="#2-1-2-步骤一：指定监视范围与超时" class="headerlink" title="2.1.2 步骤一：指定监视范围与超时"></a>2.1.2 步骤一：指定监视范围与超时</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;select.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">          	fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数</p>
<ul>
<li><p>nfds：所等待的文件描述符最大值+1，比如进程监控1、3、5，那么nfds&#x3D;5+1。</p>
</li>
<li><p><strong>fd_set</strong>：</p>
<ul>
<li>readfds：等待读事件的文件描述符集合。</li>
<li>writefds：等待写事件的文件描述符集合。</li>
<li>exceptfds：等待异常事件的文件描述符集合。</li>
</ul>
</li>
<li><p>timeout：select在内核中阻塞时间，<strong>设置NULL时非阻塞</strong>。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct timeval time =&#123;5,0&#125; 阻塞5秒</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">long</span>    tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span>    tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值</p>
<ul>
<li>没用文件描述符就绪返回0，调用失败返回-1，&gt;0表示被监控的文件描述符有变化。</li>
</ul>
</li>
</ul>
<h3 id="2-1-3-步骤二、三：调用select函数并查看结果"><a href="#2-1-3-步骤二、三：调用select函数并查看结果" class="headerlink" title="2.1.3 步骤二、三：调用select函数并查看结果"></a>2.1.3 步骤二、三：调用select函数并查看结果</h3><ul>
<li><p>调用select时，进程设置fd_set是让内核等待fs_set文件描述符发送的事件；</p>
</li>
<li><p>调用select后，内核设置fd_set是为了告诉进程哪些应用程序事件生效。</p>
</li>
</ul>
<p>调用后，没有事件发生的文件描述符在fd_set中所有位变为0，发生事件文件描述符对应位为1。</p>
<p><strong>所以<code>fd_set</code>每次调用后都可能变化，如果需要多次调用<code>select</code>监控同一些文件描述符，则每次调用<code>select</code>都要重新设置<code>fd_set</code>。</strong></p>
<h3 id="2-1-4-select例程"><a href="#2-1-4-select例程" class="headerlink" title="2.1.4 select例程"></a>2.1.4 select例程</h3><p>只向fd_set注册一个文件描述符0，即标准输入，只要标准输入有值输入，select就会返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fd_set reads, tmps;</span><br><span class="line">    <span class="type">int</span> result, str_len;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;reads);</span><br><span class="line">    FD_SET(<span class="number">0</span>, &amp;reads); <span class="comment">// 标准输入文件描述符0，注册到fd_set中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmps = reads;</span><br><span class="line">        timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 调用select并阻塞5秒，且每次都要重新设置fd_set</span></span><br><span class="line">        result = select(<span class="number">1</span>, &amp;tmps, <span class="number">0</span>, <span class="number">0</span>, &amp;timeout);</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="number">-1</span>) <span class="comment">// select出错</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;select() error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(result == <span class="number">0</span>) <span class="comment">// 超时，标准输入没有事件发生</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;time-out!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 标准输入有事件发生</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(<span class="number">0</span>, &amp;tmps)) <span class="comment">// 0位置的文件描述符是否有事件发生</span></span><br><span class="line">            &#123;</span><br><span class="line">                str_len = read(<span class="number">0</span>, buf, BUF_SIZE); <span class="comment">// 从标准输入读取</span></span><br><span class="line">                buf[str_len] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;message from console: %s&quot;</span>,buf); <span class="comment">// 打印</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-2-select服务器例程"><a href="#2-2-select服务器例程" class="headerlink" title="2.2 select服务器例程"></a>2.2 select服务器例程</h2><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230410095134055.png" alt="image-20230410095134055"></p>
<h3 id="2-2-1-代码"><a href="#2-2-1-代码" class="headerlink" title="2.2.1 代码"></a>2.2.1 代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> fd_max, fd_num, str_len, i;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;serv_sock: %d&quot;</span>, serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    <span class="comment">// 每次调用select，操作系统都会对fd_set修改，所以要一个cpy_reads作为reads的复制，</span></span><br><span class="line">    <span class="comment">// 而reads只有新增加/删除文件描述符才会被修改</span></span><br><span class="line">    fd_set reads, cpy_reads;</span><br><span class="line">    FD_ZERO(&amp;reads);</span><br><span class="line">    FD_SET(serv_sock, &amp;reads);</span><br><span class="line"></span><br><span class="line">    fd_max = serv_sock; <span class="comment">// 所监控的最大文件描述符（整数）</span></span><br><span class="line">    fd_num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 循环一次后，fd_set可能被修改或更新，若仍要监听这些文件描述符，就要重新赋值。</span></span><br><span class="line">        cpy_reads = reads; </span><br><span class="line">        <span class="comment">// 超时设置</span></span><br><span class="line">        timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 调用select，阻塞5秒</span></span><br><span class="line">        <span class="keyword">if</span> ((fd_num = select(fd_max + <span class="number">1</span>, &amp;cpy_reads, <span class="number">0</span>, <span class="number">0</span>, &amp;timeout)) == <span class="number">-1</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 没有文件描述符发生事件</span></span><br><span class="line">        <span class="keyword">if</span> (fd_num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 有文件描述符发生事件</span></span><br><span class="line">        <span class="comment">// 循环所有注册的文件描述符</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fd_max + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 找到发生事件的文件描述符</span></span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(i, &amp;cpy_reads))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 若是serv_sock发生事件，表明有新客户端接入</span></span><br><span class="line">                <span class="keyword">if</span> (i == serv_sock)</span><br><span class="line">                &#123;</span><br><span class="line">                    clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">                    clnt_sock = accept(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">                    <span class="comment">// 新客户端套接字注册到fd_set中，fd_max是所监控的最大的文件描述符+1</span></span><br><span class="line">                    FD_SET(clnt_sock, &amp;reads);</span><br><span class="line">                    <span class="keyword">if</span> (fd_max &lt; clnt_sock)</span><br><span class="line">                        fd_max = clnt_sock;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;new client %d connected...\n&quot;</span>, clnt_sock);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 若不是serv_sock，表明有客户端想写东西</span></span><br><span class="line">                &#123;</span><br><span class="line">                    str_len = read(i, buf, BUF_SIZE);</span><br><span class="line">                    <span class="keyword">if</span> (str_len == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        FD_CLR(i, &amp;reads);</span><br><span class="line">                        close(i);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client %d disconnected...\n&quot;</span>, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        write(i, buf, str_len);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-3-select优缺点"><a href="#2-3-select优缺点" class="headerlink" title="2.3 select优缺点"></a>2.3 select优缺点</h2><ul>
<li><p>每次调用select都要向函数传递监控对象的信息。</p>
</li>
<li><p>每次调用select函数后，需要循环所有文件描述符找到所监控的对象。</p>
</li>
<li><p>大部分OS都支持select，在服务器端接入者少时也适用。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>ch8-组播和多播</title>
    <url>/2023/04/d77ff84152ed/</url>
    <content><![CDATA[<h1 id="0、只有UDP才有多播-组播和广播"><a href="#0、只有UDP才有多播-组播和广播" class="headerlink" title="0、只有UDP才有多播&#x2F;组播和广播"></a>0、只有UDP才有多播&#x2F;组播和广播</h1><h1 id="1-组播-多播（multicast）"><a href="#1-组播-多播（multicast）" class="headerlink" title="1 组播&#x2F;多播（multicast）"></a>1 组播&#x2F;多播（multicast）</h1><ul>
<li><p>多播服务器只发送一次数据，加入了多播组的所有客户端都能接收到，<strong>即便客户端跨越不同网络</strong>。</p>
</li>
<li><p>多播组是D类ip地址：224:0.0.0 ~ 239.255.255.255</p>
<blockquote>
<p>一个问题：<br><a href="https://www.zhihu.com/question/287731623">加入同一个组播的用户的IP地址需要是同网段吗？ - 知乎</a><br>三层组播是指基于IP层协议（即网络层）的组播通信方式。在IP层，使用特定的组播地址范围（224.0.0.0 ~ 239.255.255.255）来进行组播通信，其中224.0.0.0 ~ 224.0.0.255是预留的本地网络控制组播地址，用于局域网内的组播控制消息，其余地址则用于全球范围内的组播通信。在三层组播中，路由器负责组播数据包的转发和复制。当一个主机要发送一个组播数据包时，它会将数据包发送到一个组播IP地址，这个地址是由多个主机共享的。当路由器接收到一个组播数据包时，它会将该数据包复制到所有与该组播地址相关的子网上，并继续向下一级路由器转发。这样，组播数据包就可以被分发到所有加入该组播地址的主机上。三层组播的优点是可以实现跨越不同的网络，从而实现全球范围内的组播通信。同时，由于只有需要接收组播数据的主机才会加入组播，所以可以有效地减少网络带宽的占用。但同时，三层组播也需要依赖复杂的路由协议和设备配置，因此对网络设备和管理的要求也比较高。</p>
</blockquote>
</li>
<li><p>多播由路由器完成，即路由器复制数据包发送，但不少路由器不支持，即便支持也因为网络拥塞故意切断多播</p>
</li>
</ul>
<h2 id="1-1-TTL（发送方考虑）"><a href="#1-1-TTL（发送方考虑）" class="headerlink" title="1.1 TTL（发送方考虑）"></a>1.1 TTL（发送方考虑）</h2><p>组播必须设置TTL（Time to Live），每经过一个路由器，TTL–；当TTL&#x3D;&#x3D;0，数据包被销毁；TTL过大，网络拥塞严重；TTL过小，无法传达到目标。</p>
<p>TTL设置方式：setsockopt() </p>
<ul>
<li><p>level： <code>IPPROTO_IP</code></p>
</li>
<li><p>optname： <code>IP_MULTICAST_TTL</code></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setsockopt()设置TTL，</span></span><br><span class="line"><span class="type">int</span> send_sock;</span><br><span class="line"><span class="type">int</span> TTL = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">send_sock=socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">setsockopt(send_sock, IPPROTO_IP, IP_MULTICAST_TTL, (<span class="type">void</span> *) &amp;TTL, <span class="keyword">sizeof</span>(TTL));</span><br></pre></td></tr></table></figure>

<h2 id="1-2-加入组（接收方考虑）"><a href="#1-2-加入组（接收方考虑）" class="headerlink" title="1.2 加入组（接收方考虑）"></a>1.2 加入组（接收方考虑）</h2><p>哪个IP的主机，加入哪个组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ip_mreq结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span> <span class="comment">// 加入的组的IP地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span> <span class="comment">// 加入该组的主机IP地址 可以用INADDR_ANY</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>level： <code>IPPROTO_IP</code></p>
</li>
<li><p>optname： <code>IP_ADD_MEMBERSHIP</code></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setsockopt()设置加入组信息</span></span><br><span class="line"><span class="comment">// 在IPPROTO_IP层 的 IP_ADD_MEMBERSHIP选项</span></span><br><span class="line"><span class="type">int</span> recv_sock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">join_adr</span>;</span></span><br><span class="line"></span><br><span class="line">recv_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">join_adr.imr_multiaddr.s_addr = <span class="string">&quot;多播组地址信息&quot;</span>;</span><br><span class="line">join_adr.imr_interface.s_addr = <span class="string">&quot;加入多播组的主机地址信息&quot;</span></span><br><span class="line"></span><br><span class="line">setsockopt(recv_sock, IPPROTO_IP, </span><br><span class="line">    IP_ADD_MEMBERSHIP, (<span class="type">void</span> *)join_adr, <span class="keyword">sizeof</span>(join_adr))</span><br></pre></td></tr></table></figure>
<h2 id="1-3-例程：多播"><a href="#1-3-例程：多播" class="headerlink" title="1.3 例程：多播"></a>1.3 例程：多播</h2><p>news_sender以多播形式发送news.txt的内容到目标多播组；<br>news_receiver加入多播组，接收news.txt内容</p>
<h3 id="1-3-1-news-sender-c"><a href="#1-3-1-news-sender-c" class="headerlink" title="1.3.1 news_sender.c"></a>1.3.1 news_sender.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTL 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;GroupIP&gt; &lt;PORT&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="comment">// 创建socket，设置TTL</span></span><br><span class="line">    <span class="type">int</span> time_live = TTL;</span><br><span class="line">    <span class="type">int</span> send_sock;</span><br><span class="line">    send_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    setsockopt(send_sock, IPPROTO_IP, IP_MULTICAST_TTL, (<span class="type">void</span> *)&amp;time_live, <span class="keyword">sizeof</span>(time_live));</span><br><span class="line">    <span class="comment">// 创建sockaddr结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">mul_adr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;mul_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(mul_adr));</span><br><span class="line">    mul_adr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 向哪个多播地址发送</span></span><br><span class="line">    mul_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    mul_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">// 发送的内容在文件中</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;news.txt&quot;</span>, <span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;fopen() error&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 数据发送</span></span><br><span class="line">    <span class="keyword">while</span>(!feof(fp))</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf, BUF_SIZE, fp);</span><br><span class="line">        sendto(send_sock, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*) &amp;mul_adr, <span class="keyword">sizeof</span>(mul_adr));</span><br><span class="line">        sleep(<span class="number">2</span>); <span class="comment">// 每两秒发一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(send_sock);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-news-receiver-c"><a href="#1-3-2-news-receiver-c" class="headerlink" title="1.3.2 news_receiver.c"></a>1.3.2 news_receiver.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;GroupIP&gt; &lt;PORT&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// sockaddr地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">recv_adr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;recv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_adr));</span><br><span class="line">    recv_adr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 加入的组</span></span><br><span class="line">    recv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    recv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="type">int</span> recv_sock;</span><br><span class="line">    recv_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 加入组信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">join_adr</span>;</span></span><br><span class="line">    join_adr.imr_multiaddr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    join_adr.imr_interface.s_addr=htonl(INADDR_ANY);</span><br><span class="line">    setsockopt(recv_sock, IPPROTO_IP,</span><br><span class="line">        IP_ADD_MEMBERSHIP, (<span class="type">void</span> *)&amp;join_adr, <span class="keyword">sizeof</span>(join_adr));</span><br><span class="line">    <span class="keyword">if</span>(bind(recv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;recv_adr, <span class="keyword">sizeof</span>(recv_adr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    <span class="comment">// 数据接收</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str_len = recvfrom(recv_sock, buf, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(str_len&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        buf[str_len]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fputs</span>(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(recv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-3-运行结果："><a href="#1-3-3-运行结果：" class="headerlink" title="1.3.3 运行结果："></a>1.3.3 运行结果：</h3><p>在服务器上运行两段代码，接收方和放送方启动顺序不重要，都能正常接受信息（接收方比发送方晚启动，收到信息会确实）。</p>
<p>服务器地址信息<code>inet 172.31.226.233  netmask 255.255.255.0</code><br>然后想在不同网段的一台另一台电脑上的虚拟机上接收服务器发来的组播地址。虚拟机地址<code>inet addr:172.30.98.110   Mask:255.255.255.0</code><br>但虚拟机无法接收到数据包。<br>可能原因是网络配置、路由器设置、网络拓扑等方面的问题，暂时没有深入探究。</p>
<h1 id="2-广播（boardcast）"><a href="#2-广播（boardcast）" class="headerlink" title="2 广播（boardcast）"></a>2 广播（boardcast）</h1><p>广播和多播类似，也是一次性向多个主机发送数据。<strong>不同的是，多播中的主机可以不属于同一网段，广播只能向同一网络的主机传输数据。</strong></p>
<p><strong>两种广播方式的ip地址设置：</strong></p>
<ul>
<li>直接广播：除网络地址外，主机地址全1，如<code>inet 172.31.226.233  netmask 255.255.255.0</code>，网络地址<code>172.31.226.0</code>，那么广播地址为<code>172.31.226.255</code>。</li>
<li>本地广播：<code>255.255.255.255</code></li>
</ul>
<h2 id="2-1-广播实现"><a href="#2-1-广播实现" class="headerlink" title="2.1 广播实现"></a>2.1 广播实现</h2><p>setsockopt()设置套接字可选项</p>
<ul>
<li><p>level： <code>SOL_SOCKET</code></p>
</li>
<li><p>optname： <code>SO_BROADCAST</code></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> send_sock;</span><br><span class="line"><span class="type">int</span> bcast;</span><br><span class="line">send_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">setsockopt(sendsock, SOL_SOCKET, SO_BROADCAST, (<span class="type">void</span>*)&amp;bcast, <span class="keyword">sizeof</span>(bcast));</span><br></pre></td></tr></table></figure>

<h2 id="2-2-例程"><a href="#2-2-例程" class="headerlink" title="2.2 例程"></a>2.2 例程</h2><p>注意事项</p>
<ul>
<li>sender需要绑定目标广播地址</li>
<li>receiver的sockadd信息绑定端口号和<code>INADDR_ANY</code>即可</li>
</ul>
<h3 id="2-2-1-news-receiver-board-c"><a href="#2-2-1-news-receiver-board-c" class="headerlink" title="2.2.1 news_receiver_board.c"></a>2.2.1 news_receiver_board.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;PORT&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// sockaddr结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">recv_adr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;recv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_adr));</span><br><span class="line">    recv_adr.sin_family = AF_INET;</span><br><span class="line">    recv_adr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">// INADDR_ANY</span></span><br><span class="line">    recv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="comment">// socket</span></span><br><span class="line">    <span class="type">int</span> recv_sock;</span><br><span class="line">    recv_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(bind(recv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;recv_adr, <span class="keyword">sizeof</span>(recv_adr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 数据传输</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str_len = recvfrom(recv_sock, buf, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(str_len&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        buf[str_len]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fputs</span>(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(recv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-news-sender-board-c"><a href="#2-2-2-news-sender-board-c" class="headerlink" title="2.2.2 news_sender_board.c"></a>2.2.2 news_sender_board.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;BroadcastIP&gt; &lt;PORT&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> so_brd = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 目标广播地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">brd_adr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;brd_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(brd_adr));</span><br><span class="line">    brd_adr.sin_family = AF_INET;</span><br><span class="line">    brd_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    brd_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">// socket，并设置SO_BROADCAST</span></span><br><span class="line">    <span class="type">int</span> send_sock;</span><br><span class="line">    send_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    setsockopt(send_sock, SOL_SOCKET, SO_BROADCAST, (<span class="type">void</span> *)&amp;so_brd, <span class="keyword">sizeof</span>(so_brd));</span><br><span class="line">    <span class="comment">// 数据传输</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;news.txt&quot;</span>, <span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;fopen() error&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(!feof(fp))</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf, BUF_SIZE, fp);</span><br><span class="line">        sendto(send_sock, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>,</span><br><span class="line">            (<span class="keyword">struct</span> sockaddr*) &amp;brd_adr, <span class="keyword">sizeof</span>(brd_adr));</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(send_sock);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-结果"><a href="#2-2-3-结果" class="headerlink" title="2.2.3 结果"></a>2.2.3 结果</h3><p>在服务器上运行两段代码，能正常接受信息。服务器地址信息<code>inet 172.31.226.233  netmask 255.255.255.0</code><br>然后想在不同网段的一台虚拟机上接收服务器发来的广播地址。虚拟机地址<code>inet addr:172.30.98.110 Mask:255.255.255.0</code><br>服务器：<code>./news_sender_board 172.30.98.255 8100</code><br>虚拟机：<code>./news_receiver_board 8100</code><br>和多播一样，无法收到数据。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>ch9-套接字和标准IO</title>
    <url>/2023/04/0bf8af506985/</url>
    <content><![CDATA[<p>2023&#x2F;2&#x2F;27（忽略了二进制文件读写，暂时没用用的必要）</p>
<blockquote>
<p><a href="https://blog.csdn.net/m0_65190367/article/details/126682477">https://blog.csdn.net/m0_65190367/article/details/126682477</a></p>
</blockquote>
<h1 id="一、C语言标准库函数I-O"><a href="#一、C语言标准库函数I-O" class="headerlink" title="一、C语言标准库函数I&#x2F;O"></a>一、C语言标准库函数I&#x2F;O</h1><h2 id="1-1-FILE结构体"><a href="#1-1-FILE结构体" class="headerlink" title="1.1 FILE结构体"></a>1.1 FILE结构体</h2><p>定义在了stdio.h中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *_ptr;          <span class="comment">//缓冲区当前指针</span></span><br><span class="line">    <span class="type">int</span>   _cnt;</span><br><span class="line">    <span class="type">char</span> *_base;         <span class="comment">//缓冲区基址</span></span><br><span class="line">    <span class="type">int</span>   _flag;         <span class="comment">//文件读写模式</span></span><br><span class="line">    <span class="type">int</span>   _file;         <span class="comment">//文件描述符</span></span><br><span class="line">    <span class="type">int</span>   _charbuf;      <span class="comment">//缓冲区剩余自己个数</span></span><br><span class="line">    <span class="type">int</span>   _bufsiz;       <span class="comment">//缓冲区大小</span></span><br><span class="line">    <span class="type">char</span> *_tmpfname;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> <span class="title">FILE</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-1文件打开与关闭"><a href="#1-1文件打开与关闭" class="headerlink" title="1.1文件打开与关闭"></a>1.1文件打开与关闭</h2><p><strong>fwrite() 函数一般并不直接将数据写入，而是暂存在缓冲里，等到时机合适时，缓冲里的数据才会被真正写入。调用 fclose() 函数能够确保缓冲里的数据真正写入。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件开启</span></span><br><span class="line">FILE* fp = <span class="built_in">fopen</span>(<span class="type">const</span> <span class="type">char</span> *file_name, <span class="type">const</span> <span class="type">char</span>* mode);</span><br><span class="line"><span class="comment">// 文件关闭，若成功，返回0；若失败，返回定义在头文件stdio.h的常量EOF</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fclose</span><span class="params">(FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230421093447504.png" alt="image-20230421093447504"></p>
<h2 id="1-2-文件的顺序读写"><a href="#1-2-文件的顺序读写" class="headerlink" title="1.2 文件的顺序读写"></a>1.2 文件的顺序读写</h2><p><strong>fp是个文件指针，读到哪写到哪，指针就走到哪，文件长啥样，读出来就长啥样。所以如果在用fp写入文件后，如果不修改fp开始读，读出的是空内容。</strong><br>fgets 如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。如果发生错误，返回一个空指针。<br><img src="en-resource:/database/635:1" alt="47fc4fd2a722e3c69aecba4205698d2c.png"></p>
<h4 id="1-2-1-fgetc-fputc-fgets-fputs"><a href="#1-2-1-fgetc-fputc-fgets-fputs" class="headerlink" title="1.2.1 fgetc fputc fgets fputs"></a>1.2.1 fgetc fputc fgets fputs</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">strerror</span>(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">fputc</span>(<span class="string">&#x27;c&#x27;</span>,fp);</span><br><span class="line">	<span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>,fp);</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">&quot;chenjie&quot;</span>,fp);</span><br><span class="line">	<span class="built_in">fclose</span>(fp); <span class="comment">// 关闭文件才能正确写入 </span></span><br><span class="line">	</span><br><span class="line"><span class="comment">/* 此时test.txt文件内容: </span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">chenjie </span></span><br><span class="line"><span class="comment">*/</span>	</span><br><span class="line">	<span class="comment">// 重新打开文件 </span></span><br><span class="line">	fp = <span class="built_in">fopen</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> ch = <span class="built_in">fgetc</span>(fp); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,ch);<span class="comment">// 输出一个字符c</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buff[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">fgets</span>(buff,<span class="number">7</span>,fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buff); <span class="comment">// 输出\n,因为流指向\n,而\n后同一行没内容 </span></span><br><span class="line">	</span><br><span class="line">	ch = <span class="built_in">fgetc</span>(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,ch);  <span class="comment">// 输出c </span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">fgets</span>(buff,<span class="number">6</span>,fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buff); <span class="comment">// 输出henji(和上面的c同一行) </span></span><br><span class="line">	<span class="comment">// 显然henji只有5个字符,fgets里定义了6的长度,个人猜测是因为c风格字符串需要以&#x27;\0&#x27; 结尾 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-fscanf-fprintf"><a href="#1-2-2-fscanf-fprintf" class="headerlink" title="1.2.2 fscanf fprintf"></a>1.2.2 fscanf fprintf</h4><p>fscanf似乎只能够识别类似<code>&quot;%s %d&quot;</code>的格式, 而无法识别<code>&quot;%s-%d&quot;</code>等非空格外的格式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">S</span>&#123;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125; People;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">strerror</span>(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">// 格式化输出 </span></span><br><span class="line">	People me = &#123;<span class="string">&quot;chenjie&quot;</span>,<span class="number">18</span>&#125;;</span><br><span class="line">	<span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s %d\n&quot;</span>,me.name,me.age); </span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">	<span class="comment">// 文件内容:一行chenjie 18\n </span></span><br><span class="line">	</span><br><span class="line">	fp = <span class="built_in">fopen</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">512</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">fgets</span>(buff,<span class="number">20</span>,fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buff);</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 格式化输入 </span></span><br><span class="line">	People new_me=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	fp = <span class="built_in">fopen</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="comment">// 扫描到chenjie和18符合格式给new_me </span></span><br><span class="line">	<span class="comment">// 注意的是,似乎只有空格才能格式化,如果是-</span></span><br><span class="line">	<span class="comment">//  chenjie-18会被认为一整个字符串,而没有18 </span></span><br><span class="line">	<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s %d&quot;</span>,new_me.name,&amp;new_me.age); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s-%d\n&quot;</span>,new_me.name,new_me.age); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 把最后的\n也打印 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">fgetc</span>(fp));</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-3-需要和sscanf-和sprinf-区分"><a href="#1-2-3-需要和sscanf-和sprinf-区分" class="headerlink" title="1.2.3 需要和sscanf()和sprinf()区分"></a>1.2.3 需要和sscanf()和sprinf()区分</h4><p>实际上功能类似，只是作用对象不同了，f开头是对文件流操作， s开头是对字符串操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buffer1[] = &#123; <span class="string">&quot;zhansan 19&quot;</span> &#125;;</span><br><span class="line">Peo p = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sscanf</span>(buffer1, <span class="string">&quot;%s %d&quot;</span>, p.name, &amp;p.age);  <span class="comment">// 字符串转为格式化数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer2[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(buffer2, <span class="string">&quot;%s %d\n&quot;</span>, p.name, p.age); <span class="comment">// 格式化数据被转为字符串</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-文件的随机读写"><a href="#1-3-文件的随机读写" class="headerlink" title="1.3 文件的随机读写"></a>1.3 文件的随机读写</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从定位的位置偏移量处读写，成功返回0</span></span><br><span class="line"><span class="comment">// 当读写完后，stream会向后移动一位（不论偏移量正负，都会++）</span></span><br><span class="line"><span class="comment">// 当超出时</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fseek</span><span class="params">( FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> origin )</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>; <span class="comment">// 距离SEEK_SET偏移量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span> <span class="comment">//文件指针回到SEEK_SET</span></span></span><br></pre></td></tr></table></figure>
<p>起始位置的定位指针：</p>
<ul>
<li>SEEK_SET：指向文件第一个字符</li>
<li>SEEK_CUR：指向当前的位置</li>
<li>SEEK_END：指向文件末尾EOF</li>
</ul>
<h4 id="1-3-1各种函数使用方式"><a href="#1-3-1各种函数使用方式" class="headerlink" title="1.3.1各种函数使用方式"></a>1.3.1各种函数使用方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">/* 文件内容</span></span><br><span class="line"><span class="comment">        name: chenjie\n</span></span><br><span class="line"><span class="comment">        age: 18[EOF]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">fseek</span>(fp,<span class="number">1</span>,SEEK_SET);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,<span class="built_in">fgetc</span>(fp)); <span class="comment">// a</span></span><br><span class="line">	<span class="built_in">fseek</span>(fp,<span class="number">4</span>,SEEK_CUR);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,<span class="built_in">fgetc</span>(fp)); <span class="comment">// c </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;距离SEEK_SET偏移量：%d\n&quot;</span>,<span class="built_in">ftell</span>(fp)); <span class="comment">// 7</span></span><br><span class="line">	<span class="built_in">fseek</span>(fp,<span class="number">8</span>,SEEK_CUR);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,<span class="built_in">fgetc</span>(fp)); <span class="comment">// a</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fseek</span>(fp,<span class="number">-2</span>,SEEK_END);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,<span class="built_in">fgetc</span>(fp)); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">fseek</span>(fp,<span class="number">-3</span>,SEEK_CUR);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,<span class="built_in">fgetc</span>(fp));<span class="comment">// :</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-2-测试fseek越界后的结果"><a href="#1-3-2-测试fseek越界后的结果" class="headerlink" title="1.3.2 测试fseek越界后的结果"></a>1.3.2 测试fseek越界后的结果</h4><p>如果偏移量左偏移越界，SEEK_CUR将指向SEEK_END</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">/* 文件内容</span></span><br><span class="line"><span class="comment">        name: chenjie\n</span></span><br><span class="line"><span class="comment">        age: 18[EOF]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">fseek</span>(fp,<span class="number">1</span>,SEEK_SET);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,<span class="built_in">fgetc</span>(fp)); <span class="comment">// a</span></span><br><span class="line">	<span class="built_in">fseek</span>(fp,<span class="number">-7</span>,SEEK_CUR); <span class="comment">// 越界</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,<span class="built_in">fgetc</span>(fp)); <span class="comment">// EOF</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;距离起始位置偏移量：%d\n&quot;</span>,<span class="built_in">ftell</span>(fp));</span><br><span class="line">    <span class="built_in">fseek</span>(fp,<span class="number">-1</span>,SEEK_CUR);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,<span class="built_in">fgetc</span>(fp)); <span class="comment">// 8</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-文件结束判定-feof-fp"><a href="#1-4-文件结束判定-feof-fp" class="headerlink" title="1.4 文件结束判定 feof(fp)"></a>1.4 文件结束判定 feof(fp)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE* pf = <span class="built_in">fopen</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;fopen is failed !&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	char c[100] = &#123;0&#125;;</span></span><br><span class="line"><span class="comment">	// 读完或失败、fgets都会返回空指针 </span></span><br><span class="line"><span class="comment">	while (fgets(c,100,pf)!=NULL)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		printf(&quot;%s&quot;,c);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span>	</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">	c = <span class="built_in">fgetc</span>(pf);</span><br><span class="line">	<span class="keyword">while</span> (c != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">putchar</span>(c);</span><br><span class="line">		c = <span class="built_in">fgetc</span>(pf); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//直到while不执行了—读取结束了—判断是什么原因结束的</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ferror</span>(pf))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;读取中出现错误\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">feof</span>(pf))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;读取到文件尾\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">fclose</span>(pf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、Linux系统的文件读写"><a href="#二、Linux系统的文件读写" class="headerlink" title="二、Linux系统的文件读写"></a>二、Linux系统的文件读写</h1><p>Linux中所有内容都是以文件的形式保存和管理的，比如文件本身、设备、套接字。每一个文件都有一个独一无二的文件描述符，对于标准输入输出也是。<br><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230421093515743.png" alt="image-20230421093515743"></p>
<h3 id="2-1-1打开文件"><a href="#2-1-1打开文件" class="headerlink" title="2.1.1打开文件"></a>2.1.1打开文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcnt1.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：打开文件，获取文件描述符</li>
<li>返回值：成功时返回文件描述符，失败返回-1</li>
<li>参数：<blockquote>
<p>path: 文件路径&#x2F;名的字符串地址<br>flag：文件的打开模式，多条模式可用or分开<br><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230421093525332.png" alt="image-20230421093525332"></p>
</blockquote>
</li>
</ul>
<h3 id="2-1-2关闭文件"><a href="#2-1-2关闭文件" class="headerlink" title="2.1.2关闭文件"></a>2.1.2关闭文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：关闭文件</li>
<li>返回值：成功时返回0，失败返回-1</li>
<li>参数：<blockquote>
<p>fd: 文件描述符参数</p>
</blockquote>
</li>
</ul>
<h3 id="2-1-3-写入文件"><a href="#2-1-3-写入文件" class="headerlink" title="2.1.3 写入文件"></a>2.1.3 写入文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：往文件描述符fd所指示文件写入大小为nbytes的buf数据</li>
<li>返回值：成功时返回<strong>写入字节数</strong>，失败返回-1</li>
<li>参数：<blockquote>
<p>fd：数据传输对象的文件描述符<br>buf：要传输数据的缓冲区地址<br>nbytes：要传输的字节大小</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>ssize_t表示signed size_t类型，size_t和ssize_t都在sys&#x2F;types.h由typedef定义，属于元数据类型，和基本数据类型不同。因为当操作系统位数不同时，只需要改变typedef就能适应。为了与程序员自己定义的数据类型区分，一般后缀加_t</p>
</blockquote>
<h3 id="2-1-4-读取文件"><a href="#2-1-4-读取文件" class="headerlink" title="2.1.4 读取文件"></a>2.1.4 读取文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> nbytes)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：读取文件描述符fd所指示文件，将内容写入最大为nbytes的buf数据</li>
<li>返回值：成功时返回<strong>读入字节数</strong>（但遇到文件结尾返回0），失败返回-1</li>
<li>参数：<blockquote>
<p>fd：数据传输对象的文件描述符<br>buf：要传输数据的缓冲区地址<br>nbytes：接收数据缓冲区最大字节数</p>
</blockquote>
</li>
</ul>
<h2 id="2-2-linux下读写文件demo"><a href="#2-2-linux下读写文件demo" class="headerlink" title="2.2 linux下读写文件demo"></a>2.2 linux下读写文件demo</h2><h3 id="2-2-1-写入文件"><a href="#2-2-1-写入文件" class="headerlink" title="2.2.1 写入文件"></a>2.2.1 写入文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span>* message)</span>; <span class="comment">// 处理错误</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> fd;</span><br><span class="line">        <span class="type">char</span> buf[] = <span class="string">&quot;write something\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        fd = open(<span class="string">&quot;data.txt&quot;</span>, O_CREAT| O_WRONLY| O_TRUNC);</span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">                error_handling(<span class="string">&quot;open() error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file descriptor: %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(write(fd, buf, <span class="keyword">sizeof</span>(buf))==<span class="number">-1</span>)</span><br><span class="line">                error_handling(<span class="string">&quot;write() error\n&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-读取文件"><a href="#2-2-2-读取文件" class="headerlink" title="2.2.2 读取文件"></a>2.2.2 读取文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> fd;</span><br><span class="line">        <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">        fd = open(<span class="string">&quot;data.txt&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">                error_handling(<span class="string">&quot;open() error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file desctiptor: %d \n&quot;</span>, fd);</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> read_rt = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read return: %d\n&quot;</span>, read_rt);          </span><br><span class="line">        <span class="keyword">if</span>(read_rt==<span class="number">-1</span>)</span><br><span class="line">                error_handling(<span class="string">&quot;read() error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file data: %s\n&quot;</span>, buf);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="三、标准I-O与系统I-O的关系"><a href="#三、标准I-O与系统I-O的关系" class="headerlink" title="三、标准I&#x2F;O与系统I&#x2F;O的关系"></a>三、标准I&#x2F;O与系统I&#x2F;O的关系</h1><h2 id="15-1-标注I-O函数优缺点"><a href="#15-1-标注I-O函数优缺点" class="headerlink" title="15.1 标注I&#x2F;O函数优缺点"></a>15.1 标注I&#x2F;O函数优缺点</h2><p>以下内容来自《TCP&#x2F;IP网络编程》第15章节</p>
<p>标准I&#x2F;O两大优点</p>
<ul>
<li>良好移植性（标准函数都有具备的特性）</li>
<li>可利用<strong>缓冲</strong>提高性能</li>
</ul>
<p><strong>创建socket，操作系统会生成用于I&#x2F;O的缓冲，为实现TCP&#x2F;IP协议设立：如果有数据包传输失败，数据包还在缓冲中用于重传</strong></p>
<p><strong>而使用标准I&#x2F;O所得到的是<code>额外</code>的缓冲支持，用于提高性能（可在FILE结构体中看到缓冲）：数据存到一定程度，再被使用&#x2F;传输</strong></p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230421092740191.png" alt="image-20230421092740191" style="zoom:50%;" />

<p>性能的提高体现两个方面</p>
<ul>
<li>传输数据量：没有I&#x2F;O缓冲时，发送10次1字节的数据，数据不经过IO函数输出缓冲，直接进入套接字输出缓冲，每字节都会被包装成一个数据包，头部数据是冗余。</li>
<li>数据向套接字输出缓冲移动次数。1字节数据移动10次花费时间是10字节移动1次的10倍。</li>
</ul>
<p>标准I&#x2F;O缺点</p>
<ul>
<li>不容易双向通信</li>
<li>可能频繁调用fflush函数</li>
<li>套接字默认返回文件描述符，需要转化为FILE结构体指针</li>
</ul>
<h3 id="例程-标准I-O函数和系统函数性能对比"><a href="#例程-标准I-O函数和系统函数性能对比" class="headerlink" title="例程 标准I&#x2F;O函数和系统函数性能对比"></a>例程 标准I&#x2F;O函数和系统函数性能对比</h3><p>两个例程分别使用标准I&#x2F;O函数和系统函数对一个大文件（大于300MB）进行拷贝</p>
<h4 id="syscmp-c"><a href="#syscmp-c" class="headerlink" title="syscmp.c"></a>syscmp.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd1, fd2; <span class="comment">// 文件描述符！</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    fd1 = open(<span class="string">&quot;news.txt&quot;</span>, O_RDONLY); </span><br><span class="line">    fd2 = open(<span class="string">&quot;cpy.txt&quot;</span>, O_WRONLY|O_CREAT|O_TRUNC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((len=read(fd1, buf, <span class="keyword">sizeof</span>(buf)))&gt;<span class="number">0</span>)</span><br><span class="line">        write(fd2, buf, len);</span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="stdcmp-c"><a href="#stdcmp-c" class="headerlink" title="stdcmp.c"></a>stdcmp.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* fd1;  <span class="comment">// FILE*指针！</span></span><br><span class="line">    FILE* fd2;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    fd1 = fopen(<span class="string">&quot;news.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fd2 = fopen(<span class="string">&quot;cpy.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, BUF_SIZE, fd1)!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">fputs</span>(buf, fd2);</span><br><span class="line">    fclose(fd1);</span><br><span class="line">    fclose(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：复制了一个约400m的txt文件，显然stdcmp更快。</p>
<h2 id="15-2-文件描述符和FILE结构体指针的相互转换"><a href="#15-2-文件描述符和FILE结构体指针的相互转换" class="headerlink" title="15.2 文件描述符和FILE结构体指针的相互转换"></a>15.2 文件描述符和FILE结构体指针的相互转换</h2><h3 id="15-1-1-文件描述符转化为FILE结构体指针"><a href="#15-1-1-文件描述符转化为FILE结构体指针" class="headerlink" title="15.1.1 文件描述符转化为FILE结构体指针"></a>15.1.1 文件描述符转化为FILE结构体指针</h3><p>相互转换的功能都来自<code>stdio.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE * <span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：将文件描述符转化为标准IO使用的FILE结构体指针</li>
<li>参数<ul>
<li>fd：需要转化的文件描述符</li>
<li>mode：要创建的FILE结构体指针的mode，常用r和w</li>
</ul>
</li>
<li>成功返回转换的FILE结构体指针，失败返回NULL</li>
</ul>
<h3 id="15-1-2-FILE结构体指针转化为文件描述符"><a href="#15-1-2-FILE结构体指针转化为文件描述符" class="headerlink" title="15.1.2 FILE结构体指针转化为文件描述符"></a>15.1.2 FILE结构体指针转化为文件描述符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> * <span class="title function_">fileno</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：将标准IO使用的FILE结构体指针转化为文件描述符</li>
<li>参数<ul>
<li>FILE：FILE结构体指针</li>
</ul>
</li>
<li>成功返回转换文件描述符，失败返回-1</li>
</ul>
<h3 id="可能出现的情况："><a href="#可能出现的情况：" class="headerlink" title="可能出现的情况："></a>可能出现的情况：</h3><ul>
<li>不论是用<code>fclose(转换后的FILE结构体指针)</code>还是<code>close(转换后的文件描述符)</code>，都会关闭对应的转换前FILE结构体指针&#x2F;文件描述符。但有一个特别注意的是，如果之前使用了<code>write()</code></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>ch4 指令系统</title>
    <url>/2023/11/842d843bf492/</url>
    <content><![CDATA[<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><ul>
<li><strong>指令&#x2F;机器指令</strong>定义：指计算机执行某种操作的命令，是计算机运行最小功能单位。</li>
<li>所有指令的集合构成该机的指令系统叫<strong>指令集</strong>。不同计算机指令集一般不同，不兼容。</li>
<li>一条指令就是机器语言的一个语句。有意义的二进制代码。</li>
<li>指令字长与机器字长没有固定关系，可以相同，可以不同</li>
</ul>
<h2 id="4-1-指令格式"><a href="#4-1-指令格式" class="headerlink" title="4.1 指令格式"></a>4.1 指令格式</h2><p>基本是根据操作码的长度、功能分类</p>
<h3 id="4-1-1-基本格式"><a href="#4-1-1-基本格式" class="headerlink" title="4.1.1  基本格式"></a>4.1.1  基本格式</h3><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/clip_image002.jpg" alt="img"></p>
<p>根据地址码数目不同、分为以下格式</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231102123621389.png" alt="image-20231102123621389"></p>
<h3 id="4-1-2-定长操作码指令格式"><a href="#4-1-2-定长操作码指令格式" class="headerlink" title="4.1.2  定长操作码指令格式"></a>4.1.2  定长操作码指令格式</h3><p>高位部分分配固定n位表示操作码，那么操作系统最多有2^n条指令，简化硬件设计，提高指令译码速度。机器字长为32位及以上时的常规用法。</p>
<h3 id="4-1-3-拓展操作码指令格式"><a href="#4-1-3-拓展操作码指令格式" class="headerlink" title="4.1.3 拓展操作码指令格式"></a>4.1.3 拓展操作码指令格式</h3><p>有限指令字长时，为了保持比较丰富的指令种类，使得操作码不定长。增加译码和控制的复杂度。</p>
<ul>
<li>不允许短操作码是长操作码前缀，操作码不能重复。</li>
<li>且一般使用频率高的操作码设计为短操作码，使用频率低分配长操作码。减少指令译码分析时间</li>
</ul>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231102124310112.png" alt="image-20231102124310112"></p>
<blockquote>
<p>例题</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231102125310339.png" alt="image-20231102125310339"></p>
</blockquote>
<h3 id="4-1-4-指令类型"><a href="#4-1-4-指令类型" class="headerlink" title="4.1.4 指令类型"></a>4.1.4 指令类型</h3><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231102125005456.png" alt="image-20231102125005456"></p>
<h2 id="4-2指令的寻址方式"><a href="#4-2指令的寻址方式" class="headerlink" title="4.2指令的寻址方式"></a>4.2指令的寻址方式</h2><p>确定本条指令的数据地址（数据寻址）以及下一条待执行指令的地址（指令寻址）。</p>
<h3 id="4-2-1-指令寻址"><a href="#4-2-1-指令寻址" class="headerlink" title="4.2.1 指令寻址"></a>4.2.1 指令寻址</h3><h4 id="1、顺序寻址"><a href="#1、顺序寻址" class="headerlink" title="1、顺序寻址"></a>1、顺序寻址</h4><p>程序计数器PC+1自动形成下一条指令的地址。</p>
<h4 id="2、跳跃寻址"><a href="#2、跳跃寻址" class="headerlink" title="2、跳跃寻址"></a>2、跳跃寻址</h4><p>通过转移类的指令，如JMP，由本条指令指出下一条指令的地址（绝对地址和相对地址）。跳跃的结果修改PC。所以下一条指令地址仍然由PC给出。</p>
<h3 id="4-2-2-数据寻址（10种）"><a href="#4-2-2-数据寻址（10种）" class="headerlink" title="4.2.2 数据寻址（10种）"></a>4.2.2 数据寻址（10种）</h3><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231103102028653.png" alt="image-20231103102028653"></p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231103102156837.png" alt="image-20231103102156837"></p>
<h4 id="1、隐含寻址"><a href="#1、隐含寻址" class="headerlink" title="1、隐含寻址"></a>1、隐含寻址</h4><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231103092204441.png" alt="image-20231103092204441"></p>
<p>不给出操作数地址，而是根据操作码知道，</p>
<ul>
<li>有利于缩短指令字长</li>
<li>增加存储操作数或隐含地址的硬件。</li>
</ul>
<p>如ADD指令，该指令只给出了第一操作数的地址A，而隐含了累加器ACC的地址作为第二操作数地址。</p>
<h4 id="2、立即（数）寻址"><a href="#2、立即（数）寻址" class="headerlink" title="2、立即（数）寻址"></a>2、立即（数）寻址</h4><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231103092555957.png" alt="image-20231103092555957"></p>
<p>指令字的地址字段不是操作数地址，而是操作数本身，采用补码表示。</p>
<ul>
<li>优：指令执行不用访问主存，执行速度最快</li>
<li>缺：位数限制数据的范围</li>
</ul>
<h4 id="3、直接寻址"><a href="#3、直接寻址" class="headerlink" title="3、直接寻址"></a>3、直接寻址</h4><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231103092603583.png" alt="image-20231103092603583"></p>
<p>指令字的地址字段（形式地址A）就是操作数的真实地址EA，即EA &#x3D; A。</p>
<ul>
<li>优：简单，只访问一次主存，</li>
<li>缺：位数限制寻址范围，操作数地址不易修改？</li>
</ul>
<h4 id="4、间接寻址"><a href="#4、间接寻址" class="headerlink" title="4、间接寻址"></a>4、间接寻址</h4><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231103093243805.png" alt="image-20231103093243805"></p>
<p>指令字的地址字段（形式地址A）就是操作数<strong>的地址的地址</strong>，，即EA &#x3D; (A)。</p>
<ul>
<li>可以<strong>扩大寻址范围</strong>，因为EA大于A；便于编制程序（方便完成子程序返回）</li>
<li>一次执行指令可能需要多次访存，慢，不常用。</li>
</ul>
<h4 id="5、寄存器寻址"><a href="#5、寄存器寻址" class="headerlink" title="5、寄存器寻址"></a>5、寄存器寻址</h4><p>指令字的地址字段 是 操作数所在的寄存器编号，即EA &#x3D; R</p>
<ul>
<li>优：指令字短，不访问主存，快；支持向量&#x2F;矩阵运算。</li>
<li>缺：寄存器贵，且数量有限。</li>
</ul>
<h4 id="6、寄存器间接寻址"><a href="#6、寄存器间接寻址" class="headerlink" title="6、寄存器间接寻址"></a>6、寄存器间接寻址</h4><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231103094000331.png" alt="image-20231103094000331"></p>
<p>指令字的地址字段是 操作数的内存地址所在的寄存器编号，即EA &#x3D; (R)。类似间接寻址，</p>
<ul>
<li>比一次间接寻址快，因为只访问一次主存。</li>
</ul>
<h4 id="7、相对寻址"><a href="#7、相对寻址" class="headerlink" title="7、相对寻址"></a>7、相对寻址</h4><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231103094316188.png" alt="image-20231103094316188"></p>
<p>指令字的地址字段是一个相对地址，操作数就存在相对于PC所指地址的相对地址上。即EA &#x3D; (PC) + A。</p>
<blockquote>
<p>CPU取出指令的一个字节后，自动执行(PC) + 1 -&gt; PC。</p>
<p>若JMP A的指令的地址为X，且占2B，那么取出该地址后PC &#x3D; X+2；执行这条指令后，自动跳转到 X+2+A的相对地址执行。</p>
</blockquote>
<ul>
<li>指令和数据相差一个固定值，便于程序浮动。</li>
<li>A的位数决定寻址范围。</li>
</ul>
<h4 id="8、基址寻址"><a href="#8、基址寻址" class="headerlink" title="8、基址寻址"></a>8、基址寻址</h4><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231103095829138.png" alt="image-20231103095829138"></p>
<p><code>CPU中基址寄存器BR的内容  + 指令字地址字段的形式地址A = 操作数有效地址</code>。即<code>EA = (BR) + A</code>。</p>
<p>面向操作系统：</p>
<ul>
<li><p>用户可以决定是哪个寄存器作为BR，如专用寄存器、通用寄存器。</p>
</li>
<li><p>BR的内容由操作系统决定，所以用户无需关心程序在主存的哪个位置。</p>
</li>
<li><p>程序运行时，BR内容作为基地址不变，A作为偏移地址可改变。</p>
</li>
<li><p>优点：可扩大寻址范围，BR位数&gt;A位数；有利于多道程序设计，编制浮动程序，解决了程序逻辑地址与存储器物理地址的无关性。</p>
</li>
<li><p>缺点：偏移量仍然较短。</p>
</li>
</ul>
<h4 id="9、变址寻址"><a href="#9、变址寻址" class="headerlink" title="9、变址寻址"></a>9、变址寻址</h4><p><code>变址寄存器IX内容 + 指令字地址字段的形式地址A = 操作数有效地址</code>。即<code>EA = (IX) + A</code></p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231103100244722.png" alt="image-20231103100244722"></p>
<p>面向用户：</p>
<ul>
<li><p>用户可以决定是哪个寄存器作为IX，如专用寄存器、通用寄存器。</p>
</li>
<li><p>IX内容由用户设定</p>
</li>
<li><p>程序运行时，IX内容可以被改变，<strong>但形式地址A作为基地址不变</strong>。</p>
</li>
<li><p>优点：扩大寻址范围，IX位数&gt;A位数，IX位数足以表示整个存储空间。</p>
</li>
<li><p>适合编制循环程序；解决数组问题：设定A固定，不断改变IX，很容易形成数组任意数据的位置</p>
</li>
</ul>
<h4 id="10、堆栈寻址"><a href="#10、堆栈寻址" class="headerlink" title="10、堆栈寻址"></a>10、堆栈寻址</h4><p>存储器或专用寄存器组的LIFO存储区。读这个堆栈的地址由堆栈指针寄存器SP指出。</p>
<ul>
<li>硬堆栈：寄存器构成，成本高，容量小</li>
<li>软堆栈：主存划分的区域，常用</li>
</ul>
<p>采用堆栈结构的系统，大多数指令都是无操作数，隐含使用SP。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><blockquote>
<ul>
<li><p>基址寻址搭配变址寻址:EA&#x3D;A+(BR)+(IX)既能保证程序浮动，程序内又能实现循环。</p>
</li>
<li><p>变址寻址搭配间址寻址：</p>
<ul>
<li>先变址后间址：EA&#x3D;(A+(IX))</li>
<li>先间址后变址：EA&#x3D;(A)+(IX)</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="4-4-CISC-RISC"><a href="#4-4-CISC-RISC" class="headerlink" title="4.4 CISC &amp; RISC"></a>4.4 CISC &amp; RISC</h2><p>复杂&#x2F;精简指令集系统计算机</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231103102625534.png" alt="image-20231103102625534"></p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231103102639847.png" alt="image-20231103102639847"></p>
]]></content>
      <categories>
        <category>408</category>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>ch10-错误处理</title>
    <url>/2023/11/e10b2052a6a6/</url>
    <content><![CDATA[<h1 id="第十章-错误处理"><a href="#第十章-错误处理" class="headerlink" title="第十章 错误处理"></a>第十章 错误处理</h1><p>go使用函数的返回值来处理错误，如果返回nil，则表示没有错误。</p>
<h2 id="10-2-自定义错误"><a href="#10-2-自定义错误" class="headerlink" title="10.2 自定义错误"></a>10.2 自定义错误</h2><p><strong>go语言常量要是编译时就能确定的数据，errors.New(“xxx”) 要等到运行时才能确定，所以不能作为常量</strong></p>
<h3 id="10-2-1-错误类型"><a href="#10-2-1-错误类型" class="headerlink" title="10.2.1 错误类型"></a>10.2.1 错误类型</h3><p>error类型实际是个接口，error接口包含Error方法，调用这个方法就会返回一个字符串，这个字符串是显示当前的错误详情。</p>
<p>自定一个类型，类型实现了Error方法，它就实现了error接口，就是一个自定义的错误。</p>
<p>和struct一样，用<code>type</code>关键字定义一个错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-2-创建错误"><a href="#10-2-2-创建错误" class="headerlink" title="10.2.2 创建错误"></a>10.2.2 创建错误</h3><p>来自标准库的errors包，可以自定义错误内容</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := errors.New(<span class="string">&quot;this is an error&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="10-2-3-格式化错误格式"><a href="#10-2-3-格式化错误格式" class="headerlink" title="10.2.3 格式化错误格式"></a>10.2.3 格式化错误格式</h3><p>来自标准库fmt包的<code>Errorf</code>方法，也是生成一个错误对象，但可以设置返回的错误字符串的内容格式（即可以添加变量）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(Sprintf(format, a...)) <span class="comment">// 内部实际上也是调用了errors包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>demo：</p>
<p>runtime包中的<code>runtime.Caller(0)</code>获取了当前代码所在行数。然后由fmt的Errorf()将行数格式化进错误信息中，再由错误对象调用Error()方法返回错误信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, _, line, ok := runtime.Caller(<span class="number">0</span>); ok == <span class="literal">true</span> &#123;</span><br><span class="line">	err := fmt.Errorf(<span class="string">&quot;***Line %d error***&quot;</span>, line)</span><br><span class="line">	fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="10-3-宕机"><a href="#10-3-宕机" class="headerlink" title="10.3 宕机"></a>10.3 宕机</h2><p>当程序发出<strong>不可逆</strong>的错误，会使用内置函数panic方法触发宕机，中断程序。调用panic方法后的代码无效。</p>
<p>panic会直接将错误打印。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;Serious Bug&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is a invalid code&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-4-宕机恢复"><a href="#10-4-宕机恢复" class="headerlink" title="10.4 宕机恢复"></a>10.4 宕机恢复</h2><h3 id="10-4-1-捕获宕机"><a href="#10-4-1-捕获宕机" class="headerlink" title="10.4.1 捕获宕机"></a>10.4.1 捕获宕机</h3><p>在panic后，<strong>会执行defer语句</strong>。此处需要注意panic后程序执行的流程，除了main中的defer，可以看出<code>paincCode()</code>里的匿名函数的defer也被执行了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicCode</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 匿名函数</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;func panicCode() exit&quot;</span>) <span class="comment">// 1</span></span><br><span class="line">	&#125;() </span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;bug&quot;</span>) <span class="comment">// painc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 匿名函数</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;main() exit&quot;</span>) <span class="comment">// 2</span></span><br><span class="line">	&#125;()</span><br><span class="line">	panicCode()</span><br><span class="line">	fmt.Println(<span class="string">&quot;test&quot;</span>) <span class="comment">// no appear</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以利用到defer语句+ 匿名函数+ recover方法捕获宕机。</p>
<ul>
<li>触发panic后，执行defer，defer指向匿名函数，匿名函数里使用recover捕获。</li>
</ul>
<p>使用recover函数，可以让进入宕机流程中的 goroutine 恢复过来，recover 仅在延迟函数 defer 中有效，类似try-catch机制。</p>
<h3 id="10-4-2-recover的应用"><a href="#10-4-2-recover的应用" class="headerlink" title="10.4.2 recover的应用"></a>10.4.2 recover的应用</h3><p>实际编程中会专门封装一个函数，以一种较安全的方式运行传入的方法，即使发生panic，主程序仍继续运行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protect</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &#123;  <span class="comment">// protect()的参数是一个函数</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123; <span class="comment">// recover捕获宕机</span></span><br><span class="line">            <span class="comment">//recover函数获取panic的传入参数</span></span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	f() <span class="comment">// 让f运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	protect(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  <span class="comment">// 传入匿名函数1 并panic</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;func 1&quot;</span>)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;Bug in func 1&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	protect(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 传入匿名函数2 并panic</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;func 2&quot;</span>)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;Bug in func 2&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;test&quot;</span>) <span class="comment">// 仍会被运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-5-error的简单应用"><a href="#10-5-error的简单应用" class="headerlink" title="10.5 error的简单应用"></a>10.5 error的简单应用</h3><p>panic和recover能模拟其他语言的try-catch机制，但不建议使用，推荐使用多值返回来返回错误。不过我挺喜欢try-catch方式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(dividend <span class="type">int</span>, divisor <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> divisor == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;divisor is zero&quot;</span>) <span class="comment">// 返回一个error</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dividend / divisor, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    res1, err := div(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(res1)  <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    res2, err := div(<span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err.Error()) <span class="comment">//divisor is zero</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(res2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-7-error接口的应用"><a href="#10-7-error接口的应用" class="headerlink" title="10.7 error接口的应用"></a>10.7 error接口的应用</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ErrZeroDivisor <span class="type">int</span> <span class="comment">// 自定义类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e ErrZeroDivisor)</span></span> Error() <span class="type">string</span> &#123; <span class="comment">// 实现Error()方法</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Divisor is %d&quot;</span>, e) <span class="comment">// Error()方法返回的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div1</span><span class="params">(dividend <span class="type">int</span>, divisor <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> divisor == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, ErrZeroDivisor(<span class="number">0</span>) <span class="comment">// 此处的调用方式暂未见过 留有疑问？</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dividend / divisor, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_, error1 := div1(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">	_, error2 := div1(<span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line">	fmt.Println(error1)</span><br><span class="line">	fmt.Println(error2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Golang</category>
        <category>Go基础</category>
      </categories>
  </entry>
  <entry>
    <title>ch11-文件操作</title>
    <url>/2023/11/8c1b64ea2c6a/</url>
    <content><![CDATA[<h1 id="第11章-文件操作"><a href="#第11章-文件操作" class="headerlink" title="第11章 文件操作"></a>第11章 文件操作</h1><p>文件分为两类：文本文件和二进制文件。<br>windows目录不区分大小写，Unix区分。<br>windows每个盘都是自己的根目录，Unix只有<code>/</code>一个根目录。<br>I&#x2F;O操作封装在：</p>
<ul>
<li>io—— 为I&#x2F;O<strong>原语</strong>提供基本的接口</li>
<li>io&#x2F;ioutil—— 封装实用I&#x2F;O函数，也是本章重点</li>
<li>fmt —— 格式化I&#x2F;O</li>
<li>bufio —— 带缓冲I&#x2F;O</li>
</ul>
<h2 id="11-1-目录基本操作"><a href="#11-1-目录基本操作" class="headerlink" title="11.1 目录基本操作"></a>11.1 目录基本操作</h2><h3 id="11-1-1-目录"><a href="#11-1-1-目录" class="headerlink" title="11.1.1 目录"></a>11.1.1 目录</h3><p>io&#x2F;ioutil库中有关目录的方法已经在Go 1.16弃用。</p>
<p>采用os库</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 删除目录</span></span><br><span class="line">os.RemoveAll(path <span class="type">string</span>)</span><br><span class="line"><span class="comment">// 获取当前工作目录</span></span><br><span class="line">os.Getwd()</span><br><span class="line"><span class="comment">// 切换当前工作目录</span></span><br><span class="line">os.Chdir(path <span class="type">string</span>)</span><br><span class="line"><span class="comment">// 获取临时目录？</span></span><br><span class="line">os.TempDir()</span><br><span class="line"><span class="comment">// 读取目录</span></span><br><span class="line">os.ReadDir(name <span class="type">string</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="11-1-3-目录操作"><a href="#11-1-3-目录操作" class="headerlink" title="11.1.3 目录操作"></a>11.1.3 目录操作</h3><p>来自os库</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mkdir</span><span class="params">(name <span class="type">string</span>, perm FileMode)</span></span> <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MkdirAll</span><span class="params">(name <span class="type">string</span>, perm FileMode)</span></span> <span class="type">error</span> <span class="comment">// &quot;a/aa/aaa&quot; 多级目录</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Mkdir</code>只能创建一个一级目录，文件存在会创建失败返回错误；权限不足，也会创建失败</li>
<li><code>MkdirAll</code>能创建多级目录，目录存在返回nil，且不做操作。成功了都会返回nil。</li>
</ul>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveAll</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>Remove</code>只能删除空文件夹，非空返回错误；</p>
</li>
<li><p><code>RemoveAll</code>删除指定的文件，或目录及它包含的任何下级对象，指定对象不存在（其实也算删除成功），返回nil。</p>
<p>成功了都会返回nil。</p>
</li>
</ul>
<h4 id="判断目录或文件是否存在"><a href="#判断目录或文件是否存在" class="headerlink" title="判断目录或文件是否存在"></a>判断目录或文件是否存在</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(name <span class="type">string</span>)</span></span> (fi FileInfo, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>成功，返回描述文件对象的<code>FileInfo</code>，返回nil</li>
<li>若对象是个符号链接，返回符号链接指向的文件的<code>FileInfo，返回nil</code></li>
<li>出错，返回<code>*PathError</code>类型错误</li>
</ul>
<p>具体判断某文件是否存在，是用<code>Stat()</code>的返回的error确定</p>
<ul>
<li>如果error&#x3D;&#x3D;nil，文件&#x2F;文件夹存在</li>
<li>对返回的<code>os.IsNotExist(error)==true </code>，文件夹不存在</li>
<li>其他情况，不确定存在不存在</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fi, err := os.Stat(<span class="string">&quot;E:\\GoWorks\\3.jpg&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;文件夹存在&quot;</span>)</span><br><span class="line">    fmt.Println(fi.IsDir())</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;文件不存在&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;不确定存不存在&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建删除目录例程"><a href="#创建删除目录例程" class="headerlink" title="创建删除目录例程"></a>创建删除目录例程</h4><ul>
<li><code>isAll</code>决定是否是带All的目录操作</li>
<li><code>os.Mkdir</code>能设置创建目录权限，但可能失败，所以还用了<code>os.Chmod</code>。<a href="https://www.codenong.com/41565192/">关于go：设置os.Mkdir权限 | 码农家园 (codenong.com)</a><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createDir</span><span class="params">(path <span class="type">string</span>, dirName <span class="type">string</span>, isAll <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	dirPath := path + <span class="string">&quot;\\&quot;</span> + dirName</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> isAll &#123;</span><br><span class="line">		err = os.MkdirAll(dirPath, <span class="number">0777</span>) <span class="comment">// 可以增加多级</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = os.Mkdir(dirPath, <span class="number">0777</span>) <span class="comment">// 只能增加一级</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		os.Chmod(dirPath, <span class="number">0777</span>) <span class="comment">// 对创建的文件夹chmod</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;Create Dit =&gt;&quot;</span> + path + dirName)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDir</span><span class="params">(dirPath <span class="type">string</span>, isAll <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Delete Dir =&gt;&quot;</span> + dirPath)</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> isAll &#123;</span><br><span class="line">		err = os.Remove(dirPath) <span class="comment">// 可以删除多级</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = os.RemoveAll(dirPath) <span class="comment">// 只能删除一级</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Delete success&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rootPath := <span class="string">&quot;F:\\code\\GoWorks\\src\\GoTutorial\\ch11&quot;</span></span><br><span class="line">	createDir(rootPath, <span class="string">&quot;mkdir&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">	deleteDir(rootPath+<span class="string">&quot;\\mkdir&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">	createDir(rootPath, <span class="string">&quot;mkdir\\mkdirAll&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">	deleteDir(rootPath+<span class="string">&quot;\\mkdir\\mkdirAll&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="11-2-文件基本操作"><a href="#11-2-文件基本操作" class="headerlink" title="11.2 文件基本操作"></a>11.2 文件基本操作</h2><p>文件权限粒度：拥有者、所属组、其他组。每个粒度都能设置不同文件权限：<br> <img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230510000554747.png" alt="image-20230510000554747"></p>
<h3 id="11-2-1-文件的创建与打开"><a href="#11-2-1-文件的创建与打开" class="headerlink" title="11.2.1 文件的创建与打开"></a>11.2.1 文件的创建与打开</h3><h4 id="Open-和-Create"><a href="#Open-和-Create" class="headerlink" title="Open() 和 Create()"></a>Open() 和 Create()</h4><ul>
<li><code>Open</code>以读<code>O_RDONLY</code>形式打开文件</li>
<li><code>Create</code>采用<code>0666</code>（可读写不可执行）创建文件；如果文件存在，会清空文件内容；对应的文件描述符具有<code>O_RDWR</code>。</li>
<li>返回错误底层类型<code>*PathError</code><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="OpenFile"><a href="#OpenFile" class="headerlink" title="OpenFile()"></a>OpenFile()</h4><p>来自os库，OpenFile比Open和Create<strong>更底层</strong>（他们俩都是调用OpenFile），会以指定的<strong>选项flag</strong>和<strong>模式perm</strong>打开文件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>flag：访问模式 （并非所有操作系统都可用）<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"> O_RDONLY <span class="type">int</span> = syscall.O_RDONLY <span class="comment">// 只读模式打开文件</span></span><br><span class="line"> O_WRONLY <span class="type">int</span> = syscall.O_WRONLY <span class="comment">// 只写模式打开文件</span></span><br><span class="line"> O_RDWR <span class="type">int</span> = syscall.O_RDWR <span class="comment">// 读写模式打开文件</span></span><br><span class="line"> <span class="comment">// O_RDONLY |  O_WRONLY 不等于 O_RDWR， 他们分别为0、1、2</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 前三个只指定一个，剩下由 | 连接指定</span></span><br><span class="line"> O_APPEND <span class="type">int</span> = syscall.O_APPEND <span class="comment">// 写操作时将数据附加到文件尾部</span></span><br><span class="line"> O_CREATE <span class="type">int</span> = syscall.O_CREAT <span class="comment">// 如果不存在将创建一个新文件</span></span><br><span class="line"> O_EXCL <span class="type">int</span> = syscall.O_EXCL <span class="comment">// 和O_CREATE配合使用，文件必须不存在</span></span><br><span class="line"> O_SYNC <span class="type">int</span> = syscall.O_SYNC <span class="comment">// 打开文件用于同步I/O</span></span><br><span class="line"> O_TRUNC <span class="type">int</span> = syscall.O_TRUNC <span class="comment">// 如果可能，打开时清空文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>perm：位掩码参数 指定文件模式和权限位 （所有操作系统都一样）<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"> <span class="comment">// 单字符是被 String 方法用于格式化的属性缩写</span></span><br><span class="line"> ModeDir FileMode = <span class="number">1</span> &lt;&lt; (<span class="number">32</span> - <span class="number">1</span> - <span class="literal">iota</span>) <span class="comment">// d: 目录</span></span><br><span class="line"> ModeAppend <span class="comment">// a: 只能写入，且只能写入到末尾</span></span><br><span class="line"> ModeExclusive <span class="comment">// l: 用于执行</span></span><br><span class="line"> ModeTemporary <span class="comment">// T: 临时文件（非备份文件）</span></span><br><span class="line"> ModeSymlink <span class="comment">// L: 符号链接（不是快捷方式文件）</span></span><br><span class="line"> ModeDevice <span class="comment">// D: 设备</span></span><br><span class="line"> ModeNamedPipe <span class="comment">// p: 命名管道（FIFO）</span></span><br><span class="line"> ModeSocket <span class="comment">// S: Unix域socket</span></span><br><span class="line"> ModeSetuid <span class="comment">// u: 表示文件具有其创建者用户id权限</span></span><br><span class="line"> ModeSetgid <span class="comment">// g: 表示文件具有其创建者组id的权限</span></span><br><span class="line"> ModeCharDevice <span class="comment">// c: 字符设备，需已设置ModeDevice</span></span><br><span class="line"> ModeSticky <span class="comment">// t: 只有root/创建者能删除/移动文件</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 覆盖所有类型位（用于通过&amp;获取类型位），对普通文件，所有这些位都不应被设置</span></span><br><span class="line"> ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | </span><br><span class="line">ModeDevice</span><br><span class="line"> ModePerm FileMode = <span class="number">0777</span> <span class="comment">// 覆盖所有Unix权限位（用于通过&amp;获取类型位）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>实际上<code>Open()</code>和<code>Creat()</code>的底层就是<code>OpenFile()</code><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (＊File, <span class="type">error</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> OpenFile(name, O_RDONLY, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="type">string</span>)</span></span> (＊File, <span class="type">error</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">file, err := os.OpenFile(rootPath+<span class="string">&quot;\\1.txt&quot;</span>, os.O_RDWR|os.O_CREATE, <span class="number">0766</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(file) <span class="comment">// &amp;&#123;0xc00010c780&#125;</span></span><br><span class="line">file.Close()</span><br></pre></td></tr></table></figure>



<h3 id="11-2-2-文件读取"><a href="#11-2-2-文件读取" class="headerlink" title="11.2.2 文件读取"></a>11.2.2 文件读取</h3><p>os库</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Read (b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> ReadAt (b []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Read</code>方法从文件中读取最多<code>len(b)</code>字节，写入byte数组b中，返回真正读取的字节数n，和err。文件终止的标志是读取n&#x3D;&#x3D;0个字节且返回值err为io.EOF。</li>
<li><code>ReadAt</code>和<code>Read</code>的区别是，从文件开始的字节偏移量off开始读，并且不会改变文件偏移量。<ul>
<li>循环<code>Read</code>一字节，文件能慢慢读到文件末尾，因为读1字节，偏移量自动往后移动1字节；</li>
<li>而循环<code>ReadAt</code>1字节，如果off固定，每次就只会从文件开始的off偏移读取，偏移量不会自动往后走，除非调用时改变off。</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(path <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	file, err := os.Open(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>) <span class="comment">// 每次读1024字节</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="built_in">len</span>, err := file.Read(buf)</span><br><span class="line">        <span class="comment">// len, err := file.ReadAt(buf, 1)</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(err) <span class="comment">// EOF</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line">	&#125;</span><br><span class="line">	file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-2-3-文件写入"><a href="#11-2-3-文件写入" class="headerlink" title="11.2.3 文件写入"></a>11.2.3 文件写入</h3><p>同样的，和读取类似，也有两个接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> WriteAt(b []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>两种方法向文件中写入<code>len(b)</code>字节，如果返回值n!&#x3D;len(b)，就返回一个非nil错误。</li>
<li>两种方式都会覆盖原文件</li>
</ul>
<p>以下例程的两个函数的文件写入效果一样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(path <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	file, err := os.Create(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	data := <span class="string">&quot;data \n for \t writing!&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 偏移量自动改变</span></span><br><span class="line">		file.Write([]<span class="type">byte</span>(data))</span><br><span class="line">	&#125;</span><br><span class="line">	file.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFileAt</span><span class="params">(path <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	file, err := os.Create(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	data := <span class="string">&quot;data \n for \t writing!&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 偏移量手动改变</span></span><br><span class="line">		file.WriteAt([]<span class="type">byte</span>(data), <span class="type">int64</span>(i*<span class="built_in">len</span>(data)))</span><br><span class="line">	&#125;</span><br><span class="line">	file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-2-4-文件删除"><a href="#11-2-4-文件删除" class="headerlink" title="11.2.4 文件删除"></a>11.2.4 文件删除</h3><p>和目录一样调用<code>Remove</code>和<code>RemoveAll</code>即可，</p>
<h2 id="11-3-处理json文件"><a href="#11-3-处理json文件" class="headerlink" title="11.3 处理json文件"></a>11.3 处理json文件</h2><p>javaScript Object Notation，</p>
<blockquote>
<p>当我们需要对大量的JSON进行快速解析处理时，标准库提供的JSON处理库“encoding&#x2F;json” 可能就不能满足我们的需求，GitHub开源了一个比标准库解析速度快10倍的[fastjson库](https:&#x2F;&#x2F; github.com&#x2F;valyala&#x2F;fastjson)</p>
</blockquote>
<h3 id="11-3-1-编码JSON"><a href="#11-3-1-编码JSON" class="headerlink" title="11.3.1 编码JSON"></a>11.3.1 编码JSON</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span> <span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>Marshal</code>返回interface的JSON编码，v通常会用map或结构体，返回的[]byte可以转成string查看，但此时并没有格式化，输出一行json字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalIndent</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, prefix, indent <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>MarshalIndent</code>返回的是JSON编码的格式化形式，prefix为每一行的开头，indent是缩进的格式，都是字符串</p>
<h5 id="map存json"><a href="#map存json" class="headerlink" title="map存json"></a>map存json</h5><ul>
<li>例程<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>] <span class="keyword">interface</span>&#123;&#125;, <span class="number">6</span>) <span class="comment">// string为键，interface&#123;&#125;为值的map，最大存6个</span></span><br><span class="line">m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;walle&quot;</span></span><br><span class="line">m[<span class="string">&quot;age&quot;</span>] = <span class="number">1</span></span><br><span class="line">m[<span class="string">&quot;sex&quot;</span>] = <span class="literal">true</span></span><br><span class="line">m[<span class="string">&quot;language&quot;</span>] = []<span class="type">string</span>&#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;PHP&quot;</span>, <span class="string">&quot;PYTHON&quot;</span>&#125;</span><br><span class="line">result, _ := json.Marshal(m)</span><br><span class="line">resultFormat, _ := json.MarshalIndent(m, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;----&quot;</span>) <span class="comment">// 每一行以1开头，然后用----缩进</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(result))</span><br><span class="line">fmt.Println(<span class="type">string</span>(resultFormat))</span><br></pre></td></tr></table></figure></li>
<li>输出结果<blockquote>
<p>{“age”:1,”language”:[“Go”,”PHP”,”PYTHON”],”name”:”walle”,”sex”:true}<br>{<br>1—-“age”: 1,<br>1—-“language”: [<br>1——–”Go”,<br>1——–”PHP”,<br>1——–”PYTHON”<br>1—-],<br>1—-“name”: “walle”,<br>1—-“sex”: true<br>1}</p>
</blockquote>
</li>
</ul>
<h5 id="struct存json"><a href="#struct存json" class="headerlink" title="struct存json"></a>struct存json</h5><p>大多数情况使用struct结构体会更方便，可以在定义struct的成员变量时添加<strong>标签</strong>控制编码和解码：</p>
<ul>
<li><code>&quot;-&quot;</code>：不要解析这个字段</li>
<li><code>&quot;omitempty&quot;</code>：字段为空时，不要解析</li>
<li><code>&quot;FieldName&quot;</code>：解析时用这个名字</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="type">string</span>   <span class="string">`json:&quot;Name1&quot;`</span> <span class="comment">//以Name1编码</span></span><br><span class="line">	Age      <span class="type">int</span>      <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Sex      <span class="type">bool</span>     <span class="string">`json:&quot;-&quot;`</span> <span class="comment">// 不解析</span></span><br><span class="line">	Birthday <span class="type">string</span>   <span class="string">`json:&quot;birthday&quot;`</span></span><br><span class="line">	Company  <span class="type">string</span>   <span class="string">`json:&quot;company,omitempty&quot;`</span> <span class="comment">// 空时（默认值时）不解析</span></span><br><span class="line">	Language []<span class="type">string</span> <span class="string">`json:&quot;language&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line">person := Person&#123;<span class="string">&quot;walle&quot;</span>, <span class="number">10</span>, <span class="literal">true</span>, <span class="string">&quot;1900-1-1&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">	[]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;go&quot;</span>,</span><br><span class="line">		<span class="string">&quot;json&quot;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line">result, err := json.MarshalIndent(person, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(result))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>{<br>“Name1”: “walle”,<br>“age”: 10,<br>“birthday”: “1900-1-1”,<br>“language”: [<br> “go”,<br> “json”<br>]<br>}</p>
</blockquote>
<h3 id="11-3-2-解码JSON"><a href="#11-3-2-解码JSON" class="headerlink" title="11.3.2 解码JSON"></a>11.3.2 解码JSON</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="type">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>将解析json编码的数据放到v中，</p>
<h4 id="使用map存放"><a href="#使用map存放" class="headerlink" title="使用map存放"></a>使用map存放</h4><p>map可以通过键获获取值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">6</span>)</span><br><span class="line">err1 := json.Unmarshal([]<span class="type">byte</span>(jsonStr), &amp;map1)</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println( map1)</span><br><span class="line"><span class="comment">// map[Name:walle Sex:true age:10 birthday:1900-1-1 language:[go json]]</span></span><br></pre></td></tr></table></figure>
<p>如果要知道类型，需要进行<strong>类型断言</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">    <span class="keyword">switch</span> data := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;string&quot;</span>, key, data)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;bool&quot;</span>, key, data)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;int&quot;</span>, key, data)</span><br><span class="line">    <span class="keyword">case</span> []<span class="type">string</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;[]string&quot;</span>, key, data)</span><br><span class="line">    <span class="keyword">case</span> []<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">        fmt.Println(<span class="string">&quot;[]interface&quot;</span>, key, data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用struct存放（推荐）"><a href="#使用struct存放（推荐）" class="headerlink" title="使用struct存放（推荐）"></a>使用struct存放（推荐）</h4><p>其实就说struct内部已经定义好了类型，所以无需类型判断</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 Person <span class="comment">// 用到了11.3.1的Person结构体</span></span><br><span class="line">err2 := json.Unmarshal([]<span class="type">byte</span>(jsonStr), &amp;person1)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;person = %+v&quot;</span>, person1) </span><br><span class="line">   <span class="comment">//person = &#123;Name: Age:10 Sex:false Birthday:1900-1-1 Company: Language:[go json]&#125; </span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>Go基础</category>
      </categories>
  </entry>
  <entry>
    <title>ch14-反射</title>
    <url>/2023/11/a90c7818ac95/</url>
    <content><![CDATA[<h1 id="第14章-反射"><a href="#第14章-反射" class="headerlink" title="第14章 反射"></a>第14章 反射</h1><p><a href="http://www.zzvips.com/article/200181.html">一文搞懂Go反射的使用方法和应用场景_Golang_脚本之家 (zzvips.com)</a><br><a href="https://golangbot.com/reflection/">Reflection in Golang | golangbot.com</a></p>
<h2 id="14-1-反射的定义"><a href="#14-1-反射的定义" class="headerlink" title="14.1 反射的定义"></a>14.1 反射的定义</h2><p>go语言提供一种机制——反射：<strong>运行时</strong>更新变量和检查它们的值，调用它们的方法或支持的内在操作，但<strong>编译时</strong>并不知道这些变量的具体类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 不知道其他人调用该函数时，会传入什么类型</span></span><br><span class="line">    <span class="comment">// 1、类型断言可以获取x的类型，但需要猜，有很多种情况</span></span><br><span class="line">    <span class="comment">// 2、利用反射reflect</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-2-reflect包基本用法"><a href="#14-2-reflect包基本用法" class="headerlink" title="14.2 reflect包基本用法"></a>14.2 reflect包基本用法</h2><h3 id="14-2-1-reflect-TypeOf"><a href="#14-2-1-reflect-TypeOf" class="headerlink" title="14.2.1 reflect.TypeOf()"></a>14.2.1 <code>reflect.TypeOf()</code></h3><p><code>reflect.TypeOf()</code>获取反射类型对象<code>reflect.Type</code>，如<code>reflect.String</code>等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> typeOfa reflect.Type = reflect.TypeOf(a)</span><br><span class="line"><span class="comment">// reflect.Type的3种方法</span></span><br><span class="line">typeOfa.Name() <span class="comment">// 获得类型名称，经过type关键字后新建立的类型名</span></span><br><span class="line">typeOfa.Kind() <span class="comment">// 获得种类，实际的类型</span></span><br><span class="line">typeOfa.Elem() <span class="comment">// 若是指针就获得指向的类型</span></span><br></pre></td></tr></table></figure>

<p>反射的种类reflect.Kind的定义如下，如reflect.Int：</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230520202931430.png" alt="image-20230520202931430"></p>
<p>其中Map、Slice、Chan属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于 独立的种类，不属于Ptr。type A struct{}定义的结构体属于Struct种类，*A属于Ptr。</p>
<h5 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Number <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkType</span><span class="params">(t reflect.Type)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;变量的类型名称=&gt;%v, 类型种类=&gt; %v\n&quot;</span>, t.Name(), t.Kind())</span><br><span class="line">	<span class="keyword">if</span> t.Kind() == reflect.Ptr &#123; <span class="comment">// 指针，</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;指向的变量：%v&quot;</span>, t.Elem())</span><br><span class="line">		t = t.Elem() <span class="comment">// 如果是指针，t赋值为t的指向</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num Number = <span class="number">10</span></span><br><span class="line">	typeOfNum := reflect.TypeOf(num)</span><br><span class="line">	fmt.Println(<span class="string">&quot;typeOfNum:&quot;</span>)</span><br><span class="line">	checkType(typeOfNum)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> person Person</span><br><span class="line">	typeOfperson := reflect.TypeOf(person)</span><br><span class="line">	fmt.Println(<span class="string">&quot;typeOfperson:&quot;</span>)</span><br><span class="line">	checkType(typeOfperson)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> personPtr = &amp;person  </span><br><span class="line">	typeOfptr := reflect.TypeOf(&amp;personPtr)</span><br><span class="line">	fmt.Println(<span class="string">&quot;typeOfptr:&quot;</span>)</span><br><span class="line">	checkType(typeOfptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typeOfNum:</span><br><span class="line">变量的类型名称=&gt;Number, 类型种类=&gt; int   </span><br><span class="line">typeOfperson:                            </span><br><span class="line">变量的类型名称=&gt;Person, 类型种类=&gt; struct</span><br><span class="line">typeOfptr:                               </span><br><span class="line">变量的类型名称=&gt;, 类型种类=&gt; ptr       </span><br><span class="line">指向的变量：*main.Person   </span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="14-2-2-reflect-ValueOf"><a href="#14-2-2-reflect-ValueOf" class="headerlink" title="14.2.2 reflect.ValueOf()"></a>14.2.2 <code>reflect.ValueOf()</code></h3><p><code>reflect.ValueOf()</code>获取类型为<code>reflect.Value</code>的反射值对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> valueOfa reflect.Value = reflect.ValueOf(a)</span><br><span class="line">valueOfa.Type() <span class="comment">// 类型种类</span></span><br><span class="line">valueOfa.Elem() <span class="comment">// 若是指针就是指向的类型</span></span><br><span class="line"></span><br><span class="line">valueOfa.Int() <span class="comment">// 获取变量值，如果a不是int，会panic</span></span><br><span class="line"><span class="comment">// 基本类型都有，如valueOfa.String()、valueOfa.Bool()</span></span><br></pre></td></tr></table></figure>

<h5 id="例程-1"><a href="#例程-1" class="headerlink" title="例程"></a>例程</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkValue</span><span class="params">(v reflect.Value)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v.Kind() == reflect.Ptr &#123; </span><br><span class="line">		v = v.Elem() <span class="comment">// 如果是指针，v转移到指针指向的值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> v.Kind() == reflect.Int &#123;  <span class="comment">// 如果v的实际类型是int</span></span><br><span class="line">    	<span class="comment">// 方式1，调用reflect.Value的Int()，再强制类型转换</span></span><br><span class="line">		<span class="keyword">var</span> v1 <span class="type">int</span> = <span class="type">int</span>(v.Int()) <span class="comment">// 若v本身不是int，不做判断直接.Int()会panic</span></span><br><span class="line">        <span class="comment">// 方式2，调用reflect.Value的Interface()，再从interface转成int</span></span><br><span class="line">		<span class="keyword">var</span> v2 <span class="type">int</span> = v.Interface().(<span class="type">int</span>)</span><br><span class="line">		fmt.Println(v1, v2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">	ValueOfNum := reflect.ValueOf(num)</span><br><span class="line">	fmt.Println(<span class="string">&quot;ValueOfNum&quot;</span>)</span><br><span class="line">	checkValue(ValueOfNum)</span><br><span class="line"></span><br><span class="line">	ValueOfPtr := reflect.ValueOf(&amp;num)</span><br><span class="line">	fmt.Println(<span class="string">&quot;ValueOfPtr&quot;</span>)</span><br><span class="line">	checkValue(ValueOfPtr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-2-3-使用反射调用函数"><a href="#14-2-3-使用反射调用函数" class="headerlink" title="14.2.3  使用反射调用函数"></a>14.2.3  使用反射调用函数</h3><p>这块比较复杂，最好是结合例程进行理解：</p>
<ol>
<li>函数也是变量，所以也可以获取其<code>reflect.Value</code>对象。</li>
<li>函数的<code>reflect.Value</code>对象有个Call方法，调用Call方法能够调用函数本身。</li>
<li>Call方法的参数：reflect.Value对象的切片，每个元素按序是 函数本身所需要的参数 的reflect.Value对象</li>
<li>Call方法的返回值：reflect.Value对象的切片，每个元素按序是 函数本身返回值 的reflect.Value对象</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> Call(in []Value) []Value  <span class="comment">// func (v Value)的方法Call()，输入为切片，输出为切片</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果v的Kind不是Func会panic。参数没对应上也会panic。</li>
</ul>
<h5 id="例程-2"><a href="#例程-2" class="headerlink" title="例程"></a>例程</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Equal</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a == b &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取函数Equal的reflect.Value对象</span></span><br><span class="line">	valueOfFunc := reflect.ValueOf(Equal)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取reflect.Value对象的切片，作为valueOfFunc调用时的参数</span></span><br><span class="line">	args := []reflect.Value&#123;reflect.ValueOf(<span class="number">1</span>), reflect.ValueOf(<span class="number">2</span>)&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call方法调用，即调用函数本身</span></span><br><span class="line">	result := valueOfFunc.Call(args)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回值也是reflect.Value对象切片，获取返回值reflect.Value的变量值</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;result&quot;</span>, result[<span class="number">0</span>].Bool())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="14-3-对结构体的反射操作"><a href="#14-3-对结构体的反射操作" class="headerlink" title="14.3 对结构体的反射操作"></a>14.3 对结构体的反射操作</h2><h3 id="14-3-1-获取结构体成员类型"><a href="#14-3-1-获取结构体成员类型" class="headerlink" title="14.3.1 获取结构体成员类型"></a>14.3.1 获取结构体成员类型</h3><p>通过<code>reflect.Type()</code>获得的<code>reflect.Type</code>对象，可以调用如下方法</p>
<ul>
<li><p><code>NumField()</code>：获取结构体成员的数量</p>
</li>
<li><p><code>Field(index int)</code>：根据索引返回结构体字段详情信息，即<code>StructField</code>对象定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StructField <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span>    <span class="comment">// 字段名</span></span><br><span class="line">    PkgPath <span class="type">string</span> <span class="comment">// 字段路径</span></span><br><span class="line">    Type Type      <span class="comment">// 字段反射类型对象</span></span><br><span class="line">    Tag StructTag  <span class="comment">// 字段结构体标签</span></span><br><span class="line">    Offset <span class="type">uintptr</span> <span class="comment">// 字段在结构体中的偏移</span></span><br><span class="line">    Index []<span class="type">int</span> 	<span class="comment">// 字段的索引值</span></span><br><span class="line">    Anonymous <span class="type">bool</span> <span class="comment">// 是否为匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>FieldByName(name string)</code>：通过字段名（结构体成员名）获取字段信息，即<code>StructField</code>对象</p>
</li>
<li><p><code>FieldByIndex(index []int)</code>：It is equivalent to calling <code>Field()</code> successively for each index i.</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="type">string</span></span><br><span class="line">	Age    <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	<span class="type">string</span>     <span class="comment">// 匿名字段 Anonymous Field</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStructFiled</span><span class="params">(field reflect.StructField)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;字段名&quot;</span>, field.Name)</span><br><span class="line">	fmt.Println(<span class="string">&quot;字段路径&quot;</span>, field.PkgPath)</span><br><span class="line">	fmt.Println(<span class="string">&quot;字段反射类型对象&quot;</span>, field.Type)</span><br><span class="line">	fmt.Println(<span class="string">&quot;字段结构体标签&quot;</span>, field.Tag)</span><br><span class="line">	fmt.Println(<span class="string">&quot;字段在结构体中的偏移&quot;</span>, field.Offset)</span><br><span class="line">	fmt.Println(<span class="string">&quot;字段的索引值&quot;</span>, field.Index)</span><br><span class="line">	fmt.Println(<span class="string">&quot;是否为匿名字段&quot;</span>, field.Anonymous)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	person := Person&#123;<span class="string">&quot;walle&quot;</span>, <span class="number">100</span>, <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">	typeOfPerson := reflect.TypeOf(person)</span><br><span class="line">	<span class="comment">// 根据NumField()循环所有成员，获取字段信息</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; typeOfPerson.NumField(); i++ &#123;</span><br><span class="line">		field := typeOfPerson.Field(i)</span><br><span class="line">		printStructFiled(field)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// FieldByName()根据字段名获取字段信息</span></span><br><span class="line">	<span class="keyword">if</span> field, ok := typeOfPerson.FieldByName(<span class="string">&quot;Age&quot;</span>); ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;通过字段名获取字段信息&quot;</span>)</span><br><span class="line">		printStructFiled(field)</span><br><span class="line">		<span class="comment">//fmt.Println(field.Int())</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据索引获取字段信息</span></span><br><span class="line">	field := typeOfPerson.FieldByIndex([]<span class="type">int</span>&#123;<span class="number">1</span>&#125;)</span><br><span class="line">    <span class="comment">// field := typeOfPerson.Field(1) // 等价写法</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;通过索引获取字段信息&quot;</span>)</span><br><span class="line">	printStructFiled(field)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 Name</span><br><span class="line">字段路径                 </span><br><span class="line">字段反射类型对象 string  </span><br><span class="line">字段结构体标签           </span><br><span class="line">字段在结构体中的偏移 0   </span><br><span class="line">字段的索引值 [0]         </span><br><span class="line">是否为匿名字段 false     </span><br><span class="line">                         </span><br><span class="line">字段名 Age               </span><br><span class="line">字段路径                 </span><br><span class="line">字段反射类型对象 int     </span><br><span class="line">字段结构体标签 json:&quot;age&quot;</span><br><span class="line">字段在结构体中的偏移 16  </span><br><span class="line">字段的索引值 [1]         </span><br><span class="line">是否为匿名字段 false     </span><br><span class="line">                         </span><br><span class="line">字段名 string            </span><br><span class="line">字段路径 main            </span><br><span class="line">字段反射类型对象 string  </span><br><span class="line">字段结构体标签           </span><br><span class="line">字段在结构体中的偏移 24  </span><br><span class="line">字段的索引值 [2]         </span><br><span class="line">是否为匿名字段 true      </span><br><span class="line">                         </span><br><span class="line">通过字段名获取字段信息   </span><br><span class="line">字段名 Age</span><br><span class="line">...和Age一样</span><br><span class="line"></span><br><span class="line">通过索引获取字段信息</span><br><span class="line">字段名 Age</span><br><span class="line">...和Age一样</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="14-3-2-获取结构体成员字段的值"><a href="#14-3-2-获取结构体成员字段的值" class="headerlink" title="14.3.2 获取结构体成员字段的值"></a>14.3.2 获取结构体成员字段的值</h3><p>通过<code>reflect.Value()</code>获得的<code>reflect.Value</code>对象，可以调用如下方法（和<code>reflect.Type</code>的方法一样，但返回值不同）</p>
<ul>
<li><code>NumField()</code>：获取结构体成员的数量</li>
<li><code>Field(index int)</code>：根据索引返回字段<code>reflect.Value</code>对象</li>
<li><code>FieldByName(name string)</code>：通过字段名（结构体成员名）获取字段<code>reflect.Value</code>对象</li>
<li><code>FieldByIndex(index []int)</code>：It is equivalent to calling <code>Field()</code> successively for each index i.</li>
</ul>
<h3 id="14-3-3-反射执行结构体方法"><a href="#14-3-3-反射执行结构体方法" class="headerlink" title="14.3.3 反射执行结构体方法"></a>14.3.3 反射执行结构体方法</h3><p>流程与14.2.3反射调用函数流程一致，但需要通过<code>reflect.Value</code>的<code>MethodByName</code>获取方法作为方法变量（类似于函数变量）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">valueOfPerson := reflect.ValueOf(person) <span class="comment">// 获取reflect.Value</span></span><br><span class="line">f := valueOfPerson.MethodByName(<span class="string">&quot;GetName&quot;</span>) <span class="comment">// 获取方法变量</span></span><br><span class="line">f.Call([]reflect.Value&#123;&#125;)  <span class="comment">// call调用该方法</span></span><br></pre></td></tr></table></figure>



<h2 id="14-4-反射三定律"><a href="#14-4-反射三定律" class="headerlink" title="14.4 反射三定律"></a>14.4 反射三定律</h2><h3 id="14-4-1-接口到反射类型的转换"><a href="#14-4-1-接口到反射类型的转换" class="headerlink" title="14.4.1 接口到反射类型的转换"></a>14.4.1 接口到反射类型的转换</h3><p>反射可以将接口类型转化为反射类型（reflect.Type和reflect.Value）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br></pre></td></tr></table></figure>

<h3 id="14-4-2-反射到接口类型的转换"><a href="#14-4-2-反射到接口类型的转换" class="headerlink" title="14.4.2 反射到接口类型的转换"></a>14.4.2 反射到接口类型的转换</h3><p>反射可以将反射类型变量（reflect.Value）转化为接口类型，reflect.Value对象用了Interface()方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">valueOfA := reflect.ValueOf(a)</span><br><span class="line">fmt.Println(valueOfA.Interface()) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="14-4-3修改反射类型对象"><a href="#14-4-3修改反射类型对象" class="headerlink" title="14.4.3修改反射类型对象"></a>14.4.3修改反射类型对象</h3><p>想要使用反射修改变量值，其值是可写canSet的：1、变量可被寻址canAddr，2、变量可导出<br>（对结构体而言，字段不能是匿名，且字段名首字母大写）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span> <span class="string">`json:&quot;Age&quot;`</span> <span class="comment">// 字段名首字母非大写</span></span><br><span class="line">	<span class="type">string</span> <span class="comment">// 匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	person := Person&#123;<span class="string">&quot;w&quot;</span>, <span class="number">123</span>, <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">	valueOfPerson := reflect.ValueOf(&amp;person) <span class="comment">// 指针</span></span><br><span class="line">	typeOfPerson := reflect.TypeOf(&amp;person)   <span class="comment">// 指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; valueOfPerson.Elem().NumField(); i++ &#123;</span><br><span class="line">		fieldValue := valueOfPerson.Elem().Field(i)</span><br><span class="line">		fieldType := typeOfPerson.Elem().Field(i)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;类型名：%v，Value.CanAddr()=&gt;%v，fieldValue.CanSet=&gt;%v\n&quot;</span>, fieldType.Name, fieldValue.CanAddr(), fieldValue.CanSet())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;修改前&quot;</span>, person)</span><br><span class="line">	valueOfPerson.Elem().Field(<span class="number">0</span>).SetString(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;修改后&quot;</span>, person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于是指针，所以都可以寻址。而age字段和匿名字段不可导出，其值不能被修改。</p>
<blockquote>
<p>类型名：Name，Value.CanAddr()&#x3D;&gt;true，fieldValue.CanSet&#x3D;&gt;true<br>类型名：age，Value.CanAddr()&#x3D;&gt;true，fieldValue.CanSet&#x3D;&gt;false<br>类型名：string，Value.CanAddr()&#x3D;&gt;true，fieldValue.CanSet&#x3D;&gt;false<br>修改前 {w 123 test}<br>修改后 {test2 123 test}</p>
</blockquote>
<h2 id="14-5-反射的性能"><a href="#14-5-反射的性能" class="headerlink" title="14.5 反射的性能"></a>14.5 反射的性能</h2><p>反射的性能极差</p>
]]></content>
      <categories>
        <category>Golang</category>
        <category>Go基础</category>
      </categories>
  </entry>
  <entry>
    <title>ch12-接口类型</title>
    <url>/2023/11/f9dcb18c0cb7/</url>
    <content><![CDATA[<h1 id="第12章-接口与类型"><a href="#第12章-接口与类型" class="headerlink" title="第12章 接口与类型"></a>第12章 接口与类型</h1><p>接口是为了抽象，方便代码解耦。</p>
<p>我对接口就是定义某些数据类型能够实现的方法集合，只要实现了这些方法集合的数据类型，就属于某个接口。</p>
<p>比较常用的是对struct去实现，因为struct内部能同时维护多个不同类型的数据，相当于是C++类的成员变量。当实现接口时，接口里的方法相当于是C++类里的方法，方法是可以对struct里的数据进行操作的。</p>
<p>虽然不同的struct可能实现方法的方式不同，但都属于一个接口。一个显而易见的好处就是，在函数传参的时候，参数定义为该interface类型，只要是实现了这个接口的实例，就能被当作参数传入，这样不用针对不同的数据类型定义参数不同但内部实现完全相同的函数。</p>
<blockquote>
<ul>
<li>鸭子类型：动态类型的一种风格，一个对象的有效语义不是继承自特定的类 或 实现特定的接口来决定，而是由当前的<strong>方法和属性</strong>的集合所决定。</li>
<li>鸭子测试：当一只鸟走起来像鸭子，游泳起来像鸭子，叫起来也像鸭子，那这只鸟就可以被称为鸭子。</li>
</ul>
</blockquote>
<p>一个类型可以实现多个接口；多个类型可以实现同一个接口；任何一个接口必然实现了空接口。</p>
<h2 id="12-1-接口的定义"><a href="#12-1-接口的定义" class="headerlink" title="12.1 接口的定义"></a>12.1 接口的定义</h2><p>接口是一个自定义<strong>类型</strong>，所以也需要type关键字，</p>
<ul>
<li><p>不会暴露内部属性结构，只会展示出方法，因此不能将接口实例化。</p>
</li>
<li><p>单个函数的接口名以”er”为后缀，接口的实现去掉“er”</p>
</li>
</ul>
<h2 id="12-2-接口的创建和实现"><a href="#12-2-接口的创建和实现" class="headerlink" title="12.2 接口的创建和实现"></a>12.2 接口的创建和实现</h2><h3 id="12-2-1-接口创建"><a href="#12-2-1-接口创建" class="headerlink" title="12.2.1 接口创建"></a>12.2.1 接口创建</h3><p>接口创建时内部只需要声明存在什么方法，而不需要实现。这是由用户定义的类型去实现的，实现了这些方法的具体类型就叫这个接口类型的实例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> InterfaceName <span class="keyword">interface</span>&#123;</span><br><span class="line">    Method()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-2-2-demo"><a href="#12-2-2-demo" class="headerlink" title="12.2.2 demo"></a>12.2.2 demo</h3><p>创建一个数据库操作接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IDatabaser <span class="keyword">interface</span>&#123;</span><br><span class="line">    Connect() <span class="type">error</span></span><br><span class="line">    Disconncet() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是两个类型实现了数据库操作接口IDatabaser的方法，所以是IDatabaser接口的实例。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230510111558257.png" alt="image-20230510111558257"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mysql <span class="keyword">struct</span> &#123; </span><br><span class="line">    DBName    <span class="type">string</span></span><br><span class="line">    isConnect <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mysql *Mysql)</span></span> Connect() <span class="type">error</span> &#123;  <span class="comment">// 指针类型，可以修改Mysql内部元素</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Mysql Connect DB =&gt;&quot;</span> + mysql.DBName)</span><br><span class="line">	mysql.isConnect = <span class="literal">true</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Mysql connect Success!&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mysql *Mysql)</span></span> Disconnect() <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Mysql Disconnect Success!&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Redis <span class="keyword">struct</span> &#123;</span><br><span class="line">	DBName    <span class="type">string</span></span><br><span class="line">	isConnect <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(redis *Redis)</span></span> Connect() <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Redis Connect DB =&gt;&quot;</span> + redis.DBName)</span><br><span class="line">	redis.isConnect = <span class="literal">true</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Redis connect Success!&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(redis *Redis)</span></span> Disconnect() <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Redis Disconnect Success!&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql1 = Mysql&#123;DBName: <span class="string">&quot;student&quot;</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;开始连接&quot;</span>)</span><br><span class="line">mysql1.Connect()</span><br><span class="line">fmt.Println(<span class="string">&quot;断开连接&quot;</span>)</span><br><span class="line">mysql1.Disconnect()</span><br><span class="line"><span class="keyword">var</span> redis1 = Redis&#123;DBName: <span class="string">&quot;teacher&quot;</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;开始连接&quot;</span>)</span><br><span class="line">redis1.Connect()</span><br><span class="line">fmt.Println(<span class="string">&quot;断开连接&quot;</span>)</span><br><span class="line">redis1.Disconnect()</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然定义了接口，但没有面向接口编程，很多地方有冗余。当面向接口编程时，如使用如下<code>HandleDB</code>，就可以处理多种不同的数据类型，称为go的多态：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleDB</span><span class="params">(db IDatabser)</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;开始连接&quot;</span>)</span><br><span class="line">   db.Connect()</span><br><span class="line">   fmt.Println(<span class="string">&quot;断开连接&quot;</span>)</span><br><span class="line">   db.Disconnect()</span><br><span class="line">&#125;</span><br><span class="line">HandleDB(&amp;mysql1)</span><br><span class="line">HandleDB(&amp;redis1)</span><br></pre></td></tr></table></figure>

<h3 id="12-2-3-接口赋值"><a href="#12-2-3-接口赋值" class="headerlink" title="12.2.3 接口赋值"></a>12.2.3 接口赋值</h3><p>如果用户自定义的类型实现了某个接口类型所声明的一组方法，那么这个用户定义的类型的 值 就可以赋值给这个接口。这个赋值会把用户定义的类型的值存入接口类型的值。个人认为，赋值后，这个接口实例就是类型实例。</p>
<p>这里涉及接口变量：1、分配给接口变量的具体值 2、值的类型的描述器（接口实现者的类型）</p>
<ul>
<li>情况1：对象实例赋值给接口</li>
<li>情况2：一个接口赋值给另一个接口<ul>
<li>两个接口拥有同样的方法，他们就是相同，可以相互赋值。</li>
<li>接口A方法集是接口B方法集的子集（B&gt;A），B可以赋值给A。反之不行</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口IDatabser</span></span><br><span class="line"><span class="keyword">type</span> IDatabser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Connect() <span class="type">error</span></span><br><span class="line">	Disconnect() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口IRedisr，是IDatabser的子集</span></span><br><span class="line"><span class="keyword">type</span> IRedisr <span class="keyword">interface</span> &#123;</span><br><span class="line">	Connect() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型，用于实现接口</span></span><br><span class="line"><span class="comment">/* 来自12.2.2，实现了Connect()和Disconnect()方法</span></span><br><span class="line"><span class="comment">type Redis struct &#123;</span></span><br><span class="line"><span class="comment">	DBName    string</span></span><br><span class="line"><span class="comment">	isConnect bool</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况1：类型的对象实例赋值给接口</span></span><br><span class="line"><span class="keyword">var</span> idb IDatabser = &amp;Redis&#123;DBName: <span class="string">&quot;teacher&quot;</span>&#125; <span class="comment">// IDatabser接口idb就是这个Redis实例</span></span><br><span class="line"><span class="comment">// 情况2：一个接口赋值给他的子集接口</span></span><br><span class="line"><span class="keyword">var</span> irds IRedisr = idb <span class="comment">// IRedisr接口irds被IDatabser接口idb赋值，并忽略了没有实现的方法</span></span><br><span class="line">irds.Connect()</span><br><span class="line"><span class="comment">// irds.Disconnect() 不可用</span></span><br><span class="line">fmt.Println(reflect.TypeOf(idb)) <span class="comment">// *main.Redis</span></span><br><span class="line">fmt.Println(reflect.TypeOf(irds)) <span class="comment">// *main.Redis</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230510115437386.png" alt="image-20230510115437386"></p>
<h2 id="12-3-接口嵌入-组合接口"><a href="#12-3-接口嵌入-组合接口" class="headerlink" title="12.3 接口嵌入&#x2F;组合接口"></a>12.3 接口嵌入&#x2F;组合接口</h2><p>类似于C++的继承。如果接口A作为接口B的嵌入字段，那么B隐式包含了A接口的所有方法。</p>
<ul>
<li><p>除了嵌入接口，接口不能嵌入其他类型。</p>
</li>
<li><p>不能嵌入自身，包括直接嵌入和间接嵌入。</p>
<p>否则都会报<code>invalid recursive type</code>错误。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> interfaceA <span class="keyword">interface</span> &#123;</span><br><span class="line">    Method()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> interfaceB <span class="keyword">interface</span> &#123;</span><br><span class="line">    interfaceA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12-4-空接口"><a href="#12-4-空接口" class="headerlink" title="12.4 空接口"></a>12.4 空接口</h2><p><code>interface&#123;&#125;</code>不包含任何方法的接口，所以空接口可以存储任意类型的数值。但空接口存的内容 不能 能赋值给其他明确的类型（当然使用<code>:=</code>是可用的，但并不是其他类型，编译器仍推断其为空接口）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;123&quot;</span> </span><br><span class="line"><span class="keyword">var</span> interfaceStr <span class="keyword">interface</span>&#123;&#125; = str <span class="comment">// 空接口</span></span><br><span class="line"><span class="keyword">var</span> str2 = interfaceStr <span class="comment">// 可以</span></span><br><span class="line"><span class="comment">// var str2 string = interfaceStr // 不可以</span></span><br><span class="line">fmt.Println(reflect.TypeOf(interfaceStr)) <span class="comment">// string</span></span><br><span class="line">fmt.Println(reflect.TypeOf(str2))  <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>空接口常用在函数参数里，如下，用来传递多个不同类型的参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Log</span><span class="params">(paras ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, para := <span class="keyword">range</span> paras &#123;</span><br><span class="line">      fmt.Println(para)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">interList := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line">interList[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">interList[<span class="number">1</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line">interList[<span class="number">2</span>] = []<span class="type">string</span>&#123;<span class="string">&quot;str1&quot;</span>, <span class="string">&quot;str2&quot;</span>&#125;</span><br><span class="line">Log(interList...)  <span class="comment">// ...意思是将该切片拆散传入参数列表</span></span><br></pre></td></tr></table></figure>



<h2 id="12-5-类型断言"><a href="#12-5-类型断言" class="headerlink" title="12.5 类型断言"></a>12.5 类型断言</h2><p>通过类型断言，我们可以将接口值转换为其底层的具体类型，并访问该类型特有的方法或属性。</p>
<p><strong>类型断言是应用在接口变量上的操作</strong>，空接口不能赋值给其他类型，只能用类型断言。</p>
<p>类型断言其实就是类型转换，但不是强制类型转换，存了int的空接口只能用类型断言赋值给int变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">valT, ok := X.(T) </span><br></pre></td></tr></table></figure>
<p>断言失败时会抛出panic，除非用两个变量接收检查的结果。<br>判断接口变量X，是否为T类型，</p>
<ul>
<li>如果断言成功，valT是接口变量X的动态值，</li>
<li>如果断言失败，valT的类型为T，值为T的初始值</li>
</ul>
<h3 id="动态类型和静态类型"><a href="#动态类型和静态类型" class="headerlink" title="动态类型和静态类型"></a>动态类型和静态类型</h3><ul>
<li>动态类型</li>
<li>静态类型</li>
</ul>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/258617170">22. 图解：Go语言中的静态类型与动态类型 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h3 id="情况1：TypeName是具体类型"><a href="#情况1：TypeName是具体类型" class="headerlink" title="情况1：TypeName是具体类型"></a>情况1：TypeName是具体类型</h3><p>如果断言的类型T是一个具体类型，X.(T)就检查X的<strong>动态类型</strong>是否和T的相同</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkType</span><span class="params">(valT <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;断言成功&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;断言失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, valT, valT)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> interfaceX <span class="keyword">interface</span>&#123;&#125; = <span class="number">1</span> <span class="comment">// 空接口存int类型</span></span><br><span class="line">	valT0, OK := interfaceX.(<span class="type">string</span>) <span class="comment">// 断言为string，失败，valT0是string类型，初始值&quot;&quot;</span></span><br><span class="line">	checkType(valT0, OK)  </span><br><span class="line">    <span class="comment">//  断言失败</span></span><br><span class="line">    <span class="comment">// type =&gt; string value =&gt; </span></span><br><span class="line">	valT1, OK := interfaceX.(<span class="type">int</span>)  <span class="comment">// 断言为int，成功</span></span><br><span class="line">	checkType(valT1, OK) </span><br><span class="line">    <span class="comment">//  断言成功                </span></span><br><span class="line">    <span class="comment">// type =&gt; int value =&gt; 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="情况2：TypeName是接口类型"><a href="#情况2：TypeName是接口类型" class="headerlink" title="情况2：TypeName是接口类型"></a>情况2：TypeName是接口类型</h3><p>如果断言的类型TypeName是一个接口类型，就检查interfaceX的<strong>动态类型</strong>是否满足TypeName的接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口Person</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">	Speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student结构体类型</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Nmae <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Person接口方法，所以Student是接口Person的实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span></span> Speak() &#123;</span><br><span class="line">	fmt.Println(s.Nmae)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkType</span><span class="params">(valT <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;断言成功&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;断言失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, valT, valT)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> student <span class="keyword">interface</span>&#123;&#125; = Student&#123;<span class="string">&quot;walle&quot;</span>&#125;</span><br><span class="line">	valT0, ok := student.(<span class="type">int</span>)  <span class="comment">// 检查student的动态类型是否与int相同</span></span><br><span class="line">	checkType(valT0, ok)</span><br><span class="line">	<span class="comment">// 断言失败</span></span><br><span class="line">	<span class="comment">// type =&gt; int value =&gt; 0</span></span><br><span class="line">    </span><br><span class="line">	valT1, ok := student.(Person) <span class="comment">// 检查student的动态类型是否与Person相同</span></span><br><span class="line">	checkType(valT1, ok)</span><br><span class="line">	<span class="comment">// 断言成功                             </span></span><br><span class="line">	<span class="comment">// type =&gt; main.Student value =&gt; &#123;walle&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-5-1-ok-pattern和switch-type"><a href="#12-5-1-ok-pattern和switch-type" class="headerlink" title="12.5.1 ok-pattern和switch-type"></a>12.5.1 ok-pattern和switch-type</h3><p>接口类型断言的两种方式：ok-pattern和switch-type</p>
<h4 id="ok-pattern"><a href="#ok-pattern" class="headerlink" title="ok-pattern"></a>ok-pattern</h4><p>适用于要断言的<strong>接口类型种类</strong>typeName较少</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> value, ok := 接口变量.(类型)； ok ==<span class="literal">true</span> &#123;</span><br><span class="line">    <span class="comment">// 是该类型时的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="switch-pattern"><a href="#switch-pattern" class="headerlink" title="switch-pattern"></a>switch-pattern</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> value := 接口变量.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> 类型<span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 是该类型时的处理</span></span><br><span class="line">    <span class="keyword">case</span> 类型<span class="number">2</span>:</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line">	s[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	s[<span class="number">1</span>] = <span class="string">&quot;abc&quot;</span></span><br><span class="line">	s[<span class="number">2</span>] = Person&#123;<span class="string">&quot;walle&quot;</span>, <span class="number">100</span>&#125;</span><br><span class="line">	<span class="comment">// ok-pattern</span></span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">if</span> t, ok := value.(<span class="type">int</span>); ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, t, t)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> t, ok := value.(<span class="type">string</span>); ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, t, t)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> t, ok := value.(Person); ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, t, t)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// switch-pattern</span></span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">switch</span> t := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, t, t)</span><br><span class="line">		<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, t, t)</span><br><span class="line">		<span class="keyword">case</span> Person:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, t, t)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12-7-侵入式-非侵入式接口"><a href="#12-7-侵入式-非侵入式接口" class="headerlink" title="12.7 侵入式&#x2F;非侵入式接口"></a>12.7 侵入式&#x2F;非侵入式接口</h2><ul>
<li><p>侵入式接口：需要显式地创建一个类去实现一个接口。</p>
</li>
<li><p>非侵入式接口：不需要显式</p>
<p>go接口属于非侵入式，更为灵活</p>
</li>
</ul>
<h2 id="12-8-有趣的接口"><a href="#12-8-有趣的接口" class="headerlink" title="12.8 有趣的接口"></a>12.8 有趣的接口</h2><h3 id="fmt包的Stringer接口"><a href="#fmt包的Stringer接口" class="headerlink" title="fmt包的Stringer接口"></a>fmt包的Stringer接口</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A <code>Stringer</code> is a type that can describe itself as a string. The <code>fmt</code> package (and many others) look for this interface to print values.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了string()方法，所以是fmt包里的Stringer()接口的实例</span></span><br><span class="line"><span class="comment">// 返回值是string，打印自己的内部变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">	z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">	fmt.Println(a, z) <span class="comment">// a和z都可以调用String()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Golang</category>
        <category>Go基础</category>
      </categories>
  </entry>
  <entry>
    <title>ch17-HTTP编程</title>
    <url>/2023/11/861a8f3c4257/</url>
    <content><![CDATA[<h1 id="17-HTTP编程"><a href="#17-HTTP编程" class="headerlink" title="17 HTTP编程"></a>17 HTTP编程</h1><ul>
<li>HTTP基于TCP协议上建立</li>
<li>当建立在TLS或SSL协议上时，协议变成了加密HTTPS协议</li>
</ul>
<h3 id="17-1-2-URL地址"><a href="#17-1-2-URL地址" class="headerlink" title="17.1.2 URL地址"></a>17.1.2 URL地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">协议://主机地址/路径?查询</span><br><span class="line">https://www.baidu.com/s?wd=Go语言</span><br><span class="line"></span><br><span class="line">协议://用户名:密码@子域名.域名.顶级域名:端口号/目录/文件名.文件后缀?参数=值#标志</span><br><span class="line">http://admin:password@ceshi.baidu.com:8080/dir/test.php?id=1#flag=1</span><br></pre></td></tr></table></figure>

<h2 id="17-2-HTTP客户端"><a href="#17-2-HTTP客户端" class="headerlink" title="17.2 HTTP客户端"></a>17.2 HTTP客户端</h2><p>RESTful风格路由 Representational State Transfer </p>
<ul>
<li>GET（READ）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
</ul>
<p>对客户端请求用得最多的两个：GET和POST</p>
<ul>
<li>GET 从指定的资源请求数据</li>
<li>POST 向指定的资源提交要被处理的数据</li>
</ul>
<p>1、GET用来从服务器获取数据，POST用来向服务器传输数据<br>2、GET不安全，请求会被放在URL，Header和data一起发出。而POST的操作对用户不可见，浏览器会先发送Header，服务器响应100后，再发送data。<br>3、GET传输数据量小，受URL长度限制，Form表单数据集的值必须是ASCII；POST可以传大量数据，且支持整个ISO 10646字符集。</p>
<h1 id="三个重要的结构体"><a href="#三个重要的结构体" class="headerlink" title="三个重要的结构体"></a>三个重要的结构体</h1><h2 id="1、Client结构体"><a href="#1、Client结构体" class="headerlink" title="1、Client结构体"></a>1、Client结构体</h2><p>Client结构体类型主要充当浏览器角色，创建时结构体成员可以是默认值（无特殊需求基本是默认值）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    Transport RoundTripper</span><br><span class="line">    CheckRedirect <span class="function"><span class="keyword">func</span></span> &#123;req *Request, via []*Request) <span class="type">error</span></span><br><span class="line">    Jar CookieJar</span><br><span class="line">    Timeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Transport指定执行独立、单次HTTP请求机制。若为nil，则是DefaultTransport</li>
<li>CheckRedirect指定重定向策略。如果为nil，采用默认策略连续10次请求后停止。</li>
<li>Jar指定Cookie管理器。若为nil，请求和回复cookie都忽略。</li>
<li>Timeout指定请求时间限制，包括连接时间、重定向、读取回复主体的时间。0表示不设置超时。</li>
</ul>
<p>拥有如下方法对资源增删改查，其中最重要的是<code>Do</code>方法，其他方法都是对do方法的封装。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clinet)</span></span> Do(req *Request) (resp *Response, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clinet)</span></span> Head(url *<span class="type">string</span>) (resp *Response, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clinet)</span></span> Get(url *<span class="type">string</span>) (resp *Response, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clinet)</span></span> Post(url *<span class="type">string</span>, bodyType <span class="type">string</span>, body io.Reader) (resp *Response, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clinet)</span></span> PostForm(url *<span class="type">string</span>, data url.Values) (resp *Response, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>





<h2 id="2、Request结构体："><a href="#2、Request结构体：" class="headerlink" title="2、Request结构体："></a>2、Request结构体：</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequest</span><span class="params">(method, urlStr <span class="type">string</span>, body io.Reader)</span></span> (*Request,<span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>返回Request结构体指针，指定方法、访问url以及io.Reader接口的body，当method为GET时，body&#x3D;nil即可。</p>
<p>如果参数body实现了的io.ReadCloser接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	Method           <span class="type">string</span>               <span class="comment">// 请求方法</span></span><br><span class="line">	URL              *url.URL             <span class="comment">// 请求地址</span></span><br><span class="line">	Proto            <span class="type">string</span>               <span class="comment">// 协议版本，&quot;HTTP/1.0&quot;</span></span><br><span class="line">	ProtoMajor       <span class="type">int</span>                  <span class="comment">// 协议主版本号，“1”</span></span><br><span class="line">	ProtoMinor       <span class="type">int</span>                  <span class="comment">// 协议主副版本号，“0”</span></span><br><span class="line">	Header           Header               <span class="comment">// 请求头</span></span><br><span class="line">	Body             io.ReadCloser        <span class="comment">// 请求的Body</span></span><br><span class="line">	ContentLength    <span class="type">int64</span>                <span class="comment">// ContentLength记录相关内容的长度</span></span><br><span class="line">	TransferEncoding []<span class="type">string</span>             <span class="comment">// TransferEncoding按从最外到最里的顺序列出传输编码</span></span><br><span class="line">	Close            <span class="type">bool</span>                 <span class="comment">// Close在服务端指定是否在回复请求后关闭连接，在客户端指定是否在发送请求后关闭连接</span></span><br><span class="line">	Host             <span class="type">string</span>               <span class="comment">// Host指定URL会在其上寻找资源的主机</span></span><br><span class="line">	Form             url.Values           <span class="comment">// Form是解析好的表单数据，包括URL字段的query参数和POST或PUT的表单数据</span></span><br><span class="line">	PostForm         url.Values           <span class="comment">// PostForm是解析好的POST或PUT的表单数据</span></span><br><span class="line">	MultipartForm    *multipart.Form      <span class="comment">// MultipartForm是解析好的多部件表单，包括上传的文件</span></span><br><span class="line">	Trailer          Header               <span class="comment">// Trailer指定了会在请求主体之后发送的额外的头域</span></span><br><span class="line">	RemoteAddr       <span class="type">string</span>               <span class="comment">// RemoteAddr允许HTTP服务器和其他软件记录该请求的来源地址，一般用于日志</span></span><br><span class="line">	RequestURI       <span class="type">string</span>               <span class="comment">// RequestURI是被客户端发送到服务端的请求中未修改的URI</span></span><br><span class="line">	TLS              *tls.ConnectionState <span class="comment">// TLS字段允许HTTP服务器和其他软件记录接收到该请求的TLS连接的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3、Response结构体"><a href="#3、Response结构体" class="headerlink" title="3、Response结构体"></a>3、Response结构体</h2><p>请求都会返回Response结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    Status           <span class="type">string</span>               <span class="comment">//表示HTTP响应的状态行中的状态码和原因短语，例如&quot;200 OK&quot;</span></span><br><span class="line">    StatusCode       <span class="type">int</span>                  <span class="comment">//表示HTTP响应的状态码，例如200</span></span><br><span class="line">    Proto            <span class="type">string</span>               <span class="comment">//表示使用的HTTP协议版本，例如&quot;HTTP/1.1&quot;</span></span><br><span class="line">    ProtoMajor       <span class="type">int</span>                  <span class="comment">//表示使用的HTTP协议版本的主版本号，例如1</span></span><br><span class="line">    ProtoMinor       <span class="type">int</span>                  <span class="comment">//表示使用的HTTP协议版本的副版本号，例如1</span></span><br><span class="line">    Header           Header               <span class="comment">//表示HTTP响应的头部信息，是一个Header类型的映射</span></span><br><span class="line">    Body             io.ReadCloser        <span class="comment">//表示HTTP响应的主体，是一个io.ReadCloser类型的接口，可以读取响应的数据</span></span><br><span class="line">    ContentLength    <span class="type">int64</span>                <span class="comment">//表示HTTP响应的主体的长度，如果长度未知则为-1</span></span><br><span class="line">    TransferEncoding []<span class="type">string</span>             <span class="comment">//表示HTTP响应的传输编码，例如&quot;chunked&quot;，如果未设置则为nil</span></span><br><span class="line">    Close            <span class="type">bool</span>                 <span class="comment">//表示HTTP响应是否需要关闭连接</span></span><br><span class="line">    Uncompressed     <span class="type">bool</span>                 <span class="comment">//表示HTTP响应是否已经解压缩</span></span><br><span class="line">    Trailer          Header               <span class="comment">//表示HTTP响应的头部信息中未确定的部分</span></span><br><span class="line">    Request          *Request             <span class="comment">//表示发送HTTP请求的Request结构体，如果未设置则为nil</span></span><br><span class="line">    TLS              *tls.ConnectionState <span class="comment">//表示HTTP响应的TLS连接信息，如果未使用TLS则为nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>需要注意的是，Request结构体和Response结构体中的Body都是io.ReadCloser类型，需要使用io.ReadAll读取，同时，需要主动去close()。</strong></p>
<h2 id="发起请求的两种方式"><a href="#发起请求的两种方式" class="headerlink" title="发起请求的两种方式"></a>发起请求的两种方式</h2><h3 id="1、创建客户端结构体、请求结构体进行请求"><a href="#1、创建客户端结构体、请求结构体进行请求" class="headerlink" title="1、创建客户端结构体、请求结构体进行请求"></a>1、创建客户端结构体、请求结构体进行请求</h3><h4 id="优点：可以定制request的细节。"><a href="#优点：可以定制request的细节。" class="headerlink" title="优点：可以定制request的细节。"></a>优点：可以定制request的细节。</h4><h4 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h4><ol>
<li>创建 客户端结构体 http.Client{} </li>
<li>NewRequest生成 请求结构体</li>
<li>设置请求结构体的内容，如header、cookie</li>
<li>客户端结构体调用请求方法</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequest</span><span class="params">(method, urlStr <span class="type">string</span>, body io.Reader)</span></span> (*Request, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>NewRequest输入访问的类型、url 以及 body，返回一个<strong>Request结构体</strong>地址。</p>
<p>POST请求需要用到body。</p>
<h4 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h4><p>使用Request结构体的Do方法，所以要先用NewRequest创建请求结构体。GET方法不需要body字段，所以NewRequest中body为nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建client</span></span><br><span class="line">	client := &amp;http.Client&#123;&#125;</span><br><span class="line">    <span class="comment">// 新建请求request结构体</span></span><br><span class="line">	request, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://www.baidu.com&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置request结构体的Header模仿浏览器（非必要）</span></span><br><span class="line">	request.Header.Set(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;</span>)</span><br><span class="line">	request.Header.Set(<span class="string">&quot;Accept-Charset&quot;</span>, <span class="string">&quot;GBK,utf-8;q=0.7,*;q=0.3&quot;</span>)</span><br><span class="line">	request.Header.Set(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip,deflate,sdch&quot;</span>)</span><br><span class="line">	request.Header.Set(<span class="string">&quot;Accept-Language&quot;</span>, <span class="string">&quot;zh-CN,zh;q=0.8&quot;</span>)</span><br><span class="line">	request.Header.Set(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;max-age=0&quot;</span>)</span><br><span class="line">	request.Header.Set(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;keep-alive&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加cookie两种方式，模拟登录（非必要） [userId=12345 session=YWRtaW4=]</span></span><br><span class="line">	cookie := &amp;http.Cookie&#123;Name: <span class="string">&quot;userID&quot;</span>, Value: strconv.Itoa(<span class="number">12345</span>)&#125; <span class="comment">// 新建</span></span><br><span class="line">    <span class="comment">// 为request添加cookie</span></span><br><span class="line">	request.AddCookie(cookie)</span><br><span class="line">	request.AddCookie(&amp;http.Cookie&#123;Name: <span class="string">&quot;session&quot;</span>, Value: <span class="string">&quot;YWRtaW4=&quot;</span>&#125;) </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用Do请求</span></span><br><span class="line">	response, err := client.Do(request)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fmt.Println(response.StatusCode) <span class="comment">// 打印响应状态码</span></span><br><span class="line">	fmt.Println(response.Request.Header) <span class="comment">// 打印请求头</span></span><br><span class="line">	fmt.Println(response.Request.Cookies()) <span class="comment">// 打印cookie</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 打印响应体</span></span><br><span class="line">	responseBody, err := io.ReadAll(response.Body)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(responseBody))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2、http包直接请求"><a href="#2、http包直接请求" class="headerlink" title="2、http包直接请求"></a>2、http包直接请求</h3><p>例如使用http包的<code>GET()</code>，可以快速发起一个GET请求。底层就是调用Client结构体的GET方法，底层的GET方法是对DO方法的封装。不需要NewRequest创建结构体，直接请求url。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">response, err := http.Get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> response.Body.Close()  </span><br><span class="line">body, _ := ioutil.ReadAll(response.Body)</span><br><span class="line">fmt.Println(<span class="type">string</span>(body))</span><br></pre></td></tr></table></figure>



<h2 id="17-2-3-发起POST请求"><a href="#17-2-3-发起POST请求" class="headerlink" title="17.2.3 发起POST请求"></a>17.2.3 发起POST请求</h2><p>POST要用到Body字段，所以使用NewRequest时需要设置。io.Closer接口若被实现，会被Client类型的Do、Post和PostForm方法以及Transport.RoundTrip方法关闭。</p>
]]></content>
      <categories>
        <category>Golang</category>
        <category>Go基础</category>
      </categories>
  </entry>
  <entry>
    <title>ch13-并发与通道</title>
    <url>/2023/11/f9e8bdee9563/</url>
    <content><![CDATA[<h1 id="第13章-并发与通道"><a href="#第13章-并发与通道" class="headerlink" title="第13章 并发与通道"></a>第13章 并发与通道</h1><p>协程（coroutine），属于多线程编程</p>
<ul>
<li>并行：同一时刻，多条指令在多处理器运行</li>
<li>并发：同一时刻只有一条指令执行，但多个进程被快速的轮回执行。宏观上达到多进程同时执行的效果。</li>
</ul>
<p>Go语言的并发基于（Communication Sequential Process, 通信顺序进程）模型，该模型用于描述两个独立并发实体，通过共享的通信<strong>管道</strong>（而非共享内存）进行通信的并发模型。</p>
<p>对于CSP模型，显式的锁可以被避免，通过安全的通道发送和接收数据实现同步。</p>
<h2 id="13-2-goroutine"><a href="#13-2-goroutine" class="headerlink" title="13.2 goroutine"></a>13.2 goroutine</h2><p>比线程更加轻量：</p>
<ul>
<li>协程和线程对用户而言几乎没区别。但实际上线程是基本有2MB固定栈；而协程采用动态扩张的栈，初始化2KB，最大扩张到1GB。</li>
<li>每个线程有一个id，所以可以方便地通过id操作线程；协程没有，不能通过一个协程杀死另一个协程，他们的创建和释放需要在编码时考虑（重要）。</li>
<li>线程的切换需要陷入内核，然后上下文切换；协程在用户态就能由协程调度器完成，代价更小，尽管切换点都是时间片用完，或者进入IO或睡眠等状态。</li>
<li>垃圾回收的必要条件的 <strong>内存位于一致状态</strong>。交给OS去做会暂停所有线程使一致，而GO中的调度器知道什么时候一致，就没必要暂停所有运行的线程。</li>
</ul>
<h3 id="13-2-2-创建goroutine"><a href="#13-2-2-创建goroutine" class="headerlink" title="13.2.2 创建goroutine"></a>13.2.2 创建goroutine</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名(参数)</span><br></pre></td></tr></table></figure>
<p>若函数有返回值，返回值会被忽略，只能使用channel。</p>
<ul>
<li>例程：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Task1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>), <span class="string">&quot;Task1&quot;</span>)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Task2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>), <span class="string">&quot;Task2&quot;</span>)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> Task1()</span><br><span class="line">	<span class="keyword">go</span> Task2()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>), <span class="string">&quot;Main&quot;</span>)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
main函数会在一个单独的goroutine中运行，新的goroutine会用go创建。当运行下面的代码，会立刻返回，因为当Task1的协程被切换成main goroutine，main中没有任何代码逻辑，程序被判断执行完毕，所有协程终止。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> Task1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
main函数终止，所有goroutine也会一并结束；终止goroutine的最好办法是在函数中自然返回。</li>
</ul>
<h3 id="13-2-4-匿名函数创建goroutine"><a href="#13-2-4-匿名函数创建goroutine" class="headerlink" title="13.2.4 匿名函数创建goroutine"></a>13.2.4 匿名函数创建goroutine</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 匿名函数</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			fmt.Println(time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>), <span class="string">&quot;Task2&quot;</span>)</span><br><span class="line">			time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(time.Second * <span class="number">100</span>) <span class="comment">// 防止main终止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-2-5-runtime包"><a href="#13-2-5-runtime包" class="headerlink" title="13.2.5 runtime包"></a>13.2.5 runtime包</h3><p>一个小型任务调度器</p>
<h4 id="1-Gosched"><a href="#1-Gosched" class="headerlink" title="1 Gosched()"></a>1 Gosched()</h4><p>使得调用它的协程放弃处理器，会在未来恢复执行。<br>协程是抢占式调度，出现如下情况，goroutine发送调度</p>
<ul>
<li>syscall</li>
<li>C函数调用，本质和syscall一样</li>
<li>主动调用<code>runtime.Gosched</code></li>
<li>某个goroutine调度时间超过100ms，且其调用了<strong>非内联</strong>函数<blockquote>
<p>内敛函数就是调用一个函数的时候是将函数代码插入到当前位置，而不是执行调用。能加快运行速度。</p>
</blockquote>
</li>
</ul>
<h5 id="例程："><a href="#例程：" class="headerlink" title="例程："></a>例程：</h5><p>若将<code>runtime.Gosched()</code>注释掉，main goroutine会很快执行完成，使得匿名函数goroutine无法抢占cpu。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;go&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		runtime.Gosched()</span><br><span class="line">		fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-Goexit"><a href="#2-Goexit" class="headerlink" title="2 Goexit()"></a>2 Goexit()</h4><p><code>Goexit()</code><strong>终止</strong>调用它的Go协程，其他Go协程不受影响。若有defer会执行。<br>试了一下，main goroutine似乎不能调用<code>Goexit()</code>。</p>
<blockquote>
<p>fatal error: no goroutines (main called runtime.Goexit) - deadlock!</p>
</blockquote>
<h5 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Task3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;task1 end&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task1 start&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task1 work&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Task4</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;task2 end&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task2 start&quot;</span>)</span><br><span class="line">	runtime.Goexit()</span><br><span class="line">	fmt.Println(<span class="string">&quot;task2 work&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> Task3()</span><br><span class="line">	<span class="keyword">go</span> Task4()</span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-GOMAXPROCS"><a href="#3-GOMAXPROCS" class="headerlink" title="3 GOMAXPROCS()"></a>3 GOMAXPROCS()</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">GOMAXPROCS(n <span class="type">int</span>) <span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>该函数设置程序在运行中所使用的CPU数，默认最大，n&lt;1就不更改设置。会返回先前的设置，即第一次设置会返回。<br>机器逻辑CPU数（也可以用<code>runtime.NumCPU()</code>查询）。</p>
<h5 id="例程-1"><a href="#例程-1" class="headerlink" title="例程"></a>例程</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">KillTimeWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			a := <span class="number">99999</span> ^ <span class="number">99999</span></span><br><span class="line">			a = a + <span class="number">1</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;CPU num:&quot;</span>, runtime.NumCPU())</span><br><span class="line">	n := runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;previous setting: &quot;</span>, n)</span><br><span class="line">	fmt.Println(<span class="string">&quot;now setting 1&quot;</span>)</span><br><span class="line">	flag1 := time.Now()</span><br><span class="line">	KillTimeWork()</span><br><span class="line">	flag2 := time.Now()</span><br><span class="line">	fmt.Println(<span class="string">&quot;KillTimeWork() cost:&quot;</span>, flag2.Sub(flag1))</span><br><span class="line"></span><br><span class="line">	n = runtime.GOMAXPROCS(<span class="number">12</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;previous setting: &quot;</span>, n)</span><br><span class="line">	fmt.Println(<span class="string">&quot;now setting: &quot;</span>, runtime.NumCPU())</span><br><span class="line">	flag1 = time.Now()</span><br><span class="line">	KillTimeWork()</span><br><span class="line">	flag2 = time.Now()</span><br><span class="line">	fmt.Println(<span class="string">&quot;KillTimeWork() cost:&quot;</span>, flag2.Sub(flag1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CPU型号R55600，6核心12线程，刚好12线程对应逻辑CPU数，显然12个协程<strong>并行</strong>会比1个协程快得多。</p>
<blockquote>
<p>CPU num: 12<br>previous setting:  12<br>now setting 1<br>KillTimeWork() cost: 19.5095ms<br>previous setting:  1<br>now setting:  12<br>KillTimeWork() cost: 1.6618ms</p>
</blockquote>
<h2 id="13-3-channel"><a href="#13-3-channel" class="headerlink" title="13.3 channel"></a>13.3 channel</h2><ul>
<li>channel其实就是FIFO的队列，不需要加锁，因为其内部实现同步，保证了并发安全。</li>
<li>往空channel取，会死锁，相当于是一直等待一个</li>
</ul>
<blockquote>
<p>goroutine运行在相同的地址空间，访问共享内存要做好同步。</p>
<p>引用类型是CSP模式的具体实现，用于多个goroutine之间的通信。</p>
</blockquote>
<h3 id="13-3-1-channel基础用法"><a href="#13-3-1-channel基础用法" class="headerlink" title="13.3.1 channel基础用法"></a>13.3.1 channel基础用法</h3><p>声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 通道变量 <span class="keyword">chan</span> Type <span class="comment">// nil channel，无论接受和发送都会被阻塞</span></span><br></pre></td></tr></table></figure>
<ul>
<li>引用类型channel是CSP模式的具体体现，内部实现了同步，保证了并发安全，用于goroutine之间的通信。</li>
<li>channel是 make创建 的底层数据结构的<strong>引用</strong>，这一点和map类似。复制channel或用于参数传递时，只是拷贝了一个channel引用。</li>
<li>数据接收格式：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">channel &lt;- value <span class="comment">// 写入</span></span><br><span class="line">value, ok &lt;- channel <span class="comment">// 向channel接收并保存，ok检查通道是否关闭</span></span><br><span class="line">&lt;- channel <span class="comment">// 接收但丢弃</span></span><br><span class="line"><span class="built_in">len</span>(ch) <span class="comment">// 长度 	</span></span><br><span class="line"><span class="built_in">cap</span>(ch) <span class="comment">//容量</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>也可以是接口通道，但取出来的东西需要类型断言  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>



<h3 id="13-3-2-初始化-缓冲机制"><a href="#13-3-2-初始化-缓冲机制" class="headerlink" title="13.3.2 初始化+缓冲机制"></a>13.3.2 初始化+缓冲机制</h3><p>一句话而言，就是channel空时阻塞读，channel满时阻塞写。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type) <span class="comment">// 即make(chan Type, 0)</span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type, capacity)</span><br></pre></td></tr></table></figure>
<ul>
<li>capacity&#x3D;&#x3D;0，channel是<strong>无缓冲阻塞读写</strong>；</li>
<li>capacity&gt;0则是<strong>有缓冲非阻塞</strong>，直到写满capacity个元素才<strong>阻塞</strong>写入（不让写入，进入阻塞）。</li>
</ul>
<p>无缓冲的意思是：先执行<strong>发送或接收</strong>的goroutine阻塞等待，直到有其他 goroutine接收或发送。</p>
<h5 id="例程-2"><a href="#例程-2" class="headerlink" title="例程"></a>例程</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>) <span class="comment">// 有缓冲</span></span><br><span class="line"><span class="comment">// ch := make(chan int)  // 无缓冲</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;len(ch)=%v, cap(ch)=%v\n&quot;</span>, <span class="built_in">len</span>(ch), <span class="built_in">cap</span>(ch))</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无缓冲时，main goroutine主动sleep，每1秒收一次数据，所以匿名函数goroutine每次输入通道，都会阻塞，直到通道的内容被取走。</p>
<blockquote>
<p>len(ch)&#x3D;0, cap(ch)&#x3D;0<br>0<br>len(ch)&#x3D;0, cap(ch)&#x3D;0<br>1<br>len(ch)&#x3D;0, cap(ch)&#x3D;0<br>2</p>
</blockquote>
<p>此例中，有缓冲时，匿名函数goroutine一股脑输入通道，无需阻塞，后续main goroutine每隔一秒从缓冲中取。</p>
<blockquote>
<p>len(ch)&#x3D;0, cap(ch)&#x3D;3<br>len(ch)&#x3D;1, cap(ch)&#x3D;3<br>len(ch)&#x3D;2, cap(ch)&#x3D;3<br>0<br>1<br>2</p>
</blockquote>
<h3 id="13-3-2-close和range"><a href="#13-3-2-close和range" class="headerlink" title="13.3.2 close和range"></a>13.3.2 close和range</h3><h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><p>当发送者本身没有更多值要发给channel，可以通过close让接收者知道，停止不必要的等待。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>
<ul>
<li>不需要经常关闭，实在没有任何数据传输再关闭</li>
<li>关闭后无法向channel发送数据，也无法再调用close，否则panic</li>
<li>关闭后仍能从中读取</li>
<li>nil channel无论接受和发送都会被阻塞</li>
</ul>
<p>在向channel取元素时，还会返回ok，如果ok&#x3D;&#x3D;true，表示通道已经关闭。</p>
<h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>调用了close()后，除了读取通道返回ok得知通道是否关闭，还能通过<code>range()</code>知道，此时通道一定要关闭，否则出错。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;len(ch)=%v, cap(ch)=%v\n&quot;</span>, <span class="built_in">len</span>(ch), <span class="built_in">cap</span>(ch))</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)   <span class="comment">// ---------应当关闭，否则方式1和方式2都会抛出panic</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 方式1：range通道</span></span><br><span class="line"><span class="keyword">for</span> val := <span class="keyword">range</span> ch &#123;</span><br><span class="line">	fmt.Println(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：for循环读取</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    val, ok := &lt;-ch</span><br><span class="line">    <span class="keyword">if</span> ok &#123;  <span class="comment">// 如果channel关闭，ok==false</span></span><br><span class="line">        <span class="built_in">println</span>(val)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么range和for遍历通道前，一定要close通道？（暂时不知道有多个协程时是否一定，但只有main go routine时一定要close）</p>
<blockquote>
<p>当所有的其他goroutine终止，而只剩一个goroutine在阻塞读取通道，因为不可能有其他goroutine写入通道，导致死锁，会产生<strong>死锁</strong>panic：<code>fatal error: all goroutines are asleep - deadlock!    </code>。</p>
</blockquote>
<h3 id="13-3-4-单向channel"><a href="#13-3-4-单向channel" class="headerlink" title="13.3.4 单向channel"></a>13.3.4 单向channel</h3><p>单向管道的意义：</p>
<ul>
<li>可以作为方法的参数，限制方法内部对管道的读写，误操作。</li>
<li>底层处理效率更高</li>
</ul>
<p>此处需要注意，输入输出是针对通道而言的，输出是通道向外发送。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// ch1为一个双向通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span>&lt;- <span class="type">int</span> <span class="comment">// ch2为一个只能接收的单向通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 &lt;-<span class="keyword">chan</span> <span class="type">int</span>  <span class="comment">//  ch3为只能输出的单向通道</span></span><br></pre></td></tr></table></figure>
<h5 id="例程-生产者消费者模型"><a href="#例程-生产者消费者模型" class="headerlink" title="例程  生产者消费者模型"></a>例程  生产者消费者模型</h5><p>双向channe可以隐式转换为单向channel，反过来不行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;  <span class="comment">// 通道只能接收数据，生产者函数</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		out &lt;- i <span class="comment">// 输出</span></span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">comsumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;  <span class="comment">// 通道只能输出数据，生产者函数</span></span><br><span class="line">	<span class="keyword">for</span> val := <span class="keyword">range</span> in &#123; <span class="comment">// 输出</span></span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">go</span> producer(ch) <span class="comment">// 隐式转换为单向</span></span><br><span class="line">	comsumer(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例程2-定时器"><a href="#例程2-定时器" class="headerlink" title="例程2 定时器"></a>例程2 定时器</h5><p>标准库time的定时器NewTicker。<br>NewTicker.C就是一个<strong>无缓冲单通道channel</strong>，个人猜测是内部每1秒会向该通道输入，所以向其取数时，会有1秒的间隔时长。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	fmt.Println(&lt;-ticker.C) <span class="comment">// 1秒</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;loop&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-4-select"><a href="#13-4-select" class="headerlink" title="13.4 select"></a>13.4 select</h2><p>select监听channel上的数据流动，类似switch。</p>
<ul>
<li>有较多限制，最大限制是每个case语句里必须是一个IO操作<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-chan1:</span><br><span class="line"><span class="comment">//如果没有阻塞，执行</span></span><br><span class="line"><span class="keyword">case</span> &lt;-chan2:</span><br><span class="line"><span class="comment">//如果没有阻塞，执行</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 都阻塞，执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在一个select语句中，Go语言会按顺序<strong>从头至尾</strong>评估每一个发送和接收语句。有多个语句可以继续执行（没有被阻塞），那么就从那些可以执行的语句中<strong>随机</strong>选择一条来使用。</li>
<li>如果没有default，case都不满足时会被阻塞，直到有一个case的IO可以进行。</li>
</ul>
<h5 id="例程-3"><a href="#例程-3" class="headerlink" title="例程"></a>例程</h5><p>有时候goroutine阻塞，可以使用select实现阻塞超时机制</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> msg := &lt;-ch:</span><br><span class="line">			fmt.Println(msg)</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">3</span>):  <span class="comment">// 阻塞超时机制</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;已超时&quot;</span>)</span><br><span class="line">			done &lt;- <span class="literal">true</span> <span class="comment">// 超时</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	ch &lt;- i <span class="comment">// ch没有close，并且main goroutine并没有终止，导致select中msg一直等，直到超时。</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;-done  <span class="comment">// 阻塞，直到超时</span></span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br></pre></td></tr></table></figure>





<h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(goodsChan <span class="keyword">chan</span>&lt;- <span class="type">int</span>, goodsNum <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; goodsNum; i++ &#123;</span><br><span class="line">		goods := rand.Intn(<span class="number">100</span>)</span><br><span class="line">		goodsChan &lt;- goods</span><br><span class="line">		fmt.Println(<span class="string">&quot;生产产品：&quot;</span>, goods)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deliver</span><span class="params">(goodsChan &lt;-<span class="keyword">chan</span> <span class="type">int</span>, shopChan <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		goods := &lt;-goodsChan</span><br><span class="line">		fmt.Println(<span class="string">&quot;运输产品：&quot;</span>, goods)</span><br><span class="line">		shopChan &lt;- goods</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(shopChan &lt;-<span class="keyword">chan</span> <span class="type">int</span>, exitChan <span class="keyword">chan</span>&lt;- <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		goods := &lt;-shopChan</span><br><span class="line">		fmt.Println(<span class="string">&quot;消费次数序号：&quot;</span>, i, <span class="string">&quot; 商品：&quot;</span>, goods)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	exitChan &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">生产者：每一秒产生一个商品</span></span><br><span class="line"><span class="comment">运输者：一有商品就运输到商店</span></span><br><span class="line"><span class="comment">消费者：每两秒消费一个商品，消费十次后，程序结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	goodsChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">	shopChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">	exitChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">	<span class="comment">// 如果goodsNum&lt;10，那么消费者在消费9次后，会进入死锁</span></span><br><span class="line">	<span class="comment">// 如果goodsNum&gt;10，那么消费者消费完后，商店还会有剩余商品</span></span><br><span class="line">	goodsNum := <span class="number">10</span></span><br><span class="line">	<span class="keyword">go</span> producer(goodsChan, goodsNum)</span><br><span class="line">	<span class="keyword">go</span> deliver(goodsChan, shopChan)</span><br><span class="line">	<span class="keyword">go</span> consumer(shopChan, exitChan)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-exitChan:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>例如，秒杀商品30分钟后，要判断是否付款。即周期性进行任务判断。</p>
<p>使用time包获取一个定时器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">fmt.Println(time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br><span class="line">timer := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> now := &lt;-timer.C:</span><br><span class="line">	fmt.Println(now.Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">now := &lt;-time.After(time.Second * <span class="number">2</span>)  <span class="comment">// 底层使用time.NewTime实现</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br></pre></td></tr></table></figure>



<h3 id="使用time-Ticker"><a href="#使用time-Ticker" class="headerlink" title="使用time.Ticker"></a>使用time.Ticker</h3><p>如果只在主协程调用，而不是go func()内部调用ticker.Stop()，会使得t :&#x3D; &lt;-ticker.C阻塞，进而主协程阻塞，导致死锁；而go出来的子协程就算阻塞，也能被主线程终止，不会死锁。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">circleTaskWithTicker</span><span class="params">()</span></span> &#123;</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	ticker := time.NewTicker(time.Second)</span><br><span class="line">	exitChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="comment">// 新协程在任务执行两次后停止定时器，并通过exitChan告知主协程</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			t := &lt;-ticker.C</span><br><span class="line">			fmt.Println(t)</span><br><span class="line">			count++</span><br><span class="line">			<span class="keyword">if</span> count &gt; <span class="number">2</span> &#123;</span><br><span class="line">				ticker.Stop()</span><br><span class="line">				exitChan &lt;- <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-exitChan:</span><br><span class="line">		fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用time-Timer"><a href="#使用time-Timer" class="headerlink" title="使用time.Timer"></a>使用time.Timer</h3><p>timer只会往管道输入一次时间，要实现类似ticker的效果的话，需要不断地reset。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">circleTaskWithTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	timer := time.NewTimer(time.Second)</span><br><span class="line">	exitChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			t := &lt;-timer.C</span><br><span class="line">			timer.Reset(time.Second)</span><br><span class="line">			fmt.Println(t)</span><br><span class="line">			count++</span><br><span class="line">			<span class="keyword">if</span> count &gt; <span class="number">2</span> &#123;</span><br><span class="line">				timer.Stop()</span><br><span class="line">				exitChan &lt;- <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-exitChan:</span><br><span class="line">		fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="引入sync包的waitGroup"><a href="#引入sync包的waitGroup" class="headerlink" title="引入sync包的waitGroup"></a>引入sync包的waitGroup</h3><p>免去使用exitChan对主协程的终止，更方便</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231015112716336.png" alt="image-20231015112716336"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">count := <span class="number">0</span></span><br><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 告知WaitGroup只需要等待一个任务完成</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		t := &lt;-ticker.C</span><br><span class="line">		fmt.Println(t)</span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">if</span> count &gt; <span class="number">2</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="comment">// 时间到，任务完成</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait() <span class="comment">// 等待</span></span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Golang</category>
        <category>Go基础</category>
      </categories>
  </entry>
  <entry>
    <title>ch6-内置容器</title>
    <url>/2023/11/19d9e2ad9d4e/</url>
    <content><![CDATA[<h1 id="第六章-Go语言内置容器"><a href="#第六章-Go语言内置容器" class="headerlink" title="第六章 Go语言内置容器"></a>第六章 Go语言内置容器</h1><p>数组array、切片slice、映射map</p>
<p>引用类型是一种特殊类型，它们包括切片（slice）、映射（map）和通道（channel）等。与基本类型（如整数、浮点数和布尔值）不同，引用类型具有更灵活的内存分配和操作方式</p>
<h2 id="6-1-数组"><a href="#6-1-数组" class="headerlink" title="6.1 数组"></a>6.1 数组</h2><p><strong>数组大小固定，不能通过数组本身增加删除元素</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组声明</span></span><br><span class="line"><span class="keyword">var</span> array1 [<span class="number">3</span>]<span class="type">int</span> </span><br><span class="line"><span class="comment">// 初始化数组</span></span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment">// 指定大小</span></span><br><span class="line"><span class="keyword">var</span> array2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment">// 编译器根据初始化元素个数指定大小</span></span><br></pre></td></tr></table></figure>


<h2 id="6-1-切片slice"><a href="#6-1-切片slice" class="headerlink" title="6.1 切片slice"></a>6.1 切片slice</h2><ul>
<li><strong>切片并不存储任何元素，是对现有数组的引用</strong></li>
<li>切片结构：地址、长度、容量。<ul>
<li>长度指当前切片所含有的元素个数，</li>
<li>容量指切片所能容纳的元素个数，</li>
<li>如果是在数组&#x2F;切片截取生成的切片，新切片地址是在数组&#x2F;切片<strong>截取位置的地址</strong>。</li>
</ul>
</li>
</ul>
<h3 id="6-2-1-切片生成方式"><a href="#6-2-1-切片生成方式" class="headerlink" title="6.2.1 切片生成方式"></a>6.2.1 切片生成方式</h3><ul>
<li><p>从数组&#x2F;切片上截取生成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 = 数组或切片[<span class="number">1</span>:<span class="number">4</span>]  <span class="comment">// 切片元素来自数组或切片的第1~3个元素。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>直接生成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 = []<span class="keyword">type</span> &#123;item1,itme2,itme3&#125; <span class="comment">// 注意，[]内放数字或`...`时为数组，什么都不放是切片。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>make生成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="type">int</span> <span class="built_in">len</span>, <span class="type">int</span> <span class="built_in">cap</span>)  <span class="comment">// 指定切片类型，长度和容量，默认初始化。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> fruit = [<span class="number">4</span>]<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;pineapple&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 切片生成方式1：从数组上生成</span></span><br><span class="line">fSlice1 := fruit[<span class="number">1</span>:]</span><br><span class="line"><span class="comment">// 切片生成方式2：从切片上生成</span></span><br><span class="line">fSlice2 := fSlice1[:<span class="number">2</span>]</span><br><span class="line"><span class="comment">// 切片生成方式3：直接生成</span></span><br><span class="line">fSlice3 := []<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;pineapple&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 切片生成方式4：make生成</span></span><br><span class="line">slice4 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;fruit:&quot;</span>, fruit)  <span class="comment">// fruit: [apple banana orange pineapple]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice1:&quot;</span>, fSlice1) <span class="comment">//  [banana orange pineapple]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice2:&quot;</span>, fSlice2) <span class="comment">//  [banana orange]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice3:&quot;</span>, fSlice3) <span class="comment">// [apple banana orange pineapple]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;slice3:&quot;</span>, slice4) <span class="comment">// [0 0 0]</span></span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Printf(<span class="string">&quot;fruit type: %T \n&quot;</span>, fruit) <span class="comment">// fruit type: [4]string</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;fSlice1 type: %T \n&quot;</span>, fSlice1) <span class="comment">// fSlice1 type: []string</span></span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Println(<span class="string">&quot;fruit addr:&quot;</span>, &amp;fruit[<span class="number">0</span>]) <span class="comment">// 0xc000024080</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice1 addr:&quot;</span>, &amp;fSlice1[<span class="number">0</span>]) <span class="comment">// 0xc000024090</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice2 addr:&quot;</span>, &amp;fSlice2[<span class="number">0</span>]) <span class="comment">// 0xc000024090</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice3 addr:&quot;</span>, &amp;fSlice3[<span class="number">0</span>]) <span class="comment">// 0xc0000240c0</span></span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Println(<span class="string">&quot;fruit len:&quot;</span>, <span class="built_in">len</span>(fruit), <span class="string">&quot;;capacity:&quot;</span>, <span class="built_in">cap</span>(fruit)) <span class="comment">// fruit len: 4 ;capacity: 4</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice1 len:&quot;</span>, <span class="built_in">len</span>(fSlice1), <span class="string">&quot;;capacity:&quot;</span>, <span class="built_in">cap</span>(fSlice1)) <span class="comment">// fSlice1 len: 3 ;capacity: 3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice2 len:&quot;</span>, <span class="built_in">len</span>(fSlice2), <span class="string">&quot;;capacity:&quot;</span>, <span class="built_in">cap</span>(fSlice2)) <span class="comment">// fSlice2 len: 2 ;capacity: 3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice3 len:&quot;</span>, <span class="built_in">len</span>(fSlice3), <span class="string">&quot;;capacity:&quot;</span>, <span class="built_in">cap</span>(fSlice3)) <span class="comment">// fSlice3 len: 4 ;capacity: 4</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-4-切片添加元素"><a href="#6-2-4-切片添加元素" class="headerlink" title="6.2.4 切片添加元素"></a>6.2.4 切片添加元素</h3><ul>
<li><p>添加方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice1 = <span class="built_in">append</span>(slice1, <span class="number">1</span>)</span><br><span class="line">slice1 = <span class="built_in">append</span>(slice1, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 2个元素</span></span><br><span class="line">slice1 = <span class="built_in">append</span>(slice1, slice2...) <span class="comment">// 另一个slice时要加...，不能是数组。</span></span><br></pre></td></tr></table></figure></li>
<li><p>当添加元素的时候，如果当前len&#x3D;&#x3D;cap，即长度将超过容量，切片会按2倍扩容。<strong>多次扩容会造成性能损耗</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">list4Append := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    list4Append = <span class="built_in">append</span>(list4Append, i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;len:&quot;</span>, <span class="built_in">len</span>(list4Append),<span class="string">&quot;cap:&quot;</span>, <span class="built_in">cap</span>(list4Append))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<blockquote>
<p>len: 2 cap: 2<br>len: 3 cap: 4<br>len: 4 cap: 4<br>len: 5 cap: 8<br>len: 6 cap: 8<br>len: 7 cap: 8<br>len: 8 cap: 8<br>len: 9 cap: 16<br>len: 10 cap: 16<br>len: 11 cap: 16</p>
</blockquote>
</li>
<li><p><strong>如果切片生成自其他切片或数组，由于切片只是引用，对切片的修改可能会影响先前的切片&#x2F;数组。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numList = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="keyword">var</span> numSlice = numList[<span class="number">0</span>:<span class="number">1</span>]  <span class="comment">// [1]</span></span><br><span class="line">numSlice = <span class="built_in">append</span>(numSlice, <span class="number">5</span>)  <span class="comment">// 往切片[1]后插入一个元素5</span></span><br><span class="line">fmt.Println(numList, numSlice) <span class="comment">// [1,5,3,4] [1,5] 原数组发生了变化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numSlice2 = numList[:]</span><br><span class="line">numSlice2 = <span class="built_in">append</span>(numSlice2, <span class="number">6</span>)</span><br><span class="line">fmt.Println(numList, numSlice, numSlice2) <span class="comment">//  [1 5 3 4] [1 5] [1 5 3 4 6]</span></span><br></pre></td></tr></table></figure>
<p>numSlice是numLis的t引用，容量4，长度1。当append时，numSlice后面填充一个元素，实际上是修改了numList对应位置的内容。<br>numSlice2也是numList引用，容量4，长度4。当append时，容量变为8，但由于numList不能再添加元素，所以numList不变，而numList1元素只覆盖了前两个，也没有变化。</p>
</li>
</ul>
<h3 id="6-2-5-切片删除元素"><a href="#6-2-5-切片删除元素" class="headerlink" title="6.2.5 切片删除元素"></a>6.2.5 切片删除元素</h3><p>go并没有提供删除的方法，可以利用append实现删除，将删除点前后的slice连接，代码接6.2.4，<br>值得注意是的，当append后面接的是另一个slice时，参数后要加<code>...</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">numSlice2 = <span class="built_in">append</span>(numSlice2[:<span class="number">1</span>], numSlice2[<span class="number">2</span>:]...) <span class="comment">// [1 5 3 4 6]</span></span><br><span class="line">fmt.Println(numSlice2) <span class="comment">//[1,3,4,6]</span></span><br></pre></td></tr></table></figure>

<p>numSlice2的地址应该没变。</p>
<h2 id="6-2-映射map"><a href="#6-2-映射map" class="headerlink" title="6.2 映射map"></a>6.2 映射map</h2><p>map并非协程安全的，同一时刻只能有一个协程对map操作，可用sync包的 对map加锁 或 线程安全map ，但有性能损失。</p>
<h3 id="6-2-1-声明"><a href="#6-2-1-声明" class="headerlink" title="6.2.1 声明"></a>6.2.1 声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">map1 := <span class="keyword">map</span>[keyType] valueType</span><br></pre></td></tr></table></figure>
<h3 id="6-2-2-初始化"><a href="#6-2-2-初始化" class="headerlink" title="6.2.2 初始化"></a>6.2.2 初始化</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化方式1</span></span><br><span class="line"><span class="keyword">var</span> map1 = <span class="keyword">map</span>[keyType] valueType &#123;</span><br><span class="line">    key1:value1,</span><br><span class="line">    key2:value2,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化方式2，根据长度执行默认初始化</span></span><br><span class="line"><span class="keyword">var</span> map1 = <span class="built_in">make</span>(<span class="keyword">map</span>[keyType]valueType, mapCapacity)</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化方式2中，make可以指定map容量，map的多次扩充会低效，</li>
<li>cap()并不能获取map的容量，而len()可以获取map当前长度。</li>
</ul>
<h3 id="6-3-3-遍历"><a href="#6-3-3-遍历" class="headerlink" title="6.3.3 遍历"></a>6.3.3 遍历</h3><ul>
<li>单纯地range遍历map，每次遍历的结果可能不同，若想每次遍历出一样的结果，可以先取出所有键，再根据键遍历。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">score[<span class="string">&quot;he&quot;</span>] = <span class="number">20</span></span><br><span class="line">score[<span class="string">&quot;she&quot;</span>] = <span class="number">30</span></span><br><span class="line">score[<span class="string">&quot;they&quot;</span>] = <span class="number">40</span></span><br><span class="line">score[<span class="string">&quot;it&quot;</span>] = <span class="number">50</span></span><br><span class="line">fmt.Println(score)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(score))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> score &#123;  <span class="comment">// 每次结果不同</span></span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-3-4-删除键值对"><a href="#6-3-4-删除键值对" class="headerlink" title="6.3.4 删除键值对"></a>6.3.4 删除键值对</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(map1, key)</span><br></pre></td></tr></table></figure>
<p>Go语言没有为map提供清空所有元素的方法。并且delete内置函数置只用于map元素删除。</p>
<h2 id="range表达式"><a href="#range表达式" class="headerlink" title="range表达式"></a>range表达式</h2><p>用于容器的迭代</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> first, second := range map1 &#123;  </span><br><span class="line">    fmt.<span class="built_in">Println</span>(i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230506195133868.png" alt="image-20230506195133868"></p>
]]></content>
      <categories>
        <category>Golang</category>
        <category>Go基础</category>
      </categories>
  </entry>
  <entry>
    <title>ch3~5-基础</title>
    <url>/2023/11/f541b5c0766a/</url>
    <content><![CDATA[<h1 id="ch3变量"><a href="#ch3变量" class="headerlink" title="ch3变量"></a>ch3变量</h1><p>声明后一定要使用</p>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> &#123;</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b <span class="type">string</span></span><br><span class="line">    c <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Go会对每个变量对应内存初始化，有默认初始化类型。</p>
<ul>
<li>数字默认为0，bool默认false，切片、映射、函数默认为nil，字符串默认空字符串。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="type">int</span> = <span class="number">1</span> <span class="comment">// 标准初始化格式</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span> <span class="comment">// 编译器推导类型格式，会根据等号右边推导变量类型</span></span><br><span class="line">age := <span class="number">30</span> <span class="comment">// 短变量声明并初始化，使用较多，可同时给多个变量赋值</span></span><br><span class="line">age, sex := <span class="number">30</span>, <span class="literal">false</span> <span class="comment">// 但要保证左边至少有一个新变量，即未定义过的变量才能使用</span></span><br></pre></td></tr></table></figure>

<h3 id="变量交换"><a href="#变量交换" class="headerlink" title="变量交换"></a>变量交换</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a, b = b, a <span class="comment">// 从左到右依次赋值</span></span><br><span class="line">a, b, c := <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">c, a, b = a, b, c</span><br><span class="line">fmt.Println(a, b, c)</span><br></pre></td></tr></table></figure>

<h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h3><p>和python一样，是我比较喜欢的，经常用在函数返回。匿名变量不占用命名空间，<strong>无分配内存</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a, _ := function() <span class="comment">// 第二个返回值被匿名变量接收</span></span><br></pre></td></tr></table></figure>



<h2 id="3-2-数据类型"><a href="#3-2-数据类型" class="headerlink" title="3.2 数据类型"></a>3.2 数据类型</h2><p><code>reflect.TypeOf()</code>输出变量类型的字符串</p>
<h3 id="3-2-1-整型"><a href="#3-2-1-整型" class="headerlink" title="3.2.1 整型"></a>3.2.1 整型</h3><p><code>int8, int16, int32, int64</code></p>
<p><code>uint8, uint16, uint32, uint64</code></p>
<h3 id="3-2-2-浮点"><a href="#3-2-2-浮点" class="headerlink" title="3.2.2 浮点"></a>3.2.2 浮点</h3><p>仅支持两种浮点数：float32和float64。最大范围分别约为3.4e38 和 1.8e308</p>
<h3 id="3-2-4-字符和转义字符"><a href="#3-2-4-字符和转义字符" class="headerlink" title="3.2.4 字符和转义字符"></a>3.2.4 字符和转义字符</h3><ul>
<li>unit8：ASCII格式</li>
<li>rune：UTF格式，本质是int32类型</li>
</ul>
<h3 id="3-2-7-数据类型转换"><a href="#3-2-7-数据类型转换" class="headerlink" title="3.2.7 数据类型转换"></a>3.2.7 数据类型转换</h3><p>通过类型前置加小括号进行类型转换。但要注意转换后值是否会改变。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 <span class="type">int32</span> = <span class="number">1234567891</span> <span class="comment">// 0x499602d3</span></span><br><span class="line">fmt.Println(a1) <span class="comment">// 1234567891 0x499602d3</span></span><br><span class="line">fmt.Println(<span class="type">int16</span>(a1)) <span class="comment">// 723 0x02d3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针本身也是变量，所以也有地址</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> <span class="comment">// 默认nil</span></span><br></pre></td></tr></table></figure>

<h3 id="取地址-与-解引用"><a href="#取地址-与-解引用" class="headerlink" title="取地址 与 解引用"></a>取地址 与 解引用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line">p := &amp;a <span class="comment">//</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// 1</span></span><br><span class="line">*p = <span class="number">2</span> <span class="comment">// 修改值</span></span><br></pre></td></tr></table></figure>



<p>go指针和C语言指针的一些区别：</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/127940853">Go语言才是学习指针的安全之地，关于指针的二三事 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h1 id="ch4常量与运算符"><a href="#ch4常量与运算符" class="headerlink" title="ch4常量与运算符"></a>ch4常量与运算符</h1><h2 id="4-1-常量"><a href="#4-1-常量" class="headerlink" title="4.1 常量"></a>4.1 常量</h2><p>常量可以声明后不使用</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a <span class="type">int</span> = <span class="number">1</span> <span class="comment">// </span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span> <span class="comment">// 编译器推断</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    c = <span class="number">3.14</span></span><br><span class="line">    d		<span class="comment">// 3.14，沿用上一行</span></span><br><span class="line">    e = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h3><p>特殊常量<code>itoa</code>，其在const关键词出现时被重置为0，每新增一行常量声明，<code>itoa</code>进行一次计数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    a = itoa 	<span class="comment">// 0</span></span><br><span class="line">    b		    <span class="comment">// 0</span></span><br><span class="line">    c = <span class="string">&quot;hello&quot;</span>	<span class="comment">// &quot;hello&quot;</span></span><br><span class="line">    d  			<span class="comment">// &quot;hello&quot;</span></span><br><span class="line">    e = itoa 	<span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-2-运算符"><a href="#4-2-运算符" class="headerlink" title="4.2 运算符"></a>4.2 运算符</h2><p>比较少用到，但感觉比较重要的</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230506193025531.png" alt="image-20230506193025531"></p>
<h1 id="ch5-流程控制"><a href="#ch5-流程控制" class="headerlink" title="ch5 流程控制"></a>ch5 流程控制</h1><p>for和if和C一样，只是没有括号。但没有while循环，一个无条件的for即可。</p>
<p>break和continue都可以跟标签，指定continue或break哪个循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">OuterLoop:</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++ &#123;</span><br><span class="line">        fmt.Println(j)</span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span> OuterLoop <span class="comment">// 或者 break OuterLoop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><code>fallthrough</code>关键字：匹配成功，会强制执行后续的case。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="number">1</span> + <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;2&quot;</span>) <span class="comment">// 打印</span></span><br><span class="line">	<span class="keyword">fallthrough</span> </span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;3&quot;</span>) <span class="comment">// 打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="goto跳转"><a href="#goto跳转" class="headerlink" title="goto跳转"></a>goto跳转</h2><p>不建议使用，会破坏程序可读性</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">goto</span> mygotoflag</span><br><span class="line">fmt.Println(<span class="string">&quot;invalid line&quot;</span>)</span><br><span class="line">mygotoflag:</span><br><span class="line">	fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Golang</category>
        <category>Go基础</category>
      </categories>
  </entry>
  <entry>
    <title>ch7-函数</title>
    <url>/2023/11/142928f796c8/</url>
    <content><![CDATA[<h1 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h1><h2 id="7-1-函数声明"><a href="#7-1-函数声明" class="headerlink" title="7.1 函数声明"></a>7.1 函数声明</h2><ul>
<li>当返回值只有一个时，可以同时忽略返回值列表的<strong>括号</strong>和<strong>返回值变量名</strong>，但不能只忽略括号</li>
<li>当有返回值名时，在函数体内不用额外声明<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(parameterList)</span></span> (returnList) &#123;</span><br><span class="line">    <span class="comment">// func body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回列表声明可以省略，只有单个返回时返回列表括号也可以省略，</span></span><br><span class="line"><span class="comment">// 参数列表同类型也可以省略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>, z <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;       </span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回多个值， 回列表的声明可以省略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">specificValue</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>, <span class="type">string</span>) &#123;       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接返回 返回列表的默认值，此时返回列表的声明不能忽略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defaultValue</span><span class="params">()</span></span> (a <span class="type">int</span>, b <span class="type">float64</span>, c <span class="type">string</span>) &#123;      </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-3-函数变量"><a href="#7-3-函数变量" class="headerlink" title="7.3 函数变量"></a>7.3 函数变量</h2><p>Go中，函数也是一种<strong>类型</strong>，可以将其保存在<strong>变量</strong>中。个人感觉就是函数的别名。仅声明时，值为<code>nil</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> funcValue <span class="function"><span class="keyword">func</span><span class="params">(parameterList)</span></span>(returnList)</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">val funcValue = funcName</span><br><span class="line"><span class="comment">// 直接声明+赋值</span></span><br><span class="line">funcValue := funcName</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addAndSub</span><span class="params">(x, y <span class="type">int</span>)</span></span> (sum <span class="type">int</span>, sub <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y, x - y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f1 <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> (sum <span class="type">int</span>, sub <span class="type">int</span>)  <span class="comment">// 方式1</span></span><br><span class="line">    f1 = addAndSub</span><br><span class="line">    <span class="comment">//var f1 = addAndSub // 方式2</span></span><br><span class="line">    <span class="comment">//f1 := addAndSub // 方式3</span></span><br><span class="line">    sum, sub := f1(<span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">    fmt.Println(sum, sub)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-4-可变参数（本质切片）"><a href="#7-4-可变参数（本质切片）" class="headerlink" title="7.4 可变参数（本质切片）"></a>7.4 可变参数（本质切片）</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span> <span class="params">(固定参数列表, valueName ...Type)</span></span>(returnList)&#123;</span><br><span class="line">    <span class="comment">// func body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>固定参数列表可无，且可变参数一般在参数列表末尾</li>
<li>valueName …Type其实就是类型为Type的<strong>切片</strong>变量valueName，所以常会对切片遍历获取参数</li>
<li>go内置函数如<code>fmt.Printf()</code>和 <code>fmt.Println()</code>，都有可变参数<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endlessAdd</span><span class="params">(list ...<span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
函数里，如果想传可变参数，可以以<code>(valueName...)</code>传递<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endlessAddShell</span><span class="params">(list...<span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123;      </span><br><span class="line">    <span class="keyword">return</span> endlessAdd(list...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可变参数是切片，所以也可以以切片形式传递可变参数<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endlessAdd</span><span class="params">(list []<span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123; <span class="comment">// 切片为参数</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endlessAddShell</span><span class="params">(list...<span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123;   <span class="comment">// 可变参数</span></span><br><span class="line">    <span class="keyword">return</span> endlessAdd(list) <span class="comment">// 切片为参数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-5-匿名函数和闭包"><a href="#7-5-匿名函数和闭包" class="headerlink" title="7.5 匿名函数和闭包"></a>7.5 匿名函数和闭包</h2><h3 id="7-5-1-匿名函数"><a href="#7-5-1-匿名函数" class="headerlink" title="7.5.1 匿名函数"></a>7.5.1 匿名函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(parameterList)</span></span>(returnList) &#123;</span><br><span class="line">    <span class="comment">//func body</span></span><br><span class="line">    &#125;(parameter) <span class="comment">// 直接调用时可填，只定义不填</span></span><br></pre></td></tr></table></figure>
<ul>
<li>顾名思义，与普通函数的区别就是没有函数名</li>
<li>如果想在定义时直接调用，此时尾部直接加括号和参数<code>(parameter)</code></li>
<li>匿名函数也可以赋给一个变量，但此时不能被直接调用，<strong>注意赋值和调用有返回值的使用区别</strong><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名函数赋值给变量</span></span><br><span class="line">	a := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello &quot;</span> + data)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(a) <span class="comment">// 0x87df60 匿名函数变量地址</span></span><br><span class="line"><span class="comment">// 带返回值匿名函数调用</span></span><br><span class="line">	b := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello &quot;</span> + data)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;(<span class="string">&quot;world&quot;</span>) <span class="comment">// 主要区别就是有没有传参</span></span><br><span class="line">    fmt.Println(b)</span><br><span class="line">    <span class="comment">// fmt.Println(a(&quot;world&quot;))</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-5-2-闭包"><a href="#7-5-2-闭包" class="headerlink" title="7.5.2 闭包"></a>7.5.2 闭包</h3><p>函数嵌套函数，内部函数可以引用外部函数的参数和变量。参数和变量不会被回收。</p>
<p>好处：</p>
<ol>
<li>可以让一个变量长期在内存中不被释放</li>
<li>避免全局变量的污染，和全局变量不同，闭包中的变量无法被外部使用</li>
<li>私有成员的存在，无法被外部调用，只能直接内部调用</li>
</ol>
<ul>
<li>闭包就是包含了自由变量的匿名函数，而这自由变量脱离了原有自由变量环境也不会被删除，闭包作用域内仍然可以使用这个变量。（记忆力）</li>
<li>同一个匿名函数的不同引用环境构成不同闭包。</li>
<li>闭包会对作用域内变量的<strong>引用</strong>修改</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名函数在函数体内引用了外部变量num形成了闭包，闭包每次对num变量的引用修改</span></span><br><span class="line">num := <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num++ <span class="comment">// 修改了num变量</span></span><br><span class="line">    fmt.Println(&amp;num, num)  <span class="comment">// 0xc000016120 2</span></span><br><span class="line">&#125;() <span class="comment">// 加了()，直接调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := <span class="number">5</span> <span class="comment">// 匿名函数的内部变量</span></span><br><span class="line">    fmt.Println(&amp;num, num) <span class="comment">// 0xc000016128 5</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num++ <span class="comment">// 修改了num变量</span></span><br><span class="line">    fmt.Println(&amp;num, num)  <span class="comment">// 0xc000016120 3</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>另一个理解闭包的程序：<br>即便输入的是常数0（好像是叫无类型变量？），一个闭包的两次调用仍是对该变量0的引用修改。两个闭包互不影响。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="comment">// 参数为int，返回一个无参数的返回值为int的函数/闭包函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a1 := addOne(<span class="number">0</span>) <span class="comment">//定义变量创建了闭包实例，此后每次用a1()，都等价于调用addrOne内部的闭包函数，且参数为0，（注意a1无参数，因为addOne返回无参数的闭包函数）</span></span><br><span class="line">    fmt.Println(a1()) <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(a1()) <span class="comment">// 2</span></span><br><span class="line">    a2 := addOne(<span class="number">100</span>) <span class="comment">// 定义变量创建新的闭包实例</span></span><br><span class="line">    fmt.Println(a2())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-6-延迟执行语句"><a href="#7-6-延迟执行语句" class="headerlink" title="7.6 延迟执行语句"></a>7.6 延迟执行语句</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> 任意语句</span><br></pre></td></tr></table></figure>
<ul>
<li>defer语句会在其所属函数即将返回式，按照出现的顺序逆序被执行，通常用于释放资源</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="7-7-函数传递的本质"><a href="#7-7-函数传递的本质" class="headerlink" title="7.7 函数传递的本质"></a>7.7 函数传递的本质</h2><ul>
<li>值传递：传递的是变量的一个副本，改变这个副本不会实际改变原变量（可以通过传递变量的指针，修改原变量）。</li>
<li>引用传递：传递变量的地址，函数操作变量时会找到地址所保存的变量（这是自动的，而不是传递指针本身去操作指针）。</li>
</ul>
<p><strong>Go里面函数传参只有值传递一种方式</strong>。</p>
<p>但会分成两种情况：</p>
<ul>
<li>对于int，stirng，bool这种类型，传递的是变量的副本。原变量不会被改变。</li>
<li>对于指针、切片、map、channel、函数等变量存放的是一个内存地址值，传递的是原变量指针的副本，因此可以通过指针修改原变量。</li>
</ul>
<blockquote>
<p> <a href="https://blog.csdn.net/m0_71777195/article/details/125502836">切片作为函数参数是传值还是传引用</a></p>
</blockquote>
<p>demo：Go函数传参方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passByValue</span><span class="params">(num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;passByValue()-- num:%d,  &amp;num:%p\n&quot;</span>, num, &amp;num)</span><br><span class="line">	num = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passByPointer</span><span class="params">(nump *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;passByPointer()-- num:%d,  &amp;nump:%p,  &amp;nump:%p\n&quot;</span>, *nump, nump, &amp;nump)</span><br><span class="line">	*nump = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passSlice</span><span class="params">(slice1 []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;passSlice()-- slice1:%p &amp;slice1:%p \n&quot;</span>, slice1, &amp;slice1)</span><br><span class="line">	<span class="comment">//fmt.Println(&quot;passByPointer：&quot;, slice1, &amp;slice1)</span></span><br><span class="line">	slice1[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="number">3</span></span><br><span class="line">	nump := &amp;num</span><br><span class="line">	fmt.Printf(<span class="string">&quot;main()-- num:%d,  &amp;num或nump:%p,  &amp;nump:%p\n&quot;</span>, num, &amp;num, &amp;nump)</span><br><span class="line">	passByValue(num)</span><br><span class="line">	passByPointer(nump)</span><br><span class="line">	<span class="keyword">var</span> slice1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;main()-- slice1:%p &amp;slice1:%p \n&quot;</span>, slice1, &amp;slice1)</span><br><span class="line">	passSlice(slice1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<table>
<thead>
<tr>
<th align="center">main()</th>
<th align="center">num: 3</th>
<th align="center">&amp;num或nump: 0xc00001a0a8</th>
<th align="center">&amp;nump: 0xc00000a028</th>
</tr>
</thead>
<tbody><tr>
<td align="center">passByValue()</td>
<td align="center">num: 3</td>
<td align="center">&amp;num: 0xc00001a0e0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">passByPointer()</td>
<td align="center">*nump: 3</td>
<td align="center">nump: 0xc00001a0a8</td>
<td align="center">&amp;nump: 0xc00000a038</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>main()</th>
<th>slice1: 0xc00000e120</th>
<th>&amp;slice1: 0xc0000080a8</th>
</tr>
</thead>
<tbody><tr>
<td>passSlice()</td>
<td>slice1: 0xc00000e120</td>
<td>&amp;slice1: 0xc0000080a8</td>
</tr>
</tbody></table>
<ul>
<li>num传给<code>func passByValue(num int) </code>:由于是值传递，传递的是副本，所以函数内num的地址是和main中的num地址不同。</li>
<li>nump传给<code>func passByPointer(nump *int) </code>:在函数里，nump的值和main中nump相同，但nump的地址和main中不同，所以传的是num的指针的副本，仍是值传递。</li>
<li>slice1传给<code>passSlice(slice1 []int)</code>，实际上slice1这个变量存的就是切片地址，因此也是传递指针的副本，值传递。</li>
</ul>
<p><strong>修改副本不会影响原值，但如果副本本身存的是地址，可以通过改地址修改值。</strong></p>
]]></content>
      <categories>
        <category>Golang</category>
        <category>Go基础</category>
      </categories>
  </entry>
  <entry>
    <title>ch8-结构体</title>
    <url>/2023/11/7e766d57970e/</url>
    <content><![CDATA[<h1 id="第九章：结构体"><a href="#第九章：结构体" class="headerlink" title="第九章：结构体"></a>第九章：结构体</h1><p>go中没有类，但提供结构体，结构体和接口实现了面向对象的编程特征。</p>
<p>目前所理解的结构体，就是一种数据类型，因此可以创建多个实例。而匿名结构体是没有类型的，即不会用匿名结构体创建很多实例，只会有一个实例。</p>
<h2 id="9-2-定义结构体"><a href="#9-2-定义结构体" class="headerlink" title="9.2 定义结构体"></a>9.2 定义结构体</h2><p>关键词type自定义类型，而结构体本身是类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体名 <span class="keyword">struct</span>&#123;</span><br><span class="line">    成员变量<span class="number">1</span> 类型<span class="number">1</span></span><br><span class="line">    成员变量<span class="number">2</span>, 成员变量<span class="number">3</span> 类型<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>同一包不能重复结构体名</li>
<li>结构体、方法名、变量名的首字母为大写，表示可以导出，可以在当前包外访问。</li>
</ul>
<h2 id="9-3-实例化-声明结构体"><a href="#9-3-实例化-声明结构体" class="headerlink" title="9.3 实例化&#x2F;声明结构体"></a>9.3 实例化&#x2F;声明结构体</h2><p>实例化后可以通过<code>.</code>进行赋值。</p>
<p>结构体本身是一种数据类型，在实例化后才会真正分配内存，所以实例化会对内部成员执行默认初始化。</p>
<ul>
<li>var关键字实例化，返回结构体<strong>（不是指针类型）</strong><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例名 结构体名</span><br></pre></td></tr></table></figure></li>
<li>new函数实例化，返回结构体的<strong>指针类型</strong><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例名 = <span class="built_in">new</span>(结构体名)</span><br><span class="line">结构体实例名 := <span class="built_in">new</span>(结构体名)</span><br></pre></td></tr></table></figure></li>
<li>取地址实例化，实际上属于初始化，也<strong>返回结构体的指针类型</strong><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">结构体实例名 := &amp;结构体名&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-3-初始化结构体"><a href="#9-3-初始化结构体" class="headerlink" title="9.3 初始化结构体"></a>9.3 初始化结构体</h2><p>声明同时赋值</p>
<p>两者初始化方式，第一种较为繁琐；第二种需要按照成员变量定义<strong>顺序</strong>初始化，且必须初始化<strong>所有</strong>成员变量。两种方式<strong>不能混用</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">结构体实例名 := 结构体名&#123;</span><br><span class="line">    成员变量<span class="number">1</span>: 值<span class="number">1</span>,</span><br><span class="line">    成员变量<span class="number">1</span>: 值<span class="number">2</span>，</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">结构体实例名 := 结构体名&#123;</span><br><span class="line">    值<span class="number">1</span>,</span><br><span class="line">    值<span class="number">2</span>，</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="9-5-结构体方法"><a href="#9-5-结构体方法" class="headerlink" title="9.5 结构体方法"></a>9.5 结构体方法</h2><p>注意结构体方法和普通函数的不同：多了<strong>接收者</strong>的概念，个人理解为是调用该方法的主体实例。</p>
<p>定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者名 接收者类型)</span></span> funcName(para)(returnList) &#123;</span><br><span class="line">    <span class="comment">// func body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-5-1-指针类型与值类型接收者（重要）"><a href="#9-5-1-指针类型与值类型接收者（重要）" class="headerlink" title="9.5.1 指针类型与值类型接收者（重要）"></a>9.5.1 指针类型与值类型接收者（重要）</h3><ul>
<li><p>当<strong>接收者</strong>类型为（结构体）指针，使用<strong>指针&#x2F;非指针</strong>类型实例（结构体）调用该函数，可以改变成员变量值。</p>
</li>
<li><p>接收者类型为值，即便使用指针调用函数，也不能改编成员变量的值。</p>
</li>
</ul>
<p><strong>接收者</strong>类型为是在结构体方法定义时，接收者是否为指针；<strong>指针&#x2F;非指针</strong>类型实例是指调用这个方法的结构体是否为指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指针类型接收者</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> book <span class="keyword">struct</span> &#123;</span><br><span class="line">	bookId    <span class="type">uint</span></span><br><span class="line">	bookTitle <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者，即使调用者不是指针，也能改变成员</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(book1 *book)</span></span> changeTitle() &#123;</span><br><span class="line">	book1.bookTitle = <span class="string">&quot;golang&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值接收者，无论如何都无法改变book1的成员</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(book1 book)</span></span> changeId() &#123;</span><br><span class="line">	book1.bookId = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> book1 book  <span class="comment">// 返回结构体</span></span><br><span class="line">	book1.changeTitle() <span class="comment">// 由于定义时是指针接收者，可以改变成员</span></span><br><span class="line">	book1.changeId() <span class="comment">// 由于定义时是值接收者，即使是结构体指针调用，也无法改变成员</span></span><br><span class="line">	fmt.Println(book1)</span><br><span class="line"></span><br><span class="line">	book2 := <span class="built_in">new</span>(book)  <span class="comment">// 返回结构体指针</span></span><br><span class="line">	book2.changeTitle() <span class="comment">// 由于定义时是指针接收者，可以改变成员</span></span><br><span class="line">	book2.changeId()    <span class="comment">// 由于定义时是值接收者，即使是结构体指针调用，也无法改变成员</span></span><br><span class="line">	fmt.Println(book2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>{0 golang}<br>&amp;{0 golang}</p>
</blockquote>
<h2 id="9-6-结构体内嵌"><a href="#9-6-结构体内嵌" class="headerlink" title="9.6 结构体内嵌"></a>9.6 结构体内嵌</h2><p>套娃，可以构建一种继承的关系。结构体实例化后，可以访问其内嵌结构体的所有成员变量和方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">	bookId    <span class="type">uint</span></span><br><span class="line">	bookTitle <span class="type">string</span></span><br><span class="line">	price     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">type</span> BookBorrow <span class="keyword">struct</span> &#123;</span><br><span class="line">	Book  <span class="comment">// 内嵌结构体</span></span><br><span class="line">    <span class="comment">// book Book // 注释写法</span></span><br><span class="line">	borrowTime <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化结构体内嵌</span></span><br><span class="line">    bookBorrow1 := &amp;BookBorrow&#123;</span><br><span class="line">		Book: Book&#123;<span class="number">1</span>, <span class="string">&quot;golang&quot;</span>, <span class="number">1</span>&#125;, <span class="comment">// 写法---1</span></span><br><span class="line">        <span class="comment">// book: Book&#123;1, &quot;golang&quot;, 1&#125;, // 写法---2</span></span><br><span class="line">		borrowTime: <span class="string">&quot;today&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按照写法1可以直接修改price，写法1相当于直接将book结构体实例的成员放入BookBorrow，而没有在BookBorrow里给Book结构体实例命名</span></span><br><span class="line">	bookBorrow1.borrowTime = <span class="string">&quot;tomorrow&quot;</span></span><br><span class="line">	bookBorrow1.price = <span class="number">10</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是按写法2，不能忽略book，因为Book结构体实例已经被命名成book</span></span><br><span class="line">    <span class="comment">// bookBorrow1.book.price = 10 // 写法2</span></span><br><span class="line">	<span class="built_in">println</span>(bookBorrow1) <span class="comment">// &amp;&#123;&#123;1 golang 10&#125; tomorrow&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-7-匿名结构体"><a href="#9-7-匿名结构体" class="headerlink" title="9.7 匿名结构体"></a>9.7 匿名结构体</h2><p>匿名结构体无需type关键词，但在定义时要创建对象（而普通结构体可以只定义）。</p>
<p>其实就是没有结构体的<strong>定义</strong>，匿名结构体的定义和变量一样，所以至少会默认初始化创建。</p>
<p>只不过其缺点就是无法复用，再定义一个完全一样的结构体，要重新把结构体的成员重新写一次，所以不推荐在需要多个结构体实例时使用。</p>
<p>匿名结构体有其使用场景：组织全局变量、构建数据模板和解析JSON。<br><a href="https://zhuanlan.zhihu.com/p/444072574">一文读懂Go语言匿名结构体使用场景 - 知乎 (zhihu.com)</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">结构体实例 := <span class="keyword">struct</span>&#123;</span><br><span class="line">    成员<span class="number">1</span> 类型<span class="number">1</span></span><br><span class="line">    成员<span class="number">2</span> 类型<span class="number">2</span></span><br><span class="line">&#125; &#123;</span><br><span class="line">    成员<span class="number">1</span>: 值<span class="number">1</span>,</span><br><span class="line">    成员<span class="number">2</span>: 值<span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> 结构体实例 <span class="keyword">struct</span>&#123;</span><br><span class="line">    成员<span class="number">1</span> 类型<span class="number">1</span></span><br><span class="line">    成员<span class="number">2</span> 类型<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再用. 赋值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unanimous_struct = <span class="keyword">struct</span> &#123;</span><br><span class="line">   bookId    <span class="type">uint</span></span><br><span class="line">   bookTitle <span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">   <span class="number">1</span>,</span><br><span class="line">   <span class="string">&quot;unanimous&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(unanimous_struct)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Golang</category>
        <category>Go基础</category>
      </categories>
  </entry>
  <entry>
    <title>Docker基础教程</title>
    <url>/2023/11/2978ee3a4e31/</url>
    <content><![CDATA[<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.bilibili.com/video/BV1HP4118797/?spm_id_from=333.337.search-card.all.click&vd_source=9883419bb9939eb61834a63a38921b19">https://www.bilibili.com/video/BV1HP4118797/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9883419bb9939eb61834a63a38921b19</a></p>
<h1 id="Docker基础教程"><a href="#Docker基础教程" class="headerlink" title="Docker基础教程"></a>Docker基础教程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>使用Docker安装应用时会从镜像仓库自动下载镜像image，镜像包含应用本身，还包含应用运行所需的环境、配置、系统函数库。镜像仓库由docker官方管理。</p>
<p>也就是镜像可以忽略操作系统的差异直接部署。</p>
<p>Docker运行image会创建一个隔离环境，即容器container。多个容器是互不干扰的。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231123103249728.png" alt="image-20231123103249728"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>linux版本centOS 7，对应官方文档</p>
<blockquote>
<p><a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
</blockquote>
<p>安装教程</p>
<blockquote>
<p><a href="https://b11et3un53m.feishu.cn/wiki/Rfocw7ctXij2RBkShcucLZbrn2d">https://b11et3un53m.feishu.cn/wiki/Rfocw7ctXij2RBkShcucLZbrn2d</a></p>
</blockquote>
<p>1、安装yum（centOS已有），并配置仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>2、安装docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>

<p>3、启动和关闭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps <span class="comment"># 不报错则安装成功</span></span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl stop docker</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> docker <span class="comment"># 设置开启自启</span></span><br></pre></td></tr></table></figure>

<p>4、配置镜像加速</p>
<p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p>
<h2 id="demo-部署mysql"><a href="#demo-部署mysql" class="headerlink" title="demo: 部署mysql"></a>demo: 部署mysql</h2><h3 id="下载并安装image"><a href="#下载并安装image" class="headerlink" title="下载并安装image"></a>下载并安装image</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \ <span class="comment"># 创建并运行 -d使得容器在后台运行</span></span><br><span class="line">--name mysql \  <span class="comment"># 容器名称</span></span><br><span class="line">-p 3306:3306 \  <span class="comment"># 端口映射</span></span><br><span class="line">-e TZ=Asia/Shanghai \  <span class="comment"># 环境变量 -e KEY=VALUE，不同镜像不同，需要查看镜像的文档说明</span></span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123 \ </span><br><span class="line">mysql \  <span class="comment"># 镜像的名字 [仓库]:[版本号]，无版本号就是最新版本</span></span><br></pre></td></tr></table></figure>

<p>端口映射：</p>
<ul>
<li>端口映射：容器由于是独立的，拥有自己的文件系统、内存空间、网络空间，也有自己的IP，但是是对外隔离的，所以当主机ping容器的ip时，是无法访问的，因此可以端口映射，将虚拟机的3306端口映射到容器的3306端口。</li>
<li>mysql的端口永远是3306，但宿主机进行端口映射的端口可以不是3306，比如<code>-p 3310:3306</code>。</li>
</ul>
<h3 id="navicat连接数据库："><a href="#navicat连接数据库：" class="headerlink" title="navicat连接数据库："></a>navicat连接数据库：</h3><p>1、由于使用虚拟机，此处要使用SSH连接虚拟机，注意，此处的虚拟机和主机采用桥接模式，同属一个内网中。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231123214213515.png" alt="image-20231123214213515"></p>
<p>2、进行数据库的连接</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231123214624203.png" alt="image-20231123214624203"></p>
<blockquote>
<p>memo：数据库账号是root（默认），密码123456，CentOS账号wallnut，密码生日。</p>
</blockquote>
<p>3、连接成功</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231123214946891.png" alt="image-20231123214946891"></p>
<h2 id="镜像、容器常见命令"><a href="#镜像、容器常见命令" class="headerlink" title="镜像、容器常见命令"></a>镜像、容器常见命令</h2><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231123104353877.png" alt="image-20231123104353877"></p>
<p>（注：DockerFile用于定制镜像，左下是将镜像存储并加载）</p>
<p>区分镜像和容器，可以类比为程序和进程。</p>
<h3 id="查看已有镜像"><a href="#查看已有镜像" class="headerlink" title="查看已有镜像"></a>查看已有镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost network-scripts]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        latest    a6bd71f48f68   2 days ago      187MB</span><br><span class="line">mysql        5.7       bdba757bc933   4 weeks ago     501MB</span><br><span class="line">mysql        latest    3218b38490ce   23 months ago   516MB</span><br></pre></td></tr></table></figure>



<h3 id="从远端仓库拉取镜像-pull"><a href="#从远端仓库拉取镜像-pull" class="headerlink" title="从远端仓库拉取镜像 pull"></a>从远端仓库拉取镜像 pull</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>



<h3 id="保存镜像到本地-save"><a href="#保存镜像到本地-save" class="headerlink" title="保存镜像到本地 save"></a>保存镜像到本地 save</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o nginx.tar nginx:latest <span class="comment"># 注意要把版本号TAG也放上，因为可能有不同的版本号但相同的Repository</span></span><br></pre></td></tr></table></figure>



<h3 id="删除本地镜像-rmi"><a href="#删除本地镜像-rmi" class="headerlink" title="删除本地镜像 rmi"></a>删除本地镜像 rmi</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi nginx:latest <span class="comment"># 注意要把版本号TAG也放上，因为可能有不同的版本号但相同的Repository</span></span><br></pre></td></tr></table></figure>



<h3 id="加载本地镜像-load"><a href="#加载本地镜像-load" class="headerlink" title="加载本地镜像 load"></a>加载本地镜像 load</h3><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker load -i nginx.tar</span><br><span class="line"><span class="number">92770</span>f546e06: Loading layer [==================================================&gt;]  <span class="number">77.87</span>MB/<span class="number">77.87</span>MB</span><br><span class="line"><span class="number">8</span>ae474e0cc8f: Loading layer [==================================================&gt;]  <span class="number">113.1</span>MB/<span class="number">113.1</span>MB</span><br><span class="line">f5525891d9e9: Loading layer [==================================================&gt;]  <span class="number">3.584</span>kB/<span class="number">3.584</span>kB</span><br><span class="line"><span class="number">66283570</span>f41b: Loading layer [==================================================&gt;]  <span class="number">4.608</span>kB/<span class="number">4.608</span>kB</span><br><span class="line">c2d3ab485d1b: Loading layer [==================================================&gt;]   <span class="number">2.56</span>kB/<span class="number">2.56</span>kB</span><br><span class="line">cddc309885a2: Loading layer [==================================================&gt;]   <span class="number">5.12</span>kB/<span class="number">5.12</span>kB</span><br><span class="line"><span class="number">0</span>d0e9c83b6f7: Loading layer [==================================================&gt;]  <span class="number">7.168</span>kB/<span class="number">7.168</span>kB</span><br></pre></td></tr></table></figure>



<h3 id="运行本地镜像-run"><a href="#运行本地镜像-run" class="headerlink" title="运行本地镜像 run"></a>运行本地镜像 run</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name nginx -p 80:80 nginx</span><br><span class="line">0cb11aaca245abc658a96c7ad05f731678f3570419d856773013e83e7f4225ad</span><br></pre></td></tr></table></figure>



<h3 id="查看已有容器-ps"><a href="#查看已有容器-ps" class="headerlink" title="查看已有容器 ps"></a>查看已有容器 ps</h3><p>可用参数<code>format</code>指定输出格式，参数<code>-a</code>使用时，显示所有容器；否则仅显示正在运行的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line">docker ps</span><br><span class="line">docker ps --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line">CONTAINER ID   IMAGE       PORTS                                                  STATUS        NAMES</span><br><span class="line">0cb11aaca245   nginx       0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp                      Up 2 hours    nginx</span><br><span class="line">563cc50d335e   mysql:5.7   0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   Up 17 hours   mysql</span><br></pre></td></tr></table></figure>

<h4 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h4><p>由于format指定输出格式的指令非常长，如果经常使用，可以设置一个命令别名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/.bashrc</span><br><span class="line"><span class="comment"># 添加：</span></span><br><span class="line"><span class="comment"># alias dpsf=&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">dpsf</span><br></pre></td></tr></table></figure>



<h3 id="关闭容器-stop"><a href="#关闭容器-stop" class="headerlink" title="关闭容器 stop"></a>关闭容器 stop</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop nginx</span><br></pre></td></tr></table></figure>



<h3 id="运行容器-start"><a href="#运行容器-start" class="headerlink" title="运行容器 start"></a>运行容器 start</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start nginx</span><br></pre></td></tr></table></figure>



<h3 id="日志-logs"><a href="#日志-logs" class="headerlink" title="日志 logs"></a>日志 logs</h3><p>参数<code>-f</code>使用时，持续跟踪日志，否则只打印历史日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -f nginx </span><br></pre></td></tr></table></figure>



<h3 id="进入容器执行-exec"><a href="#进入容器执行-exec" class="headerlink" title="进入容器执行 exec"></a>进入容器执行 exec</h3><p> <code>-it</code>:可交互终端 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost network-scripts] docker <span class="built_in">exec</span> -it nginx bash</span><br><span class="line">root@0cb11aaca245:/ <span class="built_in">ls</span></span><br><span class="line">bin   dev		   docker-entrypoint.sh  home  lib32  libx32  mnt  proc  run   srv  tmp  var</span><br><span class="line">boot  docker-entrypoint.d  etc			 lib   lib64  media   opt  root  sbin  sys  usr</span><br></pre></td></tr></table></figure>

<p>退出容器执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>



<h3 id="删除容器-rm"><a href="#删除容器-rm" class="headerlink" title="删除容器 rm"></a>删除容器 rm</h3><p>被删除的容器要先停止运行stop，除非使用<code>-f</code>强制删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> nginx</span><br></pre></td></tr></table></figure>



<h2 id="部署nginx遇到的问题"><a href="#部署nginx遇到的问题" class="headerlink" title="部署nginx遇到的问题"></a>部署nginx遇到的问题</h2><p>虚拟机可以通过curl访问已部署的nginx容器，但宿主机既不能通过curl访问，也不能通过浏览器访问该ip。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl 172.31.226.34</span><br></pre></td></tr></table></figure>

<p>原因：虚拟机防火墙未关闭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld <span class="comment"># 如果是active 就是未关闭</span></span><br><span class="line">systemctl stop firewalld.service <span class="comment"># 关闭即可解决</span></span><br><span class="line">systemctl restart docker <span class="comment"># 重启docker</span></span><br></pre></td></tr></table></figure>



<h2 id="数据卷挂载"><a href="#数据卷挂载" class="headerlink" title="数据卷挂载"></a>数据卷挂载</h2><p>为什么需要数据卷：若想修改容器内的文件，使用exec命令进入容器的bash后，发现无法使用vi修改其中的文件，原因是容器只提供了最小化的系统环境，而vi不是必要的。</p>
<p>数据卷volume：虚拟目录，容器内目录和宿主机目录之间映射的桥梁。</p>
<p>即便容器删了，数据仍会保存在虚拟机中。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231124153318786.png" alt="image-20231124153318786"></p>
<p>挂载数据卷要在容器运行时进行挂载，正在运行的容器不能再挂载数据卷。容器运行时，若不指定挂载名，会自动创建数据卷。</p>
<h3 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h3><p><img src="C:/Users/wallnut/AppData/Roaming/Typora/typora-user-images/image-20231124154230723.png" alt="image-20231124154230723"></p>
<h3 id="demo：利用nginx部署静态资源"><a href="#demo：利用nginx部署静态资源" class="headerlink" title="demo：利用nginx部署静态资源"></a>demo：利用nginx部署静态资源</h3><ul>
<li>创建nginx容器，并修改html目录下的index.html文件</li>
<li>将静态资源部署到html目录。</li>
</ul>
<h4 id="1、运行容器时挂载数据卷"><a href="#1、运行容器时挂载数据卷" class="headerlink" title="1、运行容器时挂载数据卷"></a>1、运行容器时挂载数据卷</h4><p>参数<code>-v 数据卷名：容器内目录</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx</span><br></pre></td></tr></table></figure>

<h4 id="2、查看挂载的数据卷"><a href="#2、查看挂载的数据卷" class="headerlink" title="2、查看挂载的数据卷"></a>2、查看挂载的数据卷</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     d156f43095144e073085f20b9d0d2ca802e81358b99fe6273e3420ec6338ccdf</span><br><span class="line"><span class="built_in">local</span>     db24dc659d6f0dfd0aa3d931561e585b2cf393c636dda5b3967720131175e285</span><br><span class="line"><span class="built_in">local</span>     e90f11091bc53a779f4a6f5b6ec12d0ef0e2aa2fb40ffe6c6181e09ffc17ad2d</span><br><span class="line"><span class="built_in">local</span>     ffc104a40519463581ffa58433e95225ed93894cfdb44d3d1400b2a3e66ffabb</span><br><span class="line"><span class="built_in">local</span>     html</span><br></pre></td></tr></table></figure>

<h4 id="3、查看html数据卷详细信息"><a href="#3、查看html数据卷详细信息" class="headerlink" title="3、查看html数据卷详细信息"></a>3、查看html数据卷详细信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume inspect html</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2023-11-23T23:46:58-08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,  <span class="comment"># 虚拟机目录</span></span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>至此，虚拟机目录<code>&quot;/var/lib/docker/volumes/html/_data&quot;</code>和html数据卷映射，html数据卷又和容器目录<code>/usr/share/nginx/html</code>映射</p>
<h4 id="4、修改html文件或添加静态资源"><a href="#4、修改html文件或添加静态资源" class="headerlink" title="4、修改html文件或添加静态资源"></a>4、修改html文件或添加静态资源</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /var/lib/docker/volumes/html/_data/index.html</span><br></pre></td></tr></table></figure>



<h2 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h2><p>用于数据的迁移，例如原本的mysql进行版本升级，所以需要新版本mysql的容器，并把原始数据迁移到新的mysql。</p>
<h3 id="demo："><a href="#demo：" class="headerlink" title="demo："></a>demo：</h3><p>当前mysql的挂载信息，名字很长一串，这是在run是默认时，随机生成的数据卷，称为匿名卷。可以看到虚拟机目录<code>/var/lib/docker/volumes/d156f43095144e073085f20b9d0d2ca802e81358b99fe6273e3420ec6338ccdf/_data/mysql</code>存放了mysql的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect mysql</span><br><span class="line"><span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;d156f43095144e073085f20b9d0d2ca802e81358b99fe6273e3420ec6338ccdf&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/d156f43095144e073085f20b9d0d2ca802e81358b99fe6273e3420ec6338ccdf/_data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/var/lib/mysql&quot;</span>,</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost wallnut]<span class="comment"># cd /var/lib/docker/volumes/d156f43095144e073085f20b9d0d2ca802e81358b99fe6273e3420ec6338ccdf/_data</span></span><br><span class="line">[root@localhost _data]<span class="comment"># ls</span></span><br><span class="line">auto.cnf         client-key.pem  ib_logfile1         private_key.pem  sys</span><br><span class="line">ca-key.pem       ib_buffer_pool  mysql               public_key.pem</span><br><span class="line">ca.pem           ibdata1         mysql.sock          server-cert.pem</span><br><span class="line">client-cert.pem  ib_logfile0     performance_schema  server-key.pem</span><br></pre></td></tr></table></figure>

<p><del>使用navicat为该数据库创建一个数据库pvz和一个wallnut表，用于后续数据迁移的验证。</del></p>
<p>目录挂载和数据卷挂载使用docker run命令时挂载，参数<code>-v 本地目录:容器内目录</code>。注意，本地目录要以<code>/</code>或<code>./</code>开头，即要以绝对路径和相对路径开头，否则会被识别为数据卷。</p>
<p>此外还需要挂载配置文件、初始化脚本，感觉较难用上此处不做深入（视频P8）。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231124203920577.png" alt="image-20231124203920577"></p>
<h2 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h2><p>镜像包含了应用程序、程序运行的系统函数库、运行配置等文件的文件包。构建自定义镜像就是把上述文件打包的过程。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231126100645222.png" alt="image-20231126100645222"></p>
<h3 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h3><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231126101316105.png" alt="image-20231126101316105"></p>
<p>分层，好处是可以共享某些基础层，不必重复构建。例如在安装了mysql镜像后，安装redis镜像，可见层<code>1f7ce2fa46ab</code>已存在。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost wallnut]<span class="comment"># docker pull redis</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/redis</span><br><span class="line">1f7ce2fa46ab: Already exists  <span class="comment">#当前层已存在</span></span><br><span class="line">3c6368585bf1: Pull complete </span><br><span class="line">3911d271d7d8: Pull complete </span><br><span class="line">ac88aa9d4021: Pull complete </span><br><span class="line">127cd75a68a2: Pull complete </span><br><span class="line">4f4fb700ef54: Pull complete </span><br><span class="line">f3993c1104fc: Pull complete </span><br><span class="line">Digest: sha256:2976bc0437deff693af2dcf081a1d1758de8b413e6de861151a5a136c25eb9e4</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> redis:latest</span><br><span class="line">docker.io/library/redis:latest</span><br></pre></td></tr></table></figure>



<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>自定义镜像时不需要自己找，而是使用Dockerfile中的指令说明要什么操作来构建镜像。</p>
<h4 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h4><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231126101454693.png" alt="image-20231126101454693"></p>
<h4 id="demo：-1"><a href="#demo：-1" class="headerlink" title="demo："></a>demo：</h4><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231126101938554.png" alt="image-20231126101938554"></p>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>有了dockerfile后，使用命令构建镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t myImage:1.0 . </span><br><span class="line"><span class="comment">#docker built -t repository:tag dockerfile路径（最好是相对路径）</span></span><br></pre></td></tr></table></figure>

<h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>1、加载本地镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost demo]<span class="comment"># ls</span></span><br><span class="line">demo  jdk.tar  mysql.tar  nginx.tar</span><br><span class="line">[root@localhost demo]<span class="comment"># docker load -i jdk.tar</span></span><br><span class="line">2c7e7ab2260a: Loading layer  119.3MB/119.3MB</span><br><span class="line">9ad2165feb02: Loading layer  17.18MB/17.18MB</span><br><span class="line">92903c3857f8: Loading layer  17.87MB/17.87MB</span><br><span class="line">1736ab871b32: Loading layer  12.18MB/12.18MB</span><br><span class="line">6f8e4cb95a88: Loading layer  3.584kB/3.584kB</span><br><span class="line">41080a0c646f: Loading layer  141.8MB/141.8MB</span><br><span class="line">Loaded image: openjdk:11.0-jre-buster</span><br></pre></td></tr></table></figure>

<p>2、进入demo目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost demo]<span class="comment"># cd demo</span></span><br><span class="line">[root@localhost demo]<span class="comment"># docker build -t docker-demo .</span></span><br><span class="line">[+] Building 0.4s (8/8) FINISHED                                                            docker:default</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                     0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                       0.0s</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                                  0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 358B                                                                  0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/openjdk:11.0-jre-buster                            0.0s</span><br><span class="line"> =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster                                              0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                                     0.1s</span><br><span class="line"> =&gt; =&gt; transferring context: 17.70MB                                                                  0.1s</span><br><span class="line"> =&gt; [2/3] RUN <span class="built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span> Asia/Shanghai &gt; /etc/  0.2s</span><br><span class="line"> =&gt; [3/3] COPY docker-demo.jar /app.jar                                                               0.1s</span><br><span class="line"> =&gt; exporting to image                                                                                0.1s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                               0.1s</span><br><span class="line"> =&gt; =&gt; writing image sha256:ca7a0e87318bc12fbc68314cdfb4ba2b97eaea92ee4c12d88716b46c1cde27bb          0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/docker-demo                                                        0.0s</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231126103909950.png" alt="image-20231126103909950"></p>
<p>3、运行镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name docker_demo -p 8080:8080 docker-demo <span class="comment"># 8080是代码中指定的端口号，此处无需关心</span></span><br></pre></td></tr></table></figure>

<p>4、访问<code>172.31.226.34:8080</code></p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231126104206361.png" alt="image-20231126104206361"></p>
<h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p><code>docker inspect 容器名</code>中的networks字段即可看到该容器的ip地址。默认情况下，所有容器以bridge方式连接到docker的一个虚拟网桥</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231127172334735.png" alt="image-20231127172334735"></p>
<p>虽然这些容器同属一个网桥，可以相互通信，但这些ip是由docker按顺序分配的，一旦docker重启，容器启动顺序改变，这些容器的ip地址可能不同，容器之间相互通信的地址要重新设置。</p>
<h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><p>加入自定义网络的容器可以通过<strong>容器名</strong>互相访问</p>
<h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231127181037711.png" alt="image-20231127181037711"></p>
<h4 id="demo：-2"><a href="#demo：-2" class="headerlink" title="demo："></a>demo：</h4><ul>
<li>第一步：创建网络mynetwork，并使自定义镜像时创建的docker_demo容器加入网络。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost mysql]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">0c5ff379beb7   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">68f4a61a71b2   host      host      <span class="built_in">local</span></span><br><span class="line">b27cc43b8cba   none      null      <span class="built_in">local</span></span><br><span class="line">[root@localhost mysql]<span class="comment"># docker network create mynetwork</span></span><br><span class="line">04da59f0180192d722d3846b4eaa6d7df3d4ae35df510412cf1bef9196036630</span><br><span class="line">[root@localhost mysql]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID     NAME        DRIVER    SCOPE</span><br><span class="line">0c5ff379beb7   bridge      bridge    <span class="built_in">local</span></span><br><span class="line">68f4a61a71b2   host        host      <span class="built_in">local</span></span><br><span class="line">04da59f01801   mynetwork   bridge    <span class="built_in">local</span></span><br><span class="line">b27cc43b8cba   none        null      <span class="built_in">local</span></span><br><span class="line">[root@localhost mysql]<span class="comment"># docker network connect mynetwork docker_demo</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第二步，将nginx在运行时加入网络mynetwork</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name 镜像名 -p 8080:8080 --network 容器名</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost mysql]<span class="comment"># docker rm -f nginx</span></span><br><span class="line">nginx</span><br><span class="line">[root@localhost mysql]<span class="comment"># docker run -d --name nginx -p 80:80 --network mynetwork nginx</span></span><br><span class="line">ee0f915f6e398eaba6cc95665f23d2380492e22b02a709ad2adbf9a2a7754665</span><br></pre></td></tr></table></figure>

<ul>
<li>第三步，进入docker_demo容器执行bash，并通过容器名ping nginx</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost mysql]<span class="comment"># docker exec -it docker_demo bash</span></span><br><span class="line">root@f0e9ba9a7278:/<span class="comment"># ping nginx</span></span><br><span class="line">PING nginx (172.18.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from nginx.mynetwork (172.18.0.3): icmp_seq=1 ttl=64 time=0.191 ms</span><br><span class="line">64 bytes from nginx.mynetwork (172.18.0.3): icmp_seq=2 ttl=64 time=0.142 ms</span><br></pre></td></tr></table></figure>



<h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>由于不是java选手，无法将java项目打包，此处暂时没做。</p>
<h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><p>通过一个单独的docker-compuse.yml模板文件定义一组相关联的应用容器，帮助我们实现多个相关联docker容器的快速部署。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231127190855534.png" alt="image-20231127190855534"></p>
<p>语法和docker run 命令几乎类似。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231127191013928.png" alt="image-20231127191013928"></p>
<h3 id="docker语法详解"><a href="#docker语法详解" class="headerlink" title="docker语法详解"></a>docker语法详解</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span>  <span class="comment"># 容器</span></span><br><span class="line">  <span class="attr">mysql:</span>   <span class="comment"># mysql 容器</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span>  <span class="comment"># 来自mysql镜像</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span> </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">  <span class="attr">hmall:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line"><span class="attr">networks:</span>  <span class="comment"># 网络</span></span><br><span class="line">  <span class="attr">hm-net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure>

<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20231127191800774.png" alt="image-20231127191800774"></p>
<h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><blockquote>
<p>[root@localhost &#x2F;]# docker images<br>Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?</p>
</blockquote>
<p>解决方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Fyne——基于go的GUI库</title>
    <url>/2023/12/0be9c79d0522/</url>
    <content><![CDATA[<h1 id="Fyne"><a href="#Fyne" class="headerlink" title="Fyne"></a>Fyne</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>一种基于Go的GUI。Golang的GUI没接触过，也有挺多库可用，选择Fyne的原因是star比较多，但Fyne的中文文档并不全面。本篇文章不会完整介绍Fyne的所有组件，主要是总结一下使用Fyne过程中对该库的一些个人理解。</p>
<blockquote>
<p><a href="https://github.com/fyne-io/fyne">fyne-io&#x2F;fyne: Cross platform GUI toolkit in Go inspired by Material Design (github.com)</a></p>
<p><a href="https://go-circle.cn/fyne-press/v1.0/1-getting-started/introduction.html">快速开始 | Fyne 开发文档 (go-circle.cn)</a></p>
</blockquote>
<h2 id="Fyne的安装"><a href="#Fyne的安装" class="headerlink" title="Fyne的安装"></a>Fyne的安装</h2><p>需求：</p>
<ul>
<li>golang（已满足）</li>
<li>C编译器</li>
<li>显卡驱动（已满足）</li>
</ul>
<p>C编译器官方文档给出了3种安装方式，但不论哪种都需要配置环境变量。否则会在编译Fyne库时会报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span>:<span class="string">&quot;gcc&quot;</span> executable file not found <span class="keyword">in</span> %PATH%</span><br></pre></td></tr></table></figure>

<p>我选择的是TDM-GCC <a href="https://jmeubank.github.io/tdm-gcc/download/">Download | tdm-gcc (jmeubank.github.io)</a>。</p>
<p>环境变量：安装时记住安装的路径，例如<code>C:\TDM-GCC-64</code>，并复制<code>gcc.exe</code>所在所在路径，即<code>C:\TDM-GCC-64\bin</code>，最后在设置环境变量时，在系统变量<code>Path</code>中新增一项bin文件的路径即可。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231224174710186.png" alt="image-20231224174710186"></p>
<h2 id="几个关键概念"><a href="#几个关键概念" class="headerlink" title="几个关键概念"></a>几个关键概念</h2><ul>
<li>窗口<code>Window</code>，略。</li>
<li>画布<code>Canvas</code>，一个窗口有一个画布。</li>
<li>画布对象<code>CanvasObject</code>，可用被放到画布上展示的元素。</li>
<li>容器<code>Container</code>，一次存放多个画布对象的画布对象。</li>
<li>布局<code>Layout</code>，规定了容器内的各个画布对象的尺寸与位置。</li>
</ul>
<h2 id="几个关键接口概览"><a href="#几个关键接口概览" class="headerlink" title="几个关键接口概览"></a>几个关键接口概览</h2><h3 id="CanvasObject接口"><a href="#CanvasObject接口" class="headerlink" title="CanvasObject接口"></a>CanvasObject接口</h3><p><code>CanvasObject</code>接口描述了一个可以被加到画布<code>canvas</code>的对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CanvasObject <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// geometry</span></span><br><span class="line">	<span class="comment">// MinSize returns the minimum size this object needs to be drawn.</span></span><br><span class="line">	MinSize() Size</span><br><span class="line">	<span class="comment">// Move moves this object to the given position relative to its parent.</span></span><br><span class="line">	<span class="comment">// This should only be called if your object is not in a container with a layout manager.</span></span><br><span class="line">	Move(Position)</span><br><span class="line">	<span class="comment">// Position returns the current position of the object relative to its parent.</span></span><br><span class="line">	Position() Position</span><br><span class="line">	<span class="comment">// Resize resizes this object to the given size.</span></span><br><span class="line">	<span class="comment">// This should only be called if your object is not in a container with a layout manager.</span></span><br><span class="line">	Resize(Size)</span><br><span class="line">	<span class="comment">// Size returns the current size of this object.</span></span><br><span class="line">	Size() Size</span><br><span class="line">	<span class="comment">// visibility</span></span><br><span class="line">	<span class="comment">// Hide hides this object.</span></span><br><span class="line">	Hide()</span><br><span class="line">	<span class="comment">// Visible returns whether this object is visible or not.</span></span><br><span class="line">	Visible() <span class="type">bool</span></span><br><span class="line">	<span class="comment">// Show shows this object.</span></span><br><span class="line">	Show()</span><br><span class="line">	<span class="comment">// Refresh must be called if this object should be redrawn because its inner state changed.</span></span><br><span class="line">	Refresh()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Layout接口"><a href="#Layout接口" class="headerlink" title="Layout接口"></a>Layout接口</h3><p><code>Layout</code>描述了许多<code>CanvasObject</code>怎么样以特定的<strong>尺寸</strong>被摆放。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Layout <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Layout will manipulate the listed CanvasObjects Size and Position</span></span><br><span class="line">	<span class="comment">// to fit within the specified size.</span></span><br><span class="line">	Layout([]CanvasObject, Size)</span><br><span class="line">	<span class="comment">// MinSize calculates the smallest size that will fit the listed</span></span><br><span class="line">	<span class="comment">// CanvasObjects using this Layout algorithm.</span></span><br><span class="line">	MinSize(objects []CanvasObject) Size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当一个<code>CanvasObject</code>同时实现了<code>Layout</code>接口时，<code>Resize()</code>和<code>Move()</code>方法将会失效。</strong></p>
<p>Fyne中绘制的<strong>一切都是<code>CanvasObject</code>，因此几乎所有的结构体都实现了<code>CanvasObject</code>接口</strong>。例如下面的常见结构体。</p>
<ul>
<li>绘图或动画<ul>
<li>Rectangle 长方形</li>
<li>Text 文本</li>
<li>Circle 圆圈</li>
<li>Image 图像</li>
</ul>
</li>
<li>组件<code>Widget</code>或<code>WidgetRenderer</code>，用于和用户交互的主要部分。<ul>
<li>Label 标签</li>
<li>Button 按钮</li>
<li>Entry 输入框</li>
</ul>
</li>
<li>容器<code>Container</code>，用于以一定的布局<code>Layout</code>包括一系列的<code>CanvasObject</code>，而容器本身也实现了<code>CanvasObject</code>接口。<ul>
<li>Box 盒子</li>
<li>Grid 流式布局</li>
<li>GridWrap 弹性流式布局</li>
<li>Border 边界布局</li>
</ul>
</li>
</ul>
<h2 id="布局和容器"><a href="#布局和容器" class="headerlink" title="布局和容器"></a>布局和容器</h2><h3 id="container和layout的关系"><a href="#container和layout的关系" class="headerlink" title="container和layout的关系"></a>container和layout的关系</h3><p><strong>通俗来讲，容器是放元素的，而布局规定了容器内的元素该如何被摆放。一定程度上，可以认为布局就是容器</strong></p>
<p><code>Container</code>用于将多种<code>CanvasObject</code>按一定的<code>Layout</code>布局或不按照布局排列拜访。同时<code>Container</code>本身也是<code>CanvasObject</code>，这意味着容器内也可以放容器。</p>
<p><code>container</code>有两种实例化的方法，其区别就是是否带布局<code>Layout</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// New returns a new Container instance holding the specified CanvasObjects which will be laid out according to the specified Layout.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Since: 2.0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(layout fyne.Layout, objects ...fyne.CanvasObject)</span></span> *fyne.Container &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;fyne.Container&#123;Layout: layout, Objects: objects&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewWithoutLayout returns a new Container instance holding the specified CanvasObjects that are manually arranged.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Since: 2.0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWithoutLayout</span><span class="params">(objects ...fyne.CanvasObject)</span></span> *fyne.Container &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;fyne.Container&#123;Objects: objects&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是<code>New</code>方法，其内部的元素尺寸和位置将由<code>Layout</code>自动决定。</li>
<li>如果是<code>NewWithoutLayout</code>方法，其内部的元素尺寸和位置将由手动决定（手动较为复杂，通常用自动布局）。</li>
</ul>
<h3 id="Fyne提供的布局"><a href="#Fyne提供的布局" class="headerlink" title="Fyne提供的布局"></a>Fyne提供的布局</h3><p>Fyne提供了很多种布局（容器），各布局有其元素尺寸和位置的摆放规则。</p>
<blockquote>
<p><a href="https://go-circle.cn/fyne-press/v1.0/2-exploring-fyne/layout-list.html">布局列表 | Fyne 开发文档 (go-circle.cn)</a></p>
</blockquote>
<p>通过使用多种布局，可以构建更复杂的应用程序结构。</p>
<h3 id="Border边界布局demo"><a href="#Border边界布局demo" class="headerlink" title="Border边界布局demo"></a>Border边界布局demo</h3><p>我们只需要通过一个布局demo即可理解布局是如何影响各画布元素的尺寸和位置。</p>
<p>Border布局创建方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBorder</span><span class="params">(top, bottom, left, right fyne.CanvasObject, objects ...fyne.CanvasObject)</span></span> *fyne.Container </span><br></pre></td></tr></table></figure>

<p>输入的<code>CanvasObject</code>会先后按照如下原则放置（建议跳过直接看demo进行理解）：</p>
<ul>
<li>前两个元素分别布局在上下，高度&#x3D;元素的最小高度，宽度&#x3D;窗口的最大宽度；</li>
<li>随后两个元素分别布局在左右，宽度&#x3D;元素的最小宽度，高度&#x3D;窗口最大高度-上下元素高度之和；</li>
<li>后面的多个<code>CanvasObject</code>将会按顺序先后以这些元素的最大尺寸填充到中间区域，这个区域被包围在前四个元素内的区域，且稍小一些。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := app.New()</span><br><span class="line">w := a.NewWindow(<span class="string">&quot;demo&quot;</span>)</span><br><span class="line">w.Resize(fyne.NewSize(<span class="number">300</span>, <span class="number">300</span>))</span><br><span class="line"><span class="comment">// 上</span></span><br><span class="line">text := canvas.NewText(<span class="string">&quot;hello world&quot;</span>, color.Black)</span><br><span class="line"><span class="comment">// 左</span></span><br><span class="line">rect := canvas.NewRectangle(color.Black)</span><br><span class="line"><span class="comment">// 中</span></span><br><span class="line">midRect := canvas.NewRectangle(color.Black)</span><br><span class="line">midCircle := canvas.NewCircle(color.Gray&#123;Y: <span class="number">50</span>&#125;)</span><br><span class="line">midText := canvas.NewText(<span class="string">&quot;hello world&quot;</span>, color.White)</span><br><span class="line"><span class="comment">// 下</span></span><br><span class="line">button := widget.NewButton(<span class="string">&quot;button&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;&#125;)</span><br><span class="line">button.Resize(fyne.Size&#123;Width: <span class="number">100</span>, Height: <span class="number">50</span>&#125;) <span class="comment">// 显然失效</span></span><br><span class="line"><span class="comment">// 右</span></span><br><span class="line">input := widget.NewEntry()</span><br><span class="line"></span><br><span class="line">borderContent := container.NewBorder(text, button, rect, input, midRect, midCircle, midText)</span><br><span class="line">w.SetContent(borderContent)</span><br><span class="line">w.ShowAndRun()</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231224210507244.png" alt="image-20231224210507244"></p>
<p>其中关注<code>NewBorder</code>所包含的元素，参照放置原则：</p>
<ul>
<li>前两个分别是<strong>黑色文本</strong>和<strong>按钮</strong>，均以其最小的高度放了窗口的上下区域；</li>
<li>随后两个分别是一个<strong>黑色长方形</strong>和<strong>输入框</strong>，均以其最小的宽度放了窗口的左右区域。值得注意的是，黑色长方形的最小宽度只有一个像素；</li>
<li>最后三个，分别以<strong>黑色长方形</strong>，<strong>灰色圆形</strong>，<strong>白色文本</strong>分别以最大的尺寸先后放置在了中心区域。其中文本框已经是最大尺寸，只是文本比较小，且默认上下居中。</li>
</ul>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>此命令能减小编译后可执行文件的大小，同时关闭命令行窗口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> build -ldflags <span class="string">&quot;-s -w -H=windowsgui&quot;</span> .</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Golang</category>
        <category>非标准库包</category>
      </categories>
  </entry>
</search>
