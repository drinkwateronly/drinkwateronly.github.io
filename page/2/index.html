<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"drinkwateronly.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Wallnut">
<meta property="og:url" content="https://drinkwateronly.github.io/page/2/index.html">
<meta property="og:site_name" content="Wallnut">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wallnut">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://drinkwateronly.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Wallnut</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Wallnut</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wallnut"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Wallnut</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/drinkwateronly" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;drinkwateronly" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/11/8c1b64ea2c6a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/8c1b64ea2c6a/" class="post-title-link" itemprop="url">ch11-文件操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-17 00:00:00 / 修改时间：19:48:34" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/Go%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Go基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第11章-文件操作"><a href="#第11章-文件操作" class="headerlink" title="第11章 文件操作"></a>第11章 文件操作</h1><p>文件分为两类：文本文件和二进制文件。<br>windows目录不区分大小写，Unix区分。<br>windows每个盘都是自己的根目录，Unix只有<code>/</code>一个根目录。<br>I&#x2F;O操作封装在：</p>
<ul>
<li>io—— 为I&#x2F;O<strong>原语</strong>提供基本的接口</li>
<li>io&#x2F;ioutil—— 封装实用I&#x2F;O函数，也是本章重点</li>
<li>fmt —— 格式化I&#x2F;O</li>
<li>bufio —— 带缓冲I&#x2F;O</li>
</ul>
<h2 id="11-1-目录基本操作"><a href="#11-1-目录基本操作" class="headerlink" title="11.1 目录基本操作"></a>11.1 目录基本操作</h2><h3 id="11-1-1-目录"><a href="#11-1-1-目录" class="headerlink" title="11.1.1 目录"></a>11.1.1 目录</h3><p>io&#x2F;ioutil库中有关目录的方法已经在Go 1.16弃用。</p>
<p>采用os库</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 删除目录</span></span><br><span class="line">os.RemoveAll(path <span class="type">string</span>)</span><br><span class="line"><span class="comment">// 获取当前工作目录</span></span><br><span class="line">os.Getwd()</span><br><span class="line"><span class="comment">// 切换当前工作目录</span></span><br><span class="line">os.Chdir(path <span class="type">string</span>)</span><br><span class="line"><span class="comment">// 获取临时目录？</span></span><br><span class="line">os.TempDir()</span><br><span class="line"><span class="comment">// 读取目录</span></span><br><span class="line">os.ReadDir(name <span class="type">string</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="11-1-3-目录操作"><a href="#11-1-3-目录操作" class="headerlink" title="11.1.3 目录操作"></a>11.1.3 目录操作</h3><p>来自os库</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mkdir</span><span class="params">(name <span class="type">string</span>, perm FileMode)</span></span> <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MkdirAll</span><span class="params">(name <span class="type">string</span>, perm FileMode)</span></span> <span class="type">error</span> <span class="comment">// &quot;a/aa/aaa&quot; 多级目录</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Mkdir</code>只能创建一个一级目录，文件存在会创建失败返回错误；权限不足，也会创建失败</li>
<li><code>MkdirAll</code>能创建多级目录，目录存在返回nil，且不做操作。成功了都会返回nil。</li>
</ul>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveAll</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>Remove</code>只能删除空文件夹，非空返回错误；</p>
</li>
<li><p><code>RemoveAll</code>删除指定的文件，或目录及它包含的任何下级对象，指定对象不存在（其实也算删除成功），返回nil。</p>
<p>成功了都会返回nil。</p>
</li>
</ul>
<h4 id="判断目录或文件是否存在"><a href="#判断目录或文件是否存在" class="headerlink" title="判断目录或文件是否存在"></a>判断目录或文件是否存在</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(name <span class="type">string</span>)</span></span> (fi FileInfo, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>成功，返回描述文件对象的<code>FileInfo</code>，返回nil</li>
<li>若对象是个符号链接，返回符号链接指向的文件的<code>FileInfo，返回nil</code></li>
<li>出错，返回<code>*PathError</code>类型错误</li>
</ul>
<p>具体判断某文件是否存在，是用<code>Stat()</code>的返回的error确定</p>
<ul>
<li>如果error&#x3D;&#x3D;nil，文件&#x2F;文件夹存在</li>
<li>对返回的<code>os.IsNotExist(error)==true </code>，文件夹不存在</li>
<li>其他情况，不确定存在不存在</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fi, err := os.Stat(<span class="string">&quot;E:\\GoWorks\\3.jpg&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;文件夹存在&quot;</span>)</span><br><span class="line">    fmt.Println(fi.IsDir())</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;文件不存在&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;不确定存不存在&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建删除目录例程"><a href="#创建删除目录例程" class="headerlink" title="创建删除目录例程"></a>创建删除目录例程</h4><ul>
<li><code>isAll</code>决定是否是带All的目录操作</li>
<li><code>os.Mkdir</code>能设置创建目录权限，但可能失败，所以还用了<code>os.Chmod</code>。<a target="_blank" rel="noopener" href="https://www.codenong.com/41565192/">关于go：设置os.Mkdir权限 | 码农家园 (codenong.com)</a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createDir</span><span class="params">(path <span class="type">string</span>, dirName <span class="type">string</span>, isAll <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	dirPath := path + <span class="string">&quot;\\&quot;</span> + dirName</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> isAll &#123;</span><br><span class="line">		err = os.MkdirAll(dirPath, <span class="number">0777</span>) <span class="comment">// 可以增加多级</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = os.Mkdir(dirPath, <span class="number">0777</span>) <span class="comment">// 只能增加一级</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		os.Chmod(dirPath, <span class="number">0777</span>) <span class="comment">// 对创建的文件夹chmod</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;Create Dit =&gt;&quot;</span> + path + dirName)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDir</span><span class="params">(dirPath <span class="type">string</span>, isAll <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Delete Dir =&gt;&quot;</span> + dirPath)</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> isAll &#123;</span><br><span class="line">		err = os.Remove(dirPath) <span class="comment">// 可以删除多级</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = os.RemoveAll(dirPath) <span class="comment">// 只能删除一级</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Delete success&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rootPath := <span class="string">&quot;F:\\code\\GoWorks\\src\\GoTutorial\\ch11&quot;</span></span><br><span class="line">	createDir(rootPath, <span class="string">&quot;mkdir&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">	deleteDir(rootPath+<span class="string">&quot;\\mkdir&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">	createDir(rootPath, <span class="string">&quot;mkdir\\mkdirAll&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">	deleteDir(rootPath+<span class="string">&quot;\\mkdir\\mkdirAll&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="11-2-文件基本操作"><a href="#11-2-文件基本操作" class="headerlink" title="11.2 文件基本操作"></a>11.2 文件基本操作</h2><p>文件权限粒度：拥有者、所属组、其他组。每个粒度都能设置不同文件权限：<br> <img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230510000554747.png" alt="image-20230510000554747"></p>
<h3 id="11-2-1-文件的创建与打开"><a href="#11-2-1-文件的创建与打开" class="headerlink" title="11.2.1 文件的创建与打开"></a>11.2.1 文件的创建与打开</h3><h4 id="Open-和-Create"><a href="#Open-和-Create" class="headerlink" title="Open() 和 Create()"></a>Open() 和 Create()</h4><ul>
<li><code>Open</code>以读<code>O_RDONLY</code>形式打开文件</li>
<li><code>Create</code>采用<code>0666</code>（可读写不可执行）创建文件；如果文件存在，会清空文件内容；对应的文件描述符具有<code>O_RDWR</code>。</li>
<li>返回错误底层类型<code>*PathError</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="OpenFile"><a href="#OpenFile" class="headerlink" title="OpenFile()"></a>OpenFile()</h4><p>来自os库，OpenFile比Open和Create<strong>更底层</strong>（他们俩都是调用OpenFile），会以指定的<strong>选项flag</strong>和<strong>模式perm</strong>打开文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>flag：访问模式 （并非所有操作系统都可用）<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"> O_RDONLY <span class="type">int</span> = syscall.O_RDONLY <span class="comment">// 只读模式打开文件</span></span><br><span class="line"> O_WRONLY <span class="type">int</span> = syscall.O_WRONLY <span class="comment">// 只写模式打开文件</span></span><br><span class="line"> O_RDWR <span class="type">int</span> = syscall.O_RDWR <span class="comment">// 读写模式打开文件</span></span><br><span class="line"> <span class="comment">// O_RDONLY |  O_WRONLY 不等于 O_RDWR， 他们分别为0、1、2</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 前三个只指定一个，剩下由 | 连接指定</span></span><br><span class="line"> O_APPEND <span class="type">int</span> = syscall.O_APPEND <span class="comment">// 写操作时将数据附加到文件尾部</span></span><br><span class="line"> O_CREATE <span class="type">int</span> = syscall.O_CREAT <span class="comment">// 如果不存在将创建一个新文件</span></span><br><span class="line"> O_EXCL <span class="type">int</span> = syscall.O_EXCL <span class="comment">// 和O_CREATE配合使用，文件必须不存在</span></span><br><span class="line"> O_SYNC <span class="type">int</span> = syscall.O_SYNC <span class="comment">// 打开文件用于同步I/O</span></span><br><span class="line"> O_TRUNC <span class="type">int</span> = syscall.O_TRUNC <span class="comment">// 如果可能，打开时清空文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>perm：位掩码参数 指定文件模式和权限位 （所有操作系统都一样）<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"> <span class="comment">// 单字符是被 String 方法用于格式化的属性缩写</span></span><br><span class="line"> ModeDir FileMode = <span class="number">1</span> &lt;&lt; (<span class="number">32</span> - <span class="number">1</span> - <span class="literal">iota</span>) <span class="comment">// d: 目录</span></span><br><span class="line"> ModeAppend <span class="comment">// a: 只能写入，且只能写入到末尾</span></span><br><span class="line"> ModeExclusive <span class="comment">// l: 用于执行</span></span><br><span class="line"> ModeTemporary <span class="comment">// T: 临时文件（非备份文件）</span></span><br><span class="line"> ModeSymlink <span class="comment">// L: 符号链接（不是快捷方式文件）</span></span><br><span class="line"> ModeDevice <span class="comment">// D: 设备</span></span><br><span class="line"> ModeNamedPipe <span class="comment">// p: 命名管道（FIFO）</span></span><br><span class="line"> ModeSocket <span class="comment">// S: Unix域socket</span></span><br><span class="line"> ModeSetuid <span class="comment">// u: 表示文件具有其创建者用户id权限</span></span><br><span class="line"> ModeSetgid <span class="comment">// g: 表示文件具有其创建者组id的权限</span></span><br><span class="line"> ModeCharDevice <span class="comment">// c: 字符设备，需已设置ModeDevice</span></span><br><span class="line"> ModeSticky <span class="comment">// t: 只有root/创建者能删除/移动文件</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 覆盖所有类型位（用于通过&amp;获取类型位），对普通文件，所有这些位都不应被设置</span></span><br><span class="line"> ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | </span><br><span class="line">ModeDevice</span><br><span class="line"> ModePerm FileMode = <span class="number">0777</span> <span class="comment">// 覆盖所有Unix权限位（用于通过&amp;获取类型位）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>实际上<code>Open()</code>和<code>Creat()</code>的底层就是<code>OpenFile()</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (＊File, <span class="type">error</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> OpenFile(name, O_RDONLY, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="type">string</span>)</span></span> (＊File, <span class="type">error</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.OpenFile(rootPath+<span class="string">&quot;\\1.txt&quot;</span>, os.O_RDWR|os.O_CREATE, <span class="number">0766</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(file) <span class="comment">// &amp;&#123;0xc00010c780&#125;</span></span><br><span class="line">file.Close()</span><br></pre></td></tr></table></figure>



<h3 id="11-2-2-文件读取"><a href="#11-2-2-文件读取" class="headerlink" title="11.2.2 文件读取"></a>11.2.2 文件读取</h3><p>os库</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Read (b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> ReadAt (b []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Read</code>方法从文件中读取最多<code>len(b)</code>字节，写入byte数组b中，返回真正读取的字节数n，和err。文件终止的标志是读取n&#x3D;&#x3D;0个字节且返回值err为io.EOF。</li>
<li><code>ReadAt</code>和<code>Read</code>的区别是，从文件开始的字节偏移量off开始读，并且不会改变文件偏移量。<ul>
<li>循环<code>Read</code>一字节，文件能慢慢读到文件末尾，因为读1字节，偏移量自动往后移动1字节；</li>
<li>而循环<code>ReadAt</code>1字节，如果off固定，每次就只会从文件开始的off偏移读取，偏移量不会自动往后走，除非调用时改变off。</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(path <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	file, err := os.Open(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>) <span class="comment">// 每次读1024字节</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="built_in">len</span>, err := file.Read(buf)</span><br><span class="line">        <span class="comment">// len, err := file.ReadAt(buf, 1)</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(err) <span class="comment">// EOF</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line">	&#125;</span><br><span class="line">	file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-2-3-文件写入"><a href="#11-2-3-文件写入" class="headerlink" title="11.2.3 文件写入"></a>11.2.3 文件写入</h3><p>同样的，和读取类似，也有两个接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> WriteAt(b []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>两种方法向文件中写入<code>len(b)</code>字节，如果返回值n!&#x3D;len(b)，就返回一个非nil错误。</li>
<li>两种方式都会覆盖原文件</li>
</ul>
<p>以下例程的两个函数的文件写入效果一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(path <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	file, err := os.Create(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	data := <span class="string">&quot;data \n for \t writing!&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 偏移量自动改变</span></span><br><span class="line">		file.Write([]<span class="type">byte</span>(data))</span><br><span class="line">	&#125;</span><br><span class="line">	file.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFileAt</span><span class="params">(path <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	file, err := os.Create(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	data := <span class="string">&quot;data \n for \t writing!&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 偏移量手动改变</span></span><br><span class="line">		file.WriteAt([]<span class="type">byte</span>(data), <span class="type">int64</span>(i*<span class="built_in">len</span>(data)))</span><br><span class="line">	&#125;</span><br><span class="line">	file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-2-4-文件删除"><a href="#11-2-4-文件删除" class="headerlink" title="11.2.4 文件删除"></a>11.2.4 文件删除</h3><p>和目录一样调用<code>Remove</code>和<code>RemoveAll</code>即可，</p>
<h2 id="11-3-处理json文件"><a href="#11-3-处理json文件" class="headerlink" title="11.3 处理json文件"></a>11.3 处理json文件</h2><p>javaScript Object Notation，</p>
<blockquote>
<p>当我们需要对大量的JSON进行快速解析处理时，标准库提供的JSON处理库“encoding&#x2F;json” 可能就不能满足我们的需求，GitHub开源了一个比标准库解析速度快10倍的[fastjson库](https:&#x2F;&#x2F; github.com&#x2F;valyala&#x2F;fastjson)</p>
</blockquote>
<h3 id="11-3-1-编码JSON"><a href="#11-3-1-编码JSON" class="headerlink" title="11.3.1 编码JSON"></a>11.3.1 编码JSON</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span> <span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>Marshal</code>返回interface的JSON编码，v通常会用map或结构体，返回的[]byte可以转成string查看，但此时并没有格式化，输出一行json字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalIndent</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, prefix, indent <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>MarshalIndent</code>返回的是JSON编码的格式化形式，prefix为每一行的开头，indent是缩进的格式，都是字符串</p>
<h5 id="map存json"><a href="#map存json" class="headerlink" title="map存json"></a>map存json</h5><ul>
<li>例程<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>] <span class="keyword">interface</span>&#123;&#125;, <span class="number">6</span>) <span class="comment">// string为键，interface&#123;&#125;为值的map，最大存6个</span></span><br><span class="line">m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;walle&quot;</span></span><br><span class="line">m[<span class="string">&quot;age&quot;</span>] = <span class="number">1</span></span><br><span class="line">m[<span class="string">&quot;sex&quot;</span>] = <span class="literal">true</span></span><br><span class="line">m[<span class="string">&quot;language&quot;</span>] = []<span class="type">string</span>&#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;PHP&quot;</span>, <span class="string">&quot;PYTHON&quot;</span>&#125;</span><br><span class="line">result, _ := json.Marshal(m)</span><br><span class="line">resultFormat, _ := json.MarshalIndent(m, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;----&quot;</span>) <span class="comment">// 每一行以1开头，然后用----缩进</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(result))</span><br><span class="line">fmt.Println(<span class="type">string</span>(resultFormat))</span><br></pre></td></tr></table></figure></li>
<li>输出结果<blockquote>
<p>{“age”:1,”language”:[“Go”,”PHP”,”PYTHON”],”name”:”walle”,”sex”:true}<br>{<br>1—-“age”: 1,<br>1—-“language”: [<br>1——–”Go”,<br>1——–”PHP”,<br>1——–”PYTHON”<br>1—-],<br>1—-“name”: “walle”,<br>1—-“sex”: true<br>1}</p>
</blockquote>
</li>
</ul>
<h5 id="struct存json"><a href="#struct存json" class="headerlink" title="struct存json"></a>struct存json</h5><p>大多数情况使用struct结构体会更方便，可以在定义struct的成员变量时添加<strong>标签</strong>控制编码和解码：</p>
<ul>
<li><code>&quot;-&quot;</code>：不要解析这个字段</li>
<li><code>&quot;omitempty&quot;</code>：字段为空时，不要解析</li>
<li><code>&quot;FieldName&quot;</code>：解析时用这个名字</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="type">string</span>   <span class="string">`json:&quot;Name1&quot;`</span> <span class="comment">//以Name1编码</span></span><br><span class="line">	Age      <span class="type">int</span>      <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Sex      <span class="type">bool</span>     <span class="string">`json:&quot;-&quot;`</span> <span class="comment">// 不解析</span></span><br><span class="line">	Birthday <span class="type">string</span>   <span class="string">`json:&quot;birthday&quot;`</span></span><br><span class="line">	Company  <span class="type">string</span>   <span class="string">`json:&quot;company,omitempty&quot;`</span> <span class="comment">// 空时（默认值时）不解析</span></span><br><span class="line">	Language []<span class="type">string</span> <span class="string">`json:&quot;language&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line">person := Person&#123;<span class="string">&quot;walle&quot;</span>, <span class="number">10</span>, <span class="literal">true</span>, <span class="string">&quot;1900-1-1&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">	[]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;go&quot;</span>,</span><br><span class="line">		<span class="string">&quot;json&quot;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line">result, err := json.MarshalIndent(person, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(result))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>{<br>“Name1”: “walle”,<br>“age”: 10,<br>“birthday”: “1900-1-1”,<br>“language”: [<br> “go”,<br> “json”<br>]<br>}</p>
</blockquote>
<h3 id="11-3-2-解码JSON"><a href="#11-3-2-解码JSON" class="headerlink" title="11.3.2 解码JSON"></a>11.3.2 解码JSON</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="type">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>将解析json编码的数据放到v中，</p>
<h4 id="使用map存放"><a href="#使用map存放" class="headerlink" title="使用map存放"></a>使用map存放</h4><p>map可以通过键获获取值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">6</span>)</span><br><span class="line">err1 := json.Unmarshal([]<span class="type">byte</span>(jsonStr), &amp;map1)</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println( map1)</span><br><span class="line"><span class="comment">// map[Name:walle Sex:true age:10 birthday:1900-1-1 language:[go json]]</span></span><br></pre></td></tr></table></figure>
<p>如果要知道类型，需要进行<strong>类型断言</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">    <span class="keyword">switch</span> data := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;string&quot;</span>, key, data)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;bool&quot;</span>, key, data)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;int&quot;</span>, key, data)</span><br><span class="line">    <span class="keyword">case</span> []<span class="type">string</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;[]string&quot;</span>, key, data)</span><br><span class="line">    <span class="keyword">case</span> []<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">        fmt.Println(<span class="string">&quot;[]interface&quot;</span>, key, data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用struct存放（推荐）"><a href="#使用struct存放（推荐）" class="headerlink" title="使用struct存放（推荐）"></a>使用struct存放（推荐）</h4><p>其实就说struct内部已经定义好了类型，所以无需类型判断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 Person <span class="comment">// 用到了11.3.1的Person结构体</span></span><br><span class="line">err2 := json.Unmarshal([]<span class="type">byte</span>(jsonStr), &amp;person1)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;person = %+v&quot;</span>, person1) </span><br><span class="line">   <span class="comment">//person = &#123;Name: Age:10 Sex:false Birthday:1900-1-1 Company: Language:[go json]&#125; </span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/11/a90c7818ac95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/a90c7818ac95/" class="post-title-link" itemprop="url">ch14-反射</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-17 00:00:00 / 修改时间：19:48:49" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/Go%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Go基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第14章-反射"><a href="#第14章-反射" class="headerlink" title="第14章 反射"></a>第14章 反射</h1><p><a target="_blank" rel="noopener" href="http://www.zzvips.com/article/200181.html">一文搞懂Go反射的使用方法和应用场景_Golang_脚本之家 (zzvips.com)</a><br><a target="_blank" rel="noopener" href="https://golangbot.com/reflection/">Reflection in Golang | golangbot.com</a></p>
<h2 id="14-1-反射的定义"><a href="#14-1-反射的定义" class="headerlink" title="14.1 反射的定义"></a>14.1 反射的定义</h2><p>go语言提供一种机制——反射：<strong>运行时</strong>更新变量和检查它们的值，调用它们的方法或支持的内在操作，但<strong>编译时</strong>并不知道这些变量的具体类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 不知道其他人调用该函数时，会传入什么类型</span></span><br><span class="line">    <span class="comment">// 1、类型断言可以获取x的类型，但需要猜，有很多种情况</span></span><br><span class="line">    <span class="comment">// 2、利用反射reflect</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-2-reflect包基本用法"><a href="#14-2-reflect包基本用法" class="headerlink" title="14.2 reflect包基本用法"></a>14.2 reflect包基本用法</h2><h3 id="14-2-1-reflect-TypeOf"><a href="#14-2-1-reflect-TypeOf" class="headerlink" title="14.2.1 reflect.TypeOf()"></a>14.2.1 <code>reflect.TypeOf()</code></h3><p><code>reflect.TypeOf()</code>获取反射类型对象<code>reflect.Type</code>，如<code>reflect.String</code>等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> typeOfa reflect.Type = reflect.TypeOf(a)</span><br><span class="line"><span class="comment">// reflect.Type的3种方法</span></span><br><span class="line">typeOfa.Name() <span class="comment">// 获得类型名称，经过type关键字后新建立的类型名</span></span><br><span class="line">typeOfa.Kind() <span class="comment">// 获得种类，实际的类型</span></span><br><span class="line">typeOfa.Elem() <span class="comment">// 若是指针就获得指向的类型</span></span><br></pre></td></tr></table></figure>

<p>反射的种类reflect.Kind的定义如下，如reflect.Int：</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230520202931430.png" alt="image-20230520202931430"></p>
<p>其中Map、Slice、Chan属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于 独立的种类，不属于Ptr。type A struct{}定义的结构体属于Struct种类，*A属于Ptr。</p>
<h5 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Number <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkType</span><span class="params">(t reflect.Type)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;变量的类型名称=&gt;%v, 类型种类=&gt; %v\n&quot;</span>, t.Name(), t.Kind())</span><br><span class="line">	<span class="keyword">if</span> t.Kind() == reflect.Ptr &#123; <span class="comment">// 指针，</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;指向的变量：%v&quot;</span>, t.Elem())</span><br><span class="line">		t = t.Elem() <span class="comment">// 如果是指针，t赋值为t的指向</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num Number = <span class="number">10</span></span><br><span class="line">	typeOfNum := reflect.TypeOf(num)</span><br><span class="line">	fmt.Println(<span class="string">&quot;typeOfNum:&quot;</span>)</span><br><span class="line">	checkType(typeOfNum)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> person Person</span><br><span class="line">	typeOfperson := reflect.TypeOf(person)</span><br><span class="line">	fmt.Println(<span class="string">&quot;typeOfperson:&quot;</span>)</span><br><span class="line">	checkType(typeOfperson)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> personPtr = &amp;person  </span><br><span class="line">	typeOfptr := reflect.TypeOf(&amp;personPtr)</span><br><span class="line">	fmt.Println(<span class="string">&quot;typeOfptr:&quot;</span>)</span><br><span class="line">	checkType(typeOfptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeOfNum:</span><br><span class="line">变量的类型名称=&gt;Number, 类型种类=&gt; int   </span><br><span class="line">typeOfperson:                            </span><br><span class="line">变量的类型名称=&gt;Person, 类型种类=&gt; struct</span><br><span class="line">typeOfptr:                               </span><br><span class="line">变量的类型名称=&gt;, 类型种类=&gt; ptr       </span><br><span class="line">指向的变量：*main.Person   </span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="14-2-2-reflect-ValueOf"><a href="#14-2-2-reflect-ValueOf" class="headerlink" title="14.2.2 reflect.ValueOf()"></a>14.2.2 <code>reflect.ValueOf()</code></h3><p><code>reflect.ValueOf()</code>获取类型为<code>reflect.Value</code>的反射值对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> valueOfa reflect.Value = reflect.ValueOf(a)</span><br><span class="line">valueOfa.Type() <span class="comment">// 类型种类</span></span><br><span class="line">valueOfa.Elem() <span class="comment">// 若是指针就是指向的类型</span></span><br><span class="line"></span><br><span class="line">valueOfa.Int() <span class="comment">// 获取变量值，如果a不是int，会panic</span></span><br><span class="line"><span class="comment">// 基本类型都有，如valueOfa.String()、valueOfa.Bool()</span></span><br></pre></td></tr></table></figure>

<h5 id="例程-1"><a href="#例程-1" class="headerlink" title="例程"></a>例程</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkValue</span><span class="params">(v reflect.Value)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v.Kind() == reflect.Ptr &#123; </span><br><span class="line">		v = v.Elem() <span class="comment">// 如果是指针，v转移到指针指向的值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> v.Kind() == reflect.Int &#123;  <span class="comment">// 如果v的实际类型是int</span></span><br><span class="line">    	<span class="comment">// 方式1，调用reflect.Value的Int()，再强制类型转换</span></span><br><span class="line">		<span class="keyword">var</span> v1 <span class="type">int</span> = <span class="type">int</span>(v.Int()) <span class="comment">// 若v本身不是int，不做判断直接.Int()会panic</span></span><br><span class="line">        <span class="comment">// 方式2，调用reflect.Value的Interface()，再从interface转成int</span></span><br><span class="line">		<span class="keyword">var</span> v2 <span class="type">int</span> = v.Interface().(<span class="type">int</span>)</span><br><span class="line">		fmt.Println(v1, v2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">	ValueOfNum := reflect.ValueOf(num)</span><br><span class="line">	fmt.Println(<span class="string">&quot;ValueOfNum&quot;</span>)</span><br><span class="line">	checkValue(ValueOfNum)</span><br><span class="line"></span><br><span class="line">	ValueOfPtr := reflect.ValueOf(&amp;num)</span><br><span class="line">	fmt.Println(<span class="string">&quot;ValueOfPtr&quot;</span>)</span><br><span class="line">	checkValue(ValueOfPtr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-2-3-使用反射调用函数"><a href="#14-2-3-使用反射调用函数" class="headerlink" title="14.2.3  使用反射调用函数"></a>14.2.3  使用反射调用函数</h3><p>这块比较复杂，最好是结合例程进行理解：</p>
<ol>
<li>函数也是变量，所以也可以获取其<code>reflect.Value</code>对象。</li>
<li>函数的<code>reflect.Value</code>对象有个Call方法，调用Call方法能够调用函数本身。</li>
<li>Call方法的参数：reflect.Value对象的切片，每个元素按序是 函数本身所需要的参数 的reflect.Value对象</li>
<li>Call方法的返回值：reflect.Value对象的切片，每个元素按序是 函数本身返回值 的reflect.Value对象</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> Call(in []Value) []Value  <span class="comment">// func (v Value)的方法Call()，输入为切片，输出为切片</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果v的Kind不是Func会panic。参数没对应上也会panic。</li>
</ul>
<h5 id="例程-2"><a href="#例程-2" class="headerlink" title="例程"></a>例程</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Equal</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a == b &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取函数Equal的reflect.Value对象</span></span><br><span class="line">	valueOfFunc := reflect.ValueOf(Equal)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取reflect.Value对象的切片，作为valueOfFunc调用时的参数</span></span><br><span class="line">	args := []reflect.Value&#123;reflect.ValueOf(<span class="number">1</span>), reflect.ValueOf(<span class="number">2</span>)&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call方法调用，即调用函数本身</span></span><br><span class="line">	result := valueOfFunc.Call(args)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回值也是reflect.Value对象切片，获取返回值reflect.Value的变量值</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;result&quot;</span>, result[<span class="number">0</span>].Bool())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="14-3-对结构体的反射操作"><a href="#14-3-对结构体的反射操作" class="headerlink" title="14.3 对结构体的反射操作"></a>14.3 对结构体的反射操作</h2><h3 id="14-3-1-获取结构体成员类型"><a href="#14-3-1-获取结构体成员类型" class="headerlink" title="14.3.1 获取结构体成员类型"></a>14.3.1 获取结构体成员类型</h3><p>通过<code>reflect.Type()</code>获得的<code>reflect.Type</code>对象，可以调用如下方法</p>
<ul>
<li><p><code>NumField()</code>：获取结构体成员的数量</p>
</li>
<li><p><code>Field(index int)</code>：根据索引返回结构体字段详情信息，即<code>StructField</code>对象定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StructField <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span>    <span class="comment">// 字段名</span></span><br><span class="line">    PkgPath <span class="type">string</span> <span class="comment">// 字段路径</span></span><br><span class="line">    Type Type      <span class="comment">// 字段反射类型对象</span></span><br><span class="line">    Tag StructTag  <span class="comment">// 字段结构体标签</span></span><br><span class="line">    Offset <span class="type">uintptr</span> <span class="comment">// 字段在结构体中的偏移</span></span><br><span class="line">    Index []<span class="type">int</span> 	<span class="comment">// 字段的索引值</span></span><br><span class="line">    Anonymous <span class="type">bool</span> <span class="comment">// 是否为匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>FieldByName(name string)</code>：通过字段名（结构体成员名）获取字段信息，即<code>StructField</code>对象</p>
</li>
<li><p><code>FieldByIndex(index []int)</code>：It is equivalent to calling <code>Field()</code> successively for each index i.</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="type">string</span></span><br><span class="line">	Age    <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	<span class="type">string</span>     <span class="comment">// 匿名字段 Anonymous Field</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStructFiled</span><span class="params">(field reflect.StructField)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;字段名&quot;</span>, field.Name)</span><br><span class="line">	fmt.Println(<span class="string">&quot;字段路径&quot;</span>, field.PkgPath)</span><br><span class="line">	fmt.Println(<span class="string">&quot;字段反射类型对象&quot;</span>, field.Type)</span><br><span class="line">	fmt.Println(<span class="string">&quot;字段结构体标签&quot;</span>, field.Tag)</span><br><span class="line">	fmt.Println(<span class="string">&quot;字段在结构体中的偏移&quot;</span>, field.Offset)</span><br><span class="line">	fmt.Println(<span class="string">&quot;字段的索引值&quot;</span>, field.Index)</span><br><span class="line">	fmt.Println(<span class="string">&quot;是否为匿名字段&quot;</span>, field.Anonymous)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	person := Person&#123;<span class="string">&quot;walle&quot;</span>, <span class="number">100</span>, <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">	typeOfPerson := reflect.TypeOf(person)</span><br><span class="line">	<span class="comment">// 根据NumField()循环所有成员，获取字段信息</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; typeOfPerson.NumField(); i++ &#123;</span><br><span class="line">		field := typeOfPerson.Field(i)</span><br><span class="line">		printStructFiled(field)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// FieldByName()根据字段名获取字段信息</span></span><br><span class="line">	<span class="keyword">if</span> field, ok := typeOfPerson.FieldByName(<span class="string">&quot;Age&quot;</span>); ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;通过字段名获取字段信息&quot;</span>)</span><br><span class="line">		printStructFiled(field)</span><br><span class="line">		<span class="comment">//fmt.Println(field.Int())</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据索引获取字段信息</span></span><br><span class="line">	field := typeOfPerson.FieldByIndex([]<span class="type">int</span>&#123;<span class="number">1</span>&#125;)</span><br><span class="line">    <span class="comment">// field := typeOfPerson.Field(1) // 等价写法</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;通过索引获取字段信息&quot;</span>)</span><br><span class="line">	printStructFiled(field)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">字段名 Name</span><br><span class="line">字段路径                 </span><br><span class="line">字段反射类型对象 string  </span><br><span class="line">字段结构体标签           </span><br><span class="line">字段在结构体中的偏移 0   </span><br><span class="line">字段的索引值 [0]         </span><br><span class="line">是否为匿名字段 false     </span><br><span class="line">                         </span><br><span class="line">字段名 Age               </span><br><span class="line">字段路径                 </span><br><span class="line">字段反射类型对象 int     </span><br><span class="line">字段结构体标签 json:&quot;age&quot;</span><br><span class="line">字段在结构体中的偏移 16  </span><br><span class="line">字段的索引值 [1]         </span><br><span class="line">是否为匿名字段 false     </span><br><span class="line">                         </span><br><span class="line">字段名 string            </span><br><span class="line">字段路径 main            </span><br><span class="line">字段反射类型对象 string  </span><br><span class="line">字段结构体标签           </span><br><span class="line">字段在结构体中的偏移 24  </span><br><span class="line">字段的索引值 [2]         </span><br><span class="line">是否为匿名字段 true      </span><br><span class="line">                         </span><br><span class="line">通过字段名获取字段信息   </span><br><span class="line">字段名 Age</span><br><span class="line">...和Age一样</span><br><span class="line"></span><br><span class="line">通过索引获取字段信息</span><br><span class="line">字段名 Age</span><br><span class="line">...和Age一样</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="14-3-2-获取结构体成员字段的值"><a href="#14-3-2-获取结构体成员字段的值" class="headerlink" title="14.3.2 获取结构体成员字段的值"></a>14.3.2 获取结构体成员字段的值</h3><p>通过<code>reflect.Value()</code>获得的<code>reflect.Value</code>对象，可以调用如下方法（和<code>reflect.Type</code>的方法一样，但返回值不同）</p>
<ul>
<li><code>NumField()</code>：获取结构体成员的数量</li>
<li><code>Field(index int)</code>：根据索引返回字段<code>reflect.Value</code>对象</li>
<li><code>FieldByName(name string)</code>：通过字段名（结构体成员名）获取字段<code>reflect.Value</code>对象</li>
<li><code>FieldByIndex(index []int)</code>：It is equivalent to calling <code>Field()</code> successively for each index i.</li>
</ul>
<h3 id="14-3-3-反射执行结构体方法"><a href="#14-3-3-反射执行结构体方法" class="headerlink" title="14.3.3 反射执行结构体方法"></a>14.3.3 反射执行结构体方法</h3><p>流程与14.2.3反射调用函数流程一致，但需要通过<code>reflect.Value</code>的<code>MethodByName</code>获取方法作为方法变量（类似于函数变量）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valueOfPerson := reflect.ValueOf(person) <span class="comment">// 获取reflect.Value</span></span><br><span class="line">f := valueOfPerson.MethodByName(<span class="string">&quot;GetName&quot;</span>) <span class="comment">// 获取方法变量</span></span><br><span class="line">f.Call([]reflect.Value&#123;&#125;)  <span class="comment">// call调用该方法</span></span><br></pre></td></tr></table></figure>



<h2 id="14-4-反射三定律"><a href="#14-4-反射三定律" class="headerlink" title="14.4 反射三定律"></a>14.4 反射三定律</h2><h3 id="14-4-1-接口到反射类型的转换"><a href="#14-4-1-接口到反射类型的转换" class="headerlink" title="14.4.1 接口到反射类型的转换"></a>14.4.1 接口到反射类型的转换</h3><p>反射可以将接口类型转化为反射类型（reflect.Type和reflect.Value）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br></pre></td></tr></table></figure>

<h3 id="14-4-2-反射到接口类型的转换"><a href="#14-4-2-反射到接口类型的转换" class="headerlink" title="14.4.2 反射到接口类型的转换"></a>14.4.2 反射到接口类型的转换</h3><p>反射可以将反射类型变量（reflect.Value）转化为接口类型，reflect.Value对象用了Interface()方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">valueOfA := reflect.ValueOf(a)</span><br><span class="line">fmt.Println(valueOfA.Interface()) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="14-4-3修改反射类型对象"><a href="#14-4-3修改反射类型对象" class="headerlink" title="14.4.3修改反射类型对象"></a>14.4.3修改反射类型对象</h3><p>想要使用反射修改变量值，其值是可写canSet的：1、变量可被寻址canAddr，2、变量可导出<br>（对结构体而言，字段不能是匿名，且字段名首字母大写）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span> <span class="string">`json:&quot;Age&quot;`</span> <span class="comment">// 字段名首字母非大写</span></span><br><span class="line">	<span class="type">string</span> <span class="comment">// 匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	person := Person&#123;<span class="string">&quot;w&quot;</span>, <span class="number">123</span>, <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">	valueOfPerson := reflect.ValueOf(&amp;person) <span class="comment">// 指针</span></span><br><span class="line">	typeOfPerson := reflect.TypeOf(&amp;person)   <span class="comment">// 指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; valueOfPerson.Elem().NumField(); i++ &#123;</span><br><span class="line">		fieldValue := valueOfPerson.Elem().Field(i)</span><br><span class="line">		fieldType := typeOfPerson.Elem().Field(i)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;类型名：%v，Value.CanAddr()=&gt;%v，fieldValue.CanSet=&gt;%v\n&quot;</span>, fieldType.Name, fieldValue.CanAddr(), fieldValue.CanSet())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;修改前&quot;</span>, person)</span><br><span class="line">	valueOfPerson.Elem().Field(<span class="number">0</span>).SetString(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;修改后&quot;</span>, person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于是指针，所以都可以寻址。而age字段和匿名字段不可导出，其值不能被修改。</p>
<blockquote>
<p>类型名：Name，Value.CanAddr()&#x3D;&gt;true，fieldValue.CanSet&#x3D;&gt;true<br>类型名：age，Value.CanAddr()&#x3D;&gt;true，fieldValue.CanSet&#x3D;&gt;false<br>类型名：string，Value.CanAddr()&#x3D;&gt;true，fieldValue.CanSet&#x3D;&gt;false<br>修改前 {w 123 test}<br>修改后 {test2 123 test}</p>
</blockquote>
<h2 id="14-5-反射的性能"><a href="#14-5-反射的性能" class="headerlink" title="14.5 反射的性能"></a>14.5 反射的性能</h2><p>反射的性能极差</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/11/f9dcb18c0cb7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/f9dcb18c0cb7/" class="post-title-link" itemprop="url">ch12-接口类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-17 00:00:00 / 修改时间：19:48:38" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/Go%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Go基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第12章-接口与类型"><a href="#第12章-接口与类型" class="headerlink" title="第12章 接口与类型"></a>第12章 接口与类型</h1><p>接口是为了抽象，方便代码解耦。</p>
<p>我对接口就是定义某些数据类型能够实现的方法集合，只要实现了这些方法集合的数据类型，就属于某个接口。</p>
<p>比较常用的是对struct去实现，因为struct内部能同时维护多个不同类型的数据，相当于是C++类的成员变量。当实现接口时，接口里的方法相当于是C++类里的方法，方法是可以对struct里的数据进行操作的。</p>
<p>虽然不同的struct可能实现方法的方式不同，但都属于一个接口。一个显而易见的好处就是，在函数传参的时候，参数定义为该interface类型，只要是实现了这个接口的实例，就能被当作参数传入，这样不用针对不同的数据类型定义参数不同但内部实现完全相同的函数。</p>
<blockquote>
<ul>
<li>鸭子类型：动态类型的一种风格，一个对象的有效语义不是继承自特定的类 或 实现特定的接口来决定，而是由当前的<strong>方法和属性</strong>的集合所决定。</li>
<li>鸭子测试：当一只鸟走起来像鸭子，游泳起来像鸭子，叫起来也像鸭子，那这只鸟就可以被称为鸭子。</li>
</ul>
</blockquote>
<p>一个类型可以实现多个接口；多个类型可以实现同一个接口；任何一个接口必然实现了空接口。</p>
<h2 id="12-1-接口的定义"><a href="#12-1-接口的定义" class="headerlink" title="12.1 接口的定义"></a>12.1 接口的定义</h2><p>接口是一个自定义<strong>类型</strong>，所以也需要type关键字，</p>
<ul>
<li><p>不会暴露内部属性结构，只会展示出方法，因此不能将接口实例化。</p>
</li>
<li><p>单个函数的接口名以”er”为后缀，接口的实现去掉“er”</p>
</li>
</ul>
<h2 id="12-2-接口的创建和实现"><a href="#12-2-接口的创建和实现" class="headerlink" title="12.2 接口的创建和实现"></a>12.2 接口的创建和实现</h2><h3 id="12-2-1-接口创建"><a href="#12-2-1-接口创建" class="headerlink" title="12.2.1 接口创建"></a>12.2.1 接口创建</h3><p>接口创建时内部只需要声明存在什么方法，而不需要实现。这是由用户定义的类型去实现的，实现了这些方法的具体类型就叫这个接口类型的实例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> InterfaceName <span class="keyword">interface</span>&#123;</span><br><span class="line">    Method()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-2-2-demo"><a href="#12-2-2-demo" class="headerlink" title="12.2.2 demo"></a>12.2.2 demo</h3><p>创建一个数据库操作接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IDatabaser <span class="keyword">interface</span>&#123;</span><br><span class="line">    Connect() <span class="type">error</span></span><br><span class="line">    Disconncet() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是两个类型实现了数据库操作接口IDatabaser的方法，所以是IDatabaser接口的实例。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230510111558257.png" alt="image-20230510111558257"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mysql <span class="keyword">struct</span> &#123; </span><br><span class="line">    DBName    <span class="type">string</span></span><br><span class="line">    isConnect <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mysql *Mysql)</span></span> Connect() <span class="type">error</span> &#123;  <span class="comment">// 指针类型，可以修改Mysql内部元素</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Mysql Connect DB =&gt;&quot;</span> + mysql.DBName)</span><br><span class="line">	mysql.isConnect = <span class="literal">true</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Mysql connect Success!&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mysql *Mysql)</span></span> Disconnect() <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Mysql Disconnect Success!&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Redis <span class="keyword">struct</span> &#123;</span><br><span class="line">	DBName    <span class="type">string</span></span><br><span class="line">	isConnect <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(redis *Redis)</span></span> Connect() <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Redis Connect DB =&gt;&quot;</span> + redis.DBName)</span><br><span class="line">	redis.isConnect = <span class="literal">true</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Redis connect Success!&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(redis *Redis)</span></span> Disconnect() <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Redis Disconnect Success!&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql1 = Mysql&#123;DBName: <span class="string">&quot;student&quot;</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;开始连接&quot;</span>)</span><br><span class="line">mysql1.Connect()</span><br><span class="line">fmt.Println(<span class="string">&quot;断开连接&quot;</span>)</span><br><span class="line">mysql1.Disconnect()</span><br><span class="line"><span class="keyword">var</span> redis1 = Redis&#123;DBName: <span class="string">&quot;teacher&quot;</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;开始连接&quot;</span>)</span><br><span class="line">redis1.Connect()</span><br><span class="line">fmt.Println(<span class="string">&quot;断开连接&quot;</span>)</span><br><span class="line">redis1.Disconnect()</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然定义了接口，但没有面向接口编程，很多地方有冗余。当面向接口编程时，如使用如下<code>HandleDB</code>，就可以处理多种不同的数据类型，称为go的多态：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleDB</span><span class="params">(db IDatabser)</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;开始连接&quot;</span>)</span><br><span class="line">   db.Connect()</span><br><span class="line">   fmt.Println(<span class="string">&quot;断开连接&quot;</span>)</span><br><span class="line">   db.Disconnect()</span><br><span class="line">&#125;</span><br><span class="line">HandleDB(&amp;mysql1)</span><br><span class="line">HandleDB(&amp;redis1)</span><br></pre></td></tr></table></figure>

<h3 id="12-2-3-接口赋值"><a href="#12-2-3-接口赋值" class="headerlink" title="12.2.3 接口赋值"></a>12.2.3 接口赋值</h3><p>如果用户自定义的类型实现了某个接口类型所声明的一组方法，那么这个用户定义的类型的 值 就可以赋值给这个接口。这个赋值会把用户定义的类型的值存入接口类型的值。个人认为，赋值后，这个接口实例就是类型实例。</p>
<p>这里涉及接口变量：1、分配给接口变量的具体值 2、值的类型的描述器（接口实现者的类型）</p>
<ul>
<li>情况1：对象实例赋值给接口</li>
<li>情况2：一个接口赋值给另一个接口<ul>
<li>两个接口拥有同样的方法，他们就是相同，可以相互赋值。</li>
<li>接口A方法集是接口B方法集的子集（B&gt;A），B可以赋值给A。反之不行</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口IDatabser</span></span><br><span class="line"><span class="keyword">type</span> IDatabser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Connect() <span class="type">error</span></span><br><span class="line">	Disconnect() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口IRedisr，是IDatabser的子集</span></span><br><span class="line"><span class="keyword">type</span> IRedisr <span class="keyword">interface</span> &#123;</span><br><span class="line">	Connect() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型，用于实现接口</span></span><br><span class="line"><span class="comment">/* 来自12.2.2，实现了Connect()和Disconnect()方法</span></span><br><span class="line"><span class="comment">type Redis struct &#123;</span></span><br><span class="line"><span class="comment">	DBName    string</span></span><br><span class="line"><span class="comment">	isConnect bool</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况1：类型的对象实例赋值给接口</span></span><br><span class="line"><span class="keyword">var</span> idb IDatabser = &amp;Redis&#123;DBName: <span class="string">&quot;teacher&quot;</span>&#125; <span class="comment">// IDatabser接口idb就是这个Redis实例</span></span><br><span class="line"><span class="comment">// 情况2：一个接口赋值给他的子集接口</span></span><br><span class="line"><span class="keyword">var</span> irds IRedisr = idb <span class="comment">// IRedisr接口irds被IDatabser接口idb赋值，并忽略了没有实现的方法</span></span><br><span class="line">irds.Connect()</span><br><span class="line"><span class="comment">// irds.Disconnect() 不可用</span></span><br><span class="line">fmt.Println(reflect.TypeOf(idb)) <span class="comment">// *main.Redis</span></span><br><span class="line">fmt.Println(reflect.TypeOf(irds)) <span class="comment">// *main.Redis</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230510115437386.png" alt="image-20230510115437386"></p>
<h2 id="12-3-接口嵌入-组合接口"><a href="#12-3-接口嵌入-组合接口" class="headerlink" title="12.3 接口嵌入&#x2F;组合接口"></a>12.3 接口嵌入&#x2F;组合接口</h2><p>类似于C++的继承。如果接口A作为接口B的嵌入字段，那么B隐式包含了A接口的所有方法。</p>
<ul>
<li><p>除了嵌入接口，接口不能嵌入其他类型。</p>
</li>
<li><p>不能嵌入自身，包括直接嵌入和间接嵌入。</p>
<p>否则都会报<code>invalid recursive type</code>错误。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> interfaceA <span class="keyword">interface</span> &#123;</span><br><span class="line">    Method()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> interfaceB <span class="keyword">interface</span> &#123;</span><br><span class="line">    interfaceA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12-4-空接口"><a href="#12-4-空接口" class="headerlink" title="12.4 空接口"></a>12.4 空接口</h2><p><code>interface&#123;&#125;</code>不包含任何方法的接口，所以空接口可以存储任意类型的数值。但空接口存的内容 不能 能赋值给其他明确的类型（当然使用<code>:=</code>是可用的，但并不是其他类型，编译器仍推断其为空接口）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;123&quot;</span> </span><br><span class="line"><span class="keyword">var</span> interfaceStr <span class="keyword">interface</span>&#123;&#125; = str <span class="comment">// 空接口</span></span><br><span class="line"><span class="keyword">var</span> str2 = interfaceStr <span class="comment">// 可以</span></span><br><span class="line"><span class="comment">// var str2 string = interfaceStr // 不可以</span></span><br><span class="line">fmt.Println(reflect.TypeOf(interfaceStr)) <span class="comment">// string</span></span><br><span class="line">fmt.Println(reflect.TypeOf(str2))  <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>空接口常用在函数参数里，如下，用来传递多个不同类型的参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Log</span><span class="params">(paras ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, para := <span class="keyword">range</span> paras &#123;</span><br><span class="line">      fmt.Println(para)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">interList := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line">interList[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">interList[<span class="number">1</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line">interList[<span class="number">2</span>] = []<span class="type">string</span>&#123;<span class="string">&quot;str1&quot;</span>, <span class="string">&quot;str2&quot;</span>&#125;</span><br><span class="line">Log(interList...)  <span class="comment">// ...意思是将该切片拆散传入参数列表</span></span><br></pre></td></tr></table></figure>



<h2 id="12-5-类型断言"><a href="#12-5-类型断言" class="headerlink" title="12.5 类型断言"></a>12.5 类型断言</h2><p>通过类型断言，我们可以将接口值转换为其底层的具体类型，并访问该类型特有的方法或属性。</p>
<p><strong>类型断言是应用在接口变量上的操作</strong>，空接口不能赋值给其他类型，只能用类型断言。</p>
<p>类型断言其实就是类型转换，但不是强制类型转换，存了int的空接口只能用类型断言赋值给int变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valT, ok := X.(T) </span><br></pre></td></tr></table></figure>
<p>断言失败时会抛出panic，除非用两个变量接收检查的结果。<br>判断接口变量X，是否为T类型，</p>
<ul>
<li>如果断言成功，valT是接口变量X的动态值，</li>
<li>如果断言失败，valT的类型为T，值为T的初始值</li>
</ul>
<h3 id="动态类型和静态类型"><a href="#动态类型和静态类型" class="headerlink" title="动态类型和静态类型"></a>动态类型和静态类型</h3><ul>
<li>动态类型</li>
<li>静态类型</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/258617170">22. 图解：Go语言中的静态类型与动态类型 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h3 id="情况1：TypeName是具体类型"><a href="#情况1：TypeName是具体类型" class="headerlink" title="情况1：TypeName是具体类型"></a>情况1：TypeName是具体类型</h3><p>如果断言的类型T是一个具体类型，X.(T)就检查X的<strong>动态类型</strong>是否和T的相同</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkType</span><span class="params">(valT <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;断言成功&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;断言失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, valT, valT)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> interfaceX <span class="keyword">interface</span>&#123;&#125; = <span class="number">1</span> <span class="comment">// 空接口存int类型</span></span><br><span class="line">	valT0, OK := interfaceX.(<span class="type">string</span>) <span class="comment">// 断言为string，失败，valT0是string类型，初始值&quot;&quot;</span></span><br><span class="line">	checkType(valT0, OK)  </span><br><span class="line">    <span class="comment">//  断言失败</span></span><br><span class="line">    <span class="comment">// type =&gt; string value =&gt; </span></span><br><span class="line">	valT1, OK := interfaceX.(<span class="type">int</span>)  <span class="comment">// 断言为int，成功</span></span><br><span class="line">	checkType(valT1, OK) </span><br><span class="line">    <span class="comment">//  断言成功                </span></span><br><span class="line">    <span class="comment">// type =&gt; int value =&gt; 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="情况2：TypeName是接口类型"><a href="#情况2：TypeName是接口类型" class="headerlink" title="情况2：TypeName是接口类型"></a>情况2：TypeName是接口类型</h3><p>如果断言的类型TypeName是一个接口类型，就检查interfaceX的<strong>动态类型</strong>是否满足TypeName的接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口Person</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">	Speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student结构体类型</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Nmae <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Person接口方法，所以Student是接口Person的实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span></span> Speak() &#123;</span><br><span class="line">	fmt.Println(s.Nmae)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkType</span><span class="params">(valT <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;断言成功&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;断言失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, valT, valT)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> student <span class="keyword">interface</span>&#123;&#125; = Student&#123;<span class="string">&quot;walle&quot;</span>&#125;</span><br><span class="line">	valT0, ok := student.(<span class="type">int</span>)  <span class="comment">// 检查student的动态类型是否与int相同</span></span><br><span class="line">	checkType(valT0, ok)</span><br><span class="line">	<span class="comment">// 断言失败</span></span><br><span class="line">	<span class="comment">// type =&gt; int value =&gt; 0</span></span><br><span class="line">    </span><br><span class="line">	valT1, ok := student.(Person) <span class="comment">// 检查student的动态类型是否与Person相同</span></span><br><span class="line">	checkType(valT1, ok)</span><br><span class="line">	<span class="comment">// 断言成功                             </span></span><br><span class="line">	<span class="comment">// type =&gt; main.Student value =&gt; &#123;walle&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-5-1-ok-pattern和switch-type"><a href="#12-5-1-ok-pattern和switch-type" class="headerlink" title="12.5.1 ok-pattern和switch-type"></a>12.5.1 ok-pattern和switch-type</h3><p>接口类型断言的两种方式：ok-pattern和switch-type</p>
<h4 id="ok-pattern"><a href="#ok-pattern" class="headerlink" title="ok-pattern"></a>ok-pattern</h4><p>适用于要断言的<strong>接口类型种类</strong>typeName较少</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> value, ok := 接口变量.(类型)； ok ==<span class="literal">true</span> &#123;</span><br><span class="line">    <span class="comment">// 是该类型时的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="switch-pattern"><a href="#switch-pattern" class="headerlink" title="switch-pattern"></a>switch-pattern</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> value := 接口变量.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> 类型<span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 是该类型时的处理</span></span><br><span class="line">    <span class="keyword">case</span> 类型<span class="number">2</span>:</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line">	s[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	s[<span class="number">1</span>] = <span class="string">&quot;abc&quot;</span></span><br><span class="line">	s[<span class="number">2</span>] = Person&#123;<span class="string">&quot;walle&quot;</span>, <span class="number">100</span>&#125;</span><br><span class="line">	<span class="comment">// ok-pattern</span></span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">if</span> t, ok := value.(<span class="type">int</span>); ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, t, t)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> t, ok := value.(<span class="type">string</span>); ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, t, t)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> t, ok := value.(Person); ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, t, t)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// switch-pattern</span></span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">switch</span> t := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, t, t)</span><br><span class="line">		<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, t, t)</span><br><span class="line">		<span class="keyword">case</span> Person:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;type =&gt; %T value =&gt; %v\n&quot;</span>, t, t)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12-7-侵入式-非侵入式接口"><a href="#12-7-侵入式-非侵入式接口" class="headerlink" title="12.7 侵入式&#x2F;非侵入式接口"></a>12.7 侵入式&#x2F;非侵入式接口</h2><ul>
<li><p>侵入式接口：需要显式地创建一个类去实现一个接口。</p>
</li>
<li><p>非侵入式接口：不需要显式</p>
<p>go接口属于非侵入式，更为灵活</p>
</li>
</ul>
<h2 id="12-8-有趣的接口"><a href="#12-8-有趣的接口" class="headerlink" title="12.8 有趣的接口"></a>12.8 有趣的接口</h2><h3 id="fmt包的Stringer接口"><a href="#fmt包的Stringer接口" class="headerlink" title="fmt包的Stringer接口"></a>fmt包的Stringer接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A <code>Stringer</code> is a type that can describe itself as a string. The <code>fmt</code> package (and many others) look for this interface to print values.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了string()方法，所以是fmt包里的Stringer()接口的实例</span></span><br><span class="line"><span class="comment">// 返回值是string，打印自己的内部变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">	z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">	fmt.Println(a, z) <span class="comment">// a和z都可以调用String()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/11/861a8f3c4257/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/861a8f3c4257/" class="post-title-link" itemprop="url">ch17-HTTP编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-17 00:00:00 / 修改时间：19:48:54" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/Go%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Go基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="17-HTTP编程"><a href="#17-HTTP编程" class="headerlink" title="17 HTTP编程"></a>17 HTTP编程</h1><ul>
<li>HTTP基于TCP协议上建立</li>
<li>当建立在TLS或SSL协议上时，协议变成了加密HTTPS协议</li>
</ul>
<h3 id="17-1-2-URL地址"><a href="#17-1-2-URL地址" class="headerlink" title="17.1.2 URL地址"></a>17.1.2 URL地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">协议://主机地址/路径?查询</span><br><span class="line">https://www.baidu.com/s?wd=Go语言</span><br><span class="line"></span><br><span class="line">协议://用户名:密码@子域名.域名.顶级域名:端口号/目录/文件名.文件后缀?参数=值#标志</span><br><span class="line">http://admin:password@ceshi.baidu.com:8080/dir/test.php?id=1#flag=1</span><br></pre></td></tr></table></figure>

<h2 id="17-2-HTTP客户端"><a href="#17-2-HTTP客户端" class="headerlink" title="17.2 HTTP客户端"></a>17.2 HTTP客户端</h2><p>RESTful风格路由 Representational State Transfer </p>
<ul>
<li>GET（READ）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
</ul>
<p>对客户端请求用得最多的两个：GET和POST</p>
<ul>
<li>GET 从指定的资源请求数据</li>
<li>POST 向指定的资源提交要被处理的数据</li>
</ul>
<p>1、GET用来从服务器获取数据，POST用来向服务器传输数据<br>2、GET不安全，请求会被放在URL，Header和data一起发出。而POST的操作对用户不可见，浏览器会先发送Header，服务器响应100后，再发送data。<br>3、GET传输数据量小，受URL长度限制，Form表单数据集的值必须是ASCII；POST可以传大量数据，且支持整个ISO 10646字符集。</p>
<h1 id="三个重要的结构体"><a href="#三个重要的结构体" class="headerlink" title="三个重要的结构体"></a>三个重要的结构体</h1><h2 id="1、Client结构体"><a href="#1、Client结构体" class="headerlink" title="1、Client结构体"></a>1、Client结构体</h2><p>Client结构体类型主要充当浏览器角色，创建时结构体成员可以是默认值（无特殊需求基本是默认值）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    Transport RoundTripper</span><br><span class="line">    CheckRedirect <span class="function"><span class="keyword">func</span></span> &#123;req *Request, via []*Request) <span class="type">error</span></span><br><span class="line">    Jar CookieJar</span><br><span class="line">    Timeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Transport指定执行独立、单次HTTP请求机制。若为nil，则是DefaultTransport</li>
<li>CheckRedirect指定重定向策略。如果为nil，采用默认策略连续10次请求后停止。</li>
<li>Jar指定Cookie管理器。若为nil，请求和回复cookie都忽略。</li>
<li>Timeout指定请求时间限制，包括连接时间、重定向、读取回复主体的时间。0表示不设置超时。</li>
</ul>
<p>拥有如下方法对资源增删改查，其中最重要的是<code>Do</code>方法，其他方法都是对do方法的封装。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clinet)</span></span> Do(req *Request) (resp *Response, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clinet)</span></span> Head(url *<span class="type">string</span>) (resp *Response, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clinet)</span></span> Get(url *<span class="type">string</span>) (resp *Response, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clinet)</span></span> Post(url *<span class="type">string</span>, bodyType <span class="type">string</span>, body io.Reader) (resp *Response, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clinet)</span></span> PostForm(url *<span class="type">string</span>, data url.Values) (resp *Response, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>





<h2 id="2、Request结构体："><a href="#2、Request结构体：" class="headerlink" title="2、Request结构体："></a>2、Request结构体：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequest</span><span class="params">(method, urlStr <span class="type">string</span>, body io.Reader)</span></span> (*Request,<span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>返回Request结构体指针，指定方法、访问url以及io.Reader接口的body，当method为GET时，body&#x3D;nil即可。</p>
<p>如果参数body实现了的io.ReadCloser接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	Method           <span class="type">string</span>               <span class="comment">// 请求方法</span></span><br><span class="line">	URL              *url.URL             <span class="comment">// 请求地址</span></span><br><span class="line">	Proto            <span class="type">string</span>               <span class="comment">// 协议版本，&quot;HTTP/1.0&quot;</span></span><br><span class="line">	ProtoMajor       <span class="type">int</span>                  <span class="comment">// 协议主版本号，“1”</span></span><br><span class="line">	ProtoMinor       <span class="type">int</span>                  <span class="comment">// 协议主副版本号，“0”</span></span><br><span class="line">	Header           Header               <span class="comment">// 请求头</span></span><br><span class="line">	Body             io.ReadCloser        <span class="comment">// 请求的Body</span></span><br><span class="line">	ContentLength    <span class="type">int64</span>                <span class="comment">// ContentLength记录相关内容的长度</span></span><br><span class="line">	TransferEncoding []<span class="type">string</span>             <span class="comment">// TransferEncoding按从最外到最里的顺序列出传输编码</span></span><br><span class="line">	Close            <span class="type">bool</span>                 <span class="comment">// Close在服务端指定是否在回复请求后关闭连接，在客户端指定是否在发送请求后关闭连接</span></span><br><span class="line">	Host             <span class="type">string</span>               <span class="comment">// Host指定URL会在其上寻找资源的主机</span></span><br><span class="line">	Form             url.Values           <span class="comment">// Form是解析好的表单数据，包括URL字段的query参数和POST或PUT的表单数据</span></span><br><span class="line">	PostForm         url.Values           <span class="comment">// PostForm是解析好的POST或PUT的表单数据</span></span><br><span class="line">	MultipartForm    *multipart.Form      <span class="comment">// MultipartForm是解析好的多部件表单，包括上传的文件</span></span><br><span class="line">	Trailer          Header               <span class="comment">// Trailer指定了会在请求主体之后发送的额外的头域</span></span><br><span class="line">	RemoteAddr       <span class="type">string</span>               <span class="comment">// RemoteAddr允许HTTP服务器和其他软件记录该请求的来源地址，一般用于日志</span></span><br><span class="line">	RequestURI       <span class="type">string</span>               <span class="comment">// RequestURI是被客户端发送到服务端的请求中未修改的URI</span></span><br><span class="line">	TLS              *tls.ConnectionState <span class="comment">// TLS字段允许HTTP服务器和其他软件记录接收到该请求的TLS连接的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3、Response结构体"><a href="#3、Response结构体" class="headerlink" title="3、Response结构体"></a>3、Response结构体</h2><p>请求都会返回Response结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    Status           <span class="type">string</span>               <span class="comment">//表示HTTP响应的状态行中的状态码和原因短语，例如&quot;200 OK&quot;</span></span><br><span class="line">    StatusCode       <span class="type">int</span>                  <span class="comment">//表示HTTP响应的状态码，例如200</span></span><br><span class="line">    Proto            <span class="type">string</span>               <span class="comment">//表示使用的HTTP协议版本，例如&quot;HTTP/1.1&quot;</span></span><br><span class="line">    ProtoMajor       <span class="type">int</span>                  <span class="comment">//表示使用的HTTP协议版本的主版本号，例如1</span></span><br><span class="line">    ProtoMinor       <span class="type">int</span>                  <span class="comment">//表示使用的HTTP协议版本的副版本号，例如1</span></span><br><span class="line">    Header           Header               <span class="comment">//表示HTTP响应的头部信息，是一个Header类型的映射</span></span><br><span class="line">    Body             io.ReadCloser        <span class="comment">//表示HTTP响应的主体，是一个io.ReadCloser类型的接口，可以读取响应的数据</span></span><br><span class="line">    ContentLength    <span class="type">int64</span>                <span class="comment">//表示HTTP响应的主体的长度，如果长度未知则为-1</span></span><br><span class="line">    TransferEncoding []<span class="type">string</span>             <span class="comment">//表示HTTP响应的传输编码，例如&quot;chunked&quot;，如果未设置则为nil</span></span><br><span class="line">    Close            <span class="type">bool</span>                 <span class="comment">//表示HTTP响应是否需要关闭连接</span></span><br><span class="line">    Uncompressed     <span class="type">bool</span>                 <span class="comment">//表示HTTP响应是否已经解压缩</span></span><br><span class="line">    Trailer          Header               <span class="comment">//表示HTTP响应的头部信息中未确定的部分</span></span><br><span class="line">    Request          *Request             <span class="comment">//表示发送HTTP请求的Request结构体，如果未设置则为nil</span></span><br><span class="line">    TLS              *tls.ConnectionState <span class="comment">//表示HTTP响应的TLS连接信息，如果未使用TLS则为nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>需要注意的是，Request结构体和Response结构体中的Body都是io.ReadCloser类型，需要使用io.ReadAll读取，同时，需要主动去close()。</strong></p>
<h2 id="发起请求的两种方式"><a href="#发起请求的两种方式" class="headerlink" title="发起请求的两种方式"></a>发起请求的两种方式</h2><h3 id="1、创建客户端结构体、请求结构体进行请求"><a href="#1、创建客户端结构体、请求结构体进行请求" class="headerlink" title="1、创建客户端结构体、请求结构体进行请求"></a>1、创建客户端结构体、请求结构体进行请求</h3><h4 id="优点：可以定制request的细节。"><a href="#优点：可以定制request的细节。" class="headerlink" title="优点：可以定制request的细节。"></a>优点：可以定制request的细节。</h4><h4 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h4><ol>
<li>创建 客户端结构体 http.Client{} </li>
<li>NewRequest生成 请求结构体</li>
<li>设置请求结构体的内容，如header、cookie</li>
<li>客户端结构体调用请求方法</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequest</span><span class="params">(method, urlStr <span class="type">string</span>, body io.Reader)</span></span> (*Request, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>NewRequest输入访问的类型、url 以及 body，返回一个<strong>Request结构体</strong>地址。</p>
<p>POST请求需要用到body。</p>
<h4 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h4><p>使用Request结构体的Do方法，所以要先用NewRequest创建请求结构体。GET方法不需要body字段，所以NewRequest中body为nil。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建client</span></span><br><span class="line">	client := &amp;http.Client&#123;&#125;</span><br><span class="line">    <span class="comment">// 新建请求request结构体</span></span><br><span class="line">	request, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://www.baidu.com&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置request结构体的Header模仿浏览器（非必要）</span></span><br><span class="line">	request.Header.Set(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;</span>)</span><br><span class="line">	request.Header.Set(<span class="string">&quot;Accept-Charset&quot;</span>, <span class="string">&quot;GBK,utf-8;q=0.7,*;q=0.3&quot;</span>)</span><br><span class="line">	request.Header.Set(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip,deflate,sdch&quot;</span>)</span><br><span class="line">	request.Header.Set(<span class="string">&quot;Accept-Language&quot;</span>, <span class="string">&quot;zh-CN,zh;q=0.8&quot;</span>)</span><br><span class="line">	request.Header.Set(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;max-age=0&quot;</span>)</span><br><span class="line">	request.Header.Set(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;keep-alive&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加cookie两种方式，模拟登录（非必要） [userId=12345 session=YWRtaW4=]</span></span><br><span class="line">	cookie := &amp;http.Cookie&#123;Name: <span class="string">&quot;userID&quot;</span>, Value: strconv.Itoa(<span class="number">12345</span>)&#125; <span class="comment">// 新建</span></span><br><span class="line">    <span class="comment">// 为request添加cookie</span></span><br><span class="line">	request.AddCookie(cookie)</span><br><span class="line">	request.AddCookie(&amp;http.Cookie&#123;Name: <span class="string">&quot;session&quot;</span>, Value: <span class="string">&quot;YWRtaW4=&quot;</span>&#125;) </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用Do请求</span></span><br><span class="line">	response, err := client.Do(request)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fmt.Println(response.StatusCode) <span class="comment">// 打印响应状态码</span></span><br><span class="line">	fmt.Println(response.Request.Header) <span class="comment">// 打印请求头</span></span><br><span class="line">	fmt.Println(response.Request.Cookies()) <span class="comment">// 打印cookie</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 打印响应体</span></span><br><span class="line">	responseBody, err := io.ReadAll(response.Body)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(responseBody))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2、http包直接请求"><a href="#2、http包直接请求" class="headerlink" title="2、http包直接请求"></a>2、http包直接请求</h3><p>例如使用http包的<code>GET()</code>，可以快速发起一个GET请求。底层就是调用Client结构体的GET方法，底层的GET方法是对DO方法的封装。不需要NewRequest创建结构体，直接请求url。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">response, err := http.Get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> response.Body.Close()  </span><br><span class="line">body, _ := ioutil.ReadAll(response.Body)</span><br><span class="line">fmt.Println(<span class="type">string</span>(body))</span><br></pre></td></tr></table></figure>



<h2 id="17-2-3-发起POST请求"><a href="#17-2-3-发起POST请求" class="headerlink" title="17.2.3 发起POST请求"></a>17.2.3 发起POST请求</h2><p>POST要用到Body字段，所以使用NewRequest时需要设置。io.Closer接口若被实现，会被Client类型的Do、Post和PostForm方法以及Transport.RoundTrip方法关闭。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/11/f9e8bdee9563/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/f9e8bdee9563/" class="post-title-link" itemprop="url">ch13-并发与通道</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-17 00:00:00 / 修改时间：19:48:45" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/Go%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Go基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第13章-并发与通道"><a href="#第13章-并发与通道" class="headerlink" title="第13章 并发与通道"></a>第13章 并发与通道</h1><p>协程（coroutine），属于多线程编程</p>
<ul>
<li>并行：同一时刻，多条指令在多处理器运行</li>
<li>并发：同一时刻只有一条指令执行，但多个进程被快速的轮回执行。宏观上达到多进程同时执行的效果。</li>
</ul>
<p>Go语言的并发基于（Communication Sequential Process, 通信顺序进程）模型，该模型用于描述两个独立并发实体，通过共享的通信<strong>管道</strong>（而非共享内存）进行通信的并发模型。</p>
<p>对于CSP模型，显式的锁可以被避免，通过安全的通道发送和接收数据实现同步。</p>
<h2 id="13-2-goroutine"><a href="#13-2-goroutine" class="headerlink" title="13.2 goroutine"></a>13.2 goroutine</h2><p>比线程更加轻量：</p>
<ul>
<li>协程和线程对用户而言几乎没区别。但实际上线程是基本有2MB固定栈；而协程采用动态扩张的栈，初始化2KB，最大扩张到1GB。</li>
<li>每个线程有一个id，所以可以方便地通过id操作线程；协程没有，不能通过一个协程杀死另一个协程，他们的创建和释放需要在编码时考虑（重要）。</li>
<li>线程的切换需要陷入内核，然后上下文切换；协程在用户态就能由协程调度器完成，代价更小，尽管切换点都是时间片用完，或者进入IO或睡眠等状态。</li>
<li>垃圾回收的必要条件的 <strong>内存位于一致状态</strong>。交给OS去做会暂停所有线程使一致，而GO中的调度器知道什么时候一致，就没必要暂停所有运行的线程。</li>
</ul>
<h3 id="13-2-2-创建goroutine"><a href="#13-2-2-创建goroutine" class="headerlink" title="13.2.2 创建goroutine"></a>13.2.2 创建goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名(参数)</span><br></pre></td></tr></table></figure>
<p>若函数有返回值，返回值会被忽略，只能使用channel。</p>
<ul>
<li>例程：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Task1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>), <span class="string">&quot;Task1&quot;</span>)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Task2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>), <span class="string">&quot;Task2&quot;</span>)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> Task1()</span><br><span class="line">	<span class="keyword">go</span> Task2()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>), <span class="string">&quot;Main&quot;</span>)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
main函数会在一个单独的goroutine中运行，新的goroutine会用go创建。当运行下面的代码，会立刻返回，因为当Task1的协程被切换成main goroutine，main中没有任何代码逻辑，程序被判断执行完毕，所有协程终止。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> Task1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
main函数终止，所有goroutine也会一并结束；终止goroutine的最好办法是在函数中自然返回。</li>
</ul>
<h3 id="13-2-4-匿名函数创建goroutine"><a href="#13-2-4-匿名函数创建goroutine" class="headerlink" title="13.2.4 匿名函数创建goroutine"></a>13.2.4 匿名函数创建goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 匿名函数</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			fmt.Println(time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>), <span class="string">&quot;Task2&quot;</span>)</span><br><span class="line">			time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(time.Second * <span class="number">100</span>) <span class="comment">// 防止main终止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-2-5-runtime包"><a href="#13-2-5-runtime包" class="headerlink" title="13.2.5 runtime包"></a>13.2.5 runtime包</h3><p>一个小型任务调度器</p>
<h4 id="1-Gosched"><a href="#1-Gosched" class="headerlink" title="1 Gosched()"></a>1 Gosched()</h4><p>使得调用它的协程放弃处理器，会在未来恢复执行。<br>协程是抢占式调度，出现如下情况，goroutine发送调度</p>
<ul>
<li>syscall</li>
<li>C函数调用，本质和syscall一样</li>
<li>主动调用<code>runtime.Gosched</code></li>
<li>某个goroutine调度时间超过100ms，且其调用了<strong>非内联</strong>函数<blockquote>
<p>内敛函数就是调用一个函数的时候是将函数代码插入到当前位置，而不是执行调用。能加快运行速度。</p>
</blockquote>
</li>
</ul>
<h5 id="例程："><a href="#例程：" class="headerlink" title="例程："></a>例程：</h5><p>若将<code>runtime.Gosched()</code>注释掉，main goroutine会很快执行完成，使得匿名函数goroutine无法抢占cpu。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;go&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		runtime.Gosched()</span><br><span class="line">		fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-Goexit"><a href="#2-Goexit" class="headerlink" title="2 Goexit()"></a>2 Goexit()</h4><p><code>Goexit()</code><strong>终止</strong>调用它的Go协程，其他Go协程不受影响。若有defer会执行。<br>试了一下，main goroutine似乎不能调用<code>Goexit()</code>。</p>
<blockquote>
<p>fatal error: no goroutines (main called runtime.Goexit) - deadlock!</p>
</blockquote>
<h5 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Task3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;task1 end&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task1 start&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task1 work&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Task4</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;task2 end&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task2 start&quot;</span>)</span><br><span class="line">	runtime.Goexit()</span><br><span class="line">	fmt.Println(<span class="string">&quot;task2 work&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> Task3()</span><br><span class="line">	<span class="keyword">go</span> Task4()</span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-GOMAXPROCS"><a href="#3-GOMAXPROCS" class="headerlink" title="3 GOMAXPROCS()"></a>3 GOMAXPROCS()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOMAXPROCS(n <span class="type">int</span>) <span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>该函数设置程序在运行中所使用的CPU数，默认最大，n&lt;1就不更改设置。会返回先前的设置，即第一次设置会返回。<br>机器逻辑CPU数（也可以用<code>runtime.NumCPU()</code>查询）。</p>
<h5 id="例程-1"><a href="#例程-1" class="headerlink" title="例程"></a>例程</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">KillTimeWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			a := <span class="number">99999</span> ^ <span class="number">99999</span></span><br><span class="line">			a = a + <span class="number">1</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;CPU num:&quot;</span>, runtime.NumCPU())</span><br><span class="line">	n := runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;previous setting: &quot;</span>, n)</span><br><span class="line">	fmt.Println(<span class="string">&quot;now setting 1&quot;</span>)</span><br><span class="line">	flag1 := time.Now()</span><br><span class="line">	KillTimeWork()</span><br><span class="line">	flag2 := time.Now()</span><br><span class="line">	fmt.Println(<span class="string">&quot;KillTimeWork() cost:&quot;</span>, flag2.Sub(flag1))</span><br><span class="line"></span><br><span class="line">	n = runtime.GOMAXPROCS(<span class="number">12</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;previous setting: &quot;</span>, n)</span><br><span class="line">	fmt.Println(<span class="string">&quot;now setting: &quot;</span>, runtime.NumCPU())</span><br><span class="line">	flag1 = time.Now()</span><br><span class="line">	KillTimeWork()</span><br><span class="line">	flag2 = time.Now()</span><br><span class="line">	fmt.Println(<span class="string">&quot;KillTimeWork() cost:&quot;</span>, flag2.Sub(flag1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CPU型号R55600，6核心12线程，刚好12线程对应逻辑CPU数，显然12个协程<strong>并行</strong>会比1个协程快得多。</p>
<blockquote>
<p>CPU num: 12<br>previous setting:  12<br>now setting 1<br>KillTimeWork() cost: 19.5095ms<br>previous setting:  1<br>now setting:  12<br>KillTimeWork() cost: 1.6618ms</p>
</blockquote>
<h2 id="13-3-channel"><a href="#13-3-channel" class="headerlink" title="13.3 channel"></a>13.3 channel</h2><ul>
<li>channel其实就是FIFO的队列，不需要加锁，因为其内部实现同步，保证了并发安全。</li>
<li>往空channel取，会死锁，相当于是一直等待一个</li>
</ul>
<blockquote>
<p>goroutine运行在相同的地址空间，访问共享内存要做好同步。</p>
<p>引用类型是CSP模式的具体实现，用于多个goroutine之间的通信。</p>
</blockquote>
<h3 id="13-3-1-channel基础用法"><a href="#13-3-1-channel基础用法" class="headerlink" title="13.3.1 channel基础用法"></a>13.3.1 channel基础用法</h3><p>声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 通道变量 <span class="keyword">chan</span> Type <span class="comment">// nil channel，无论接受和发送都会被阻塞</span></span><br></pre></td></tr></table></figure>
<ul>
<li>引用类型channel是CSP模式的具体体现，内部实现了同步，保证了并发安全，用于goroutine之间的通信。</li>
<li>channel是 make创建 的底层数据结构的<strong>引用</strong>，这一点和map类似。复制channel或用于参数传递时，只是拷贝了一个channel引用。</li>
<li>数据接收格式：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channel &lt;- value <span class="comment">// 写入</span></span><br><span class="line">value, ok &lt;- channel <span class="comment">// 向channel接收并保存，ok检查通道是否关闭</span></span><br><span class="line">&lt;- channel <span class="comment">// 接收但丢弃</span></span><br><span class="line"><span class="built_in">len</span>(ch) <span class="comment">// 长度 	</span></span><br><span class="line"><span class="built_in">cap</span>(ch) <span class="comment">//容量</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>也可以是接口通道，但取出来的东西需要类型断言  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>



<h3 id="13-3-2-初始化-缓冲机制"><a href="#13-3-2-初始化-缓冲机制" class="headerlink" title="13.3.2 初始化+缓冲机制"></a>13.3.2 初始化+缓冲机制</h3><p>一句话而言，就是channel空时阻塞读，channel满时阻塞写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type) <span class="comment">// 即make(chan Type, 0)</span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type, capacity)</span><br></pre></td></tr></table></figure>
<ul>
<li>capacity&#x3D;&#x3D;0，channel是<strong>无缓冲阻塞读写</strong>；</li>
<li>capacity&gt;0则是<strong>有缓冲非阻塞</strong>，直到写满capacity个元素才<strong>阻塞</strong>写入（不让写入，进入阻塞）。</li>
</ul>
<p>无缓冲的意思是：先执行<strong>发送或接收</strong>的goroutine阻塞等待，直到有其他 goroutine接收或发送。</p>
<h5 id="例程-2"><a href="#例程-2" class="headerlink" title="例程"></a>例程</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>) <span class="comment">// 有缓冲</span></span><br><span class="line"><span class="comment">// ch := make(chan int)  // 无缓冲</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;len(ch)=%v, cap(ch)=%v\n&quot;</span>, <span class="built_in">len</span>(ch), <span class="built_in">cap</span>(ch))</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无缓冲时，main goroutine主动sleep，每1秒收一次数据，所以匿名函数goroutine每次输入通道，都会阻塞，直到通道的内容被取走。</p>
<blockquote>
<p>len(ch)&#x3D;0, cap(ch)&#x3D;0<br>0<br>len(ch)&#x3D;0, cap(ch)&#x3D;0<br>1<br>len(ch)&#x3D;0, cap(ch)&#x3D;0<br>2</p>
</blockquote>
<p>此例中，有缓冲时，匿名函数goroutine一股脑输入通道，无需阻塞，后续main goroutine每隔一秒从缓冲中取。</p>
<blockquote>
<p>len(ch)&#x3D;0, cap(ch)&#x3D;3<br>len(ch)&#x3D;1, cap(ch)&#x3D;3<br>len(ch)&#x3D;2, cap(ch)&#x3D;3<br>0<br>1<br>2</p>
</blockquote>
<h3 id="13-3-2-close和range"><a href="#13-3-2-close和range" class="headerlink" title="13.3.2 close和range"></a>13.3.2 close和range</h3><h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><p>当发送者本身没有更多值要发给channel，可以通过close让接收者知道，停止不必要的等待。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>
<ul>
<li>不需要经常关闭，实在没有任何数据传输再关闭</li>
<li>关闭后无法向channel发送数据，也无法再调用close，否则panic</li>
<li>关闭后仍能从中读取</li>
<li>nil channel无论接受和发送都会被阻塞</li>
</ul>
<p>在向channel取元素时，还会返回ok，如果ok&#x3D;&#x3D;true，表示通道已经关闭。</p>
<h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>调用了close()后，除了读取通道返回ok得知通道是否关闭，还能通过<code>range()</code>知道，此时通道一定要关闭，否则出错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;len(ch)=%v, cap(ch)=%v\n&quot;</span>, <span class="built_in">len</span>(ch), <span class="built_in">cap</span>(ch))</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)   <span class="comment">// ---------应当关闭，否则方式1和方式2都会抛出panic</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 方式1：range通道</span></span><br><span class="line"><span class="keyword">for</span> val := <span class="keyword">range</span> ch &#123;</span><br><span class="line">	fmt.Println(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：for循环读取</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    val, ok := &lt;-ch</span><br><span class="line">    <span class="keyword">if</span> ok &#123;  <span class="comment">// 如果channel关闭，ok==false</span></span><br><span class="line">        <span class="built_in">println</span>(val)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么range和for遍历通道前，一定要close通道？（暂时不知道有多个协程时是否一定，但只有main go routine时一定要close）</p>
<blockquote>
<p>当所有的其他goroutine终止，而只剩一个goroutine在阻塞读取通道，因为不可能有其他goroutine写入通道，导致死锁，会产生<strong>死锁</strong>panic：<code>fatal error: all goroutines are asleep - deadlock!    </code>。</p>
</blockquote>
<h3 id="13-3-4-单向channel"><a href="#13-3-4-单向channel" class="headerlink" title="13.3.4 单向channel"></a>13.3.4 单向channel</h3><p>单向管道的意义：</p>
<ul>
<li>可以作为方法的参数，限制方法内部对管道的读写，误操作。</li>
<li>底层处理效率更高</li>
</ul>
<p>此处需要注意，输入输出是针对通道而言的，输出是通道向外发送。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// ch1为一个双向通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span>&lt;- <span class="type">int</span> <span class="comment">// ch2为一个只能接收的单向通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 &lt;-<span class="keyword">chan</span> <span class="type">int</span>  <span class="comment">//  ch3为只能输出的单向通道</span></span><br></pre></td></tr></table></figure>
<h5 id="例程-生产者消费者模型"><a href="#例程-生产者消费者模型" class="headerlink" title="例程  生产者消费者模型"></a>例程  生产者消费者模型</h5><p>双向channe可以隐式转换为单向channel，反过来不行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;  <span class="comment">// 通道只能接收数据，生产者函数</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		out &lt;- i <span class="comment">// 输出</span></span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">comsumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;  <span class="comment">// 通道只能输出数据，生产者函数</span></span><br><span class="line">	<span class="keyword">for</span> val := <span class="keyword">range</span> in &#123; <span class="comment">// 输出</span></span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">go</span> producer(ch) <span class="comment">// 隐式转换为单向</span></span><br><span class="line">	comsumer(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例程2-定时器"><a href="#例程2-定时器" class="headerlink" title="例程2 定时器"></a>例程2 定时器</h5><p>标准库time的定时器NewTicker。<br>NewTicker.C就是一个<strong>无缓冲单通道channel</strong>，个人猜测是内部每1秒会向该通道输入，所以向其取数时，会有1秒的间隔时长。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	fmt.Println(&lt;-ticker.C) <span class="comment">// 1秒</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;loop&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-4-select"><a href="#13-4-select" class="headerlink" title="13.4 select"></a>13.4 select</h2><p>select监听channel上的数据流动，类似switch。</p>
<ul>
<li>有较多限制，最大限制是每个case语句里必须是一个IO操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-chan1:</span><br><span class="line"><span class="comment">//如果没有阻塞，执行</span></span><br><span class="line"><span class="keyword">case</span> &lt;-chan2:</span><br><span class="line"><span class="comment">//如果没有阻塞，执行</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 都阻塞，执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在一个select语句中，Go语言会按顺序<strong>从头至尾</strong>评估每一个发送和接收语句。有多个语句可以继续执行（没有被阻塞），那么就从那些可以执行的语句中<strong>随机</strong>选择一条来使用。</li>
<li>如果没有default，case都不满足时会被阻塞，直到有一个case的IO可以进行。</li>
</ul>
<h5 id="例程-3"><a href="#例程-3" class="headerlink" title="例程"></a>例程</h5><p>有时候goroutine阻塞，可以使用select实现阻塞超时机制</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> msg := &lt;-ch:</span><br><span class="line">			fmt.Println(msg)</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">3</span>):  <span class="comment">// 阻塞超时机制</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;已超时&quot;</span>)</span><br><span class="line">			done &lt;- <span class="literal">true</span> <span class="comment">// 超时</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	ch &lt;- i <span class="comment">// ch没有close，并且main goroutine并没有终止，导致select中msg一直等，直到超时。</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;-done  <span class="comment">// 阻塞，直到超时</span></span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br></pre></td></tr></table></figure>





<h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(goodsChan <span class="keyword">chan</span>&lt;- <span class="type">int</span>, goodsNum <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; goodsNum; i++ &#123;</span><br><span class="line">		goods := rand.Intn(<span class="number">100</span>)</span><br><span class="line">		goodsChan &lt;- goods</span><br><span class="line">		fmt.Println(<span class="string">&quot;生产产品：&quot;</span>, goods)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deliver</span><span class="params">(goodsChan &lt;-<span class="keyword">chan</span> <span class="type">int</span>, shopChan <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		goods := &lt;-goodsChan</span><br><span class="line">		fmt.Println(<span class="string">&quot;运输产品：&quot;</span>, goods)</span><br><span class="line">		shopChan &lt;- goods</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(shopChan &lt;-<span class="keyword">chan</span> <span class="type">int</span>, exitChan <span class="keyword">chan</span>&lt;- <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		goods := &lt;-shopChan</span><br><span class="line">		fmt.Println(<span class="string">&quot;消费次数序号：&quot;</span>, i, <span class="string">&quot; 商品：&quot;</span>, goods)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	exitChan &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">生产者：每一秒产生一个商品</span></span><br><span class="line"><span class="comment">运输者：一有商品就运输到商店</span></span><br><span class="line"><span class="comment">消费者：每两秒消费一个商品，消费十次后，程序结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	goodsChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">	shopChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">	exitChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">	<span class="comment">// 如果goodsNum&lt;10，那么消费者在消费9次后，会进入死锁</span></span><br><span class="line">	<span class="comment">// 如果goodsNum&gt;10，那么消费者消费完后，商店还会有剩余商品</span></span><br><span class="line">	goodsNum := <span class="number">10</span></span><br><span class="line">	<span class="keyword">go</span> producer(goodsChan, goodsNum)</span><br><span class="line">	<span class="keyword">go</span> deliver(goodsChan, shopChan)</span><br><span class="line">	<span class="keyword">go</span> consumer(shopChan, exitChan)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-exitChan:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>例如，秒杀商品30分钟后，要判断是否付款。即周期性进行任务判断。</p>
<p>使用time包获取一个定时器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">fmt.Println(time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br><span class="line">timer := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> now := &lt;-timer.C:</span><br><span class="line">	fmt.Println(now.Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">now := &lt;-time.After(time.Second * <span class="number">2</span>)  <span class="comment">// 底层使用time.NewTime实现</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br></pre></td></tr></table></figure>



<h3 id="使用time-Ticker"><a href="#使用time-Ticker" class="headerlink" title="使用time.Ticker"></a>使用time.Ticker</h3><p>如果只在主协程调用，而不是go func()内部调用ticker.Stop()，会使得t :&#x3D; &lt;-ticker.C阻塞，进而主协程阻塞，导致死锁；而go出来的子协程就算阻塞，也能被主线程终止，不会死锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">circleTaskWithTicker</span><span class="params">()</span></span> &#123;</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	ticker := time.NewTicker(time.Second)</span><br><span class="line">	exitChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="comment">// 新协程在任务执行两次后停止定时器，并通过exitChan告知主协程</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			t := &lt;-ticker.C</span><br><span class="line">			fmt.Println(t)</span><br><span class="line">			count++</span><br><span class="line">			<span class="keyword">if</span> count &gt; <span class="number">2</span> &#123;</span><br><span class="line">				ticker.Stop()</span><br><span class="line">				exitChan &lt;- <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-exitChan:</span><br><span class="line">		fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用time-Timer"><a href="#使用time-Timer" class="headerlink" title="使用time.Timer"></a>使用time.Timer</h3><p>timer只会往管道输入一次时间，要实现类似ticker的效果的话，需要不断地reset。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">circleTaskWithTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	timer := time.NewTimer(time.Second)</span><br><span class="line">	exitChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			t := &lt;-timer.C</span><br><span class="line">			timer.Reset(time.Second)</span><br><span class="line">			fmt.Println(t)</span><br><span class="line">			count++</span><br><span class="line">			<span class="keyword">if</span> count &gt; <span class="number">2</span> &#123;</span><br><span class="line">				timer.Stop()</span><br><span class="line">				exitChan &lt;- <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-exitChan:</span><br><span class="line">		fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="引入sync包的waitGroup"><a href="#引入sync包的waitGroup" class="headerlink" title="引入sync包的waitGroup"></a>引入sync包的waitGroup</h3><p>免去使用exitChan对主协程的终止，更方便</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20231015112716336.png" alt="image-20231015112716336"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">count := <span class="number">0</span></span><br><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 告知WaitGroup只需要等待一个任务完成</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		t := &lt;-ticker.C</span><br><span class="line">		fmt.Println(t)</span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">if</span> count &gt; <span class="number">2</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="comment">// 时间到，任务完成</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait() <span class="comment">// 等待</span></span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/11/19d9e2ad9d4e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/19d9e2ad9d4e/" class="post-title-link" itemprop="url">ch6-内置容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-17 00:00:00 / 修改时间：19:48:14" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/Go%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Go基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第六章-Go语言内置容器"><a href="#第六章-Go语言内置容器" class="headerlink" title="第六章 Go语言内置容器"></a>第六章 Go语言内置容器</h1><p>数组array、切片slice、映射map</p>
<p>引用类型是一种特殊类型，它们包括切片（slice）、映射（map）和通道（channel）等。与基本类型（如整数、浮点数和布尔值）不同，引用类型具有更灵活的内存分配和操作方式</p>
<h2 id="6-1-数组"><a href="#6-1-数组" class="headerlink" title="6.1 数组"></a>6.1 数组</h2><p><strong>数组大小固定，不能通过数组本身增加删除元素</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组声明</span></span><br><span class="line"><span class="keyword">var</span> array1 [<span class="number">3</span>]<span class="type">int</span> </span><br><span class="line"><span class="comment">// 初始化数组</span></span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment">// 指定大小</span></span><br><span class="line"><span class="keyword">var</span> array2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment">// 编译器根据初始化元素个数指定大小</span></span><br></pre></td></tr></table></figure>


<h2 id="6-1-切片slice"><a href="#6-1-切片slice" class="headerlink" title="6.1 切片slice"></a>6.1 切片slice</h2><ul>
<li><strong>切片并不存储任何元素，是对现有数组的引用</strong></li>
<li>切片结构：地址、长度、容量。<ul>
<li>长度指当前切片所含有的元素个数，</li>
<li>容量指切片所能容纳的元素个数，</li>
<li>如果是在数组&#x2F;切片截取生成的切片，新切片地址是在数组&#x2F;切片<strong>截取位置的地址</strong>。</li>
</ul>
</li>
</ul>
<h3 id="6-2-1-切片生成方式"><a href="#6-2-1-切片生成方式" class="headerlink" title="6.2.1 切片生成方式"></a>6.2.1 切片生成方式</h3><ul>
<li><p>从数组&#x2F;切片上截取生成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 = 数组或切片[<span class="number">1</span>:<span class="number">4</span>]  <span class="comment">// 切片元素来自数组或切片的第1~3个元素。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>直接生成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 = []<span class="keyword">type</span> &#123;item1,itme2,itme3&#125; <span class="comment">// 注意，[]内放数字或`...`时为数组，什么都不放是切片。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>make生成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="type">int</span> <span class="built_in">len</span>, <span class="type">int</span> <span class="built_in">cap</span>)  <span class="comment">// 指定切片类型，长度和容量，默认初始化。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> fruit = [<span class="number">4</span>]<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;pineapple&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 切片生成方式1：从数组上生成</span></span><br><span class="line">fSlice1 := fruit[<span class="number">1</span>:]</span><br><span class="line"><span class="comment">// 切片生成方式2：从切片上生成</span></span><br><span class="line">fSlice2 := fSlice1[:<span class="number">2</span>]</span><br><span class="line"><span class="comment">// 切片生成方式3：直接生成</span></span><br><span class="line">fSlice3 := []<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;pineapple&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 切片生成方式4：make生成</span></span><br><span class="line">slice4 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;fruit:&quot;</span>, fruit)  <span class="comment">// fruit: [apple banana orange pineapple]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice1:&quot;</span>, fSlice1) <span class="comment">//  [banana orange pineapple]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice2:&quot;</span>, fSlice2) <span class="comment">//  [banana orange]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice3:&quot;</span>, fSlice3) <span class="comment">// [apple banana orange pineapple]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;slice3:&quot;</span>, slice4) <span class="comment">// [0 0 0]</span></span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Printf(<span class="string">&quot;fruit type: %T \n&quot;</span>, fruit) <span class="comment">// fruit type: [4]string</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;fSlice1 type: %T \n&quot;</span>, fSlice1) <span class="comment">// fSlice1 type: []string</span></span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Println(<span class="string">&quot;fruit addr:&quot;</span>, &amp;fruit[<span class="number">0</span>]) <span class="comment">// 0xc000024080</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice1 addr:&quot;</span>, &amp;fSlice1[<span class="number">0</span>]) <span class="comment">// 0xc000024090</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice2 addr:&quot;</span>, &amp;fSlice2[<span class="number">0</span>]) <span class="comment">// 0xc000024090</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice3 addr:&quot;</span>, &amp;fSlice3[<span class="number">0</span>]) <span class="comment">// 0xc0000240c0</span></span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Println(<span class="string">&quot;fruit len:&quot;</span>, <span class="built_in">len</span>(fruit), <span class="string">&quot;;capacity:&quot;</span>, <span class="built_in">cap</span>(fruit)) <span class="comment">// fruit len: 4 ;capacity: 4</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice1 len:&quot;</span>, <span class="built_in">len</span>(fSlice1), <span class="string">&quot;;capacity:&quot;</span>, <span class="built_in">cap</span>(fSlice1)) <span class="comment">// fSlice1 len: 3 ;capacity: 3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice2 len:&quot;</span>, <span class="built_in">len</span>(fSlice2), <span class="string">&quot;;capacity:&quot;</span>, <span class="built_in">cap</span>(fSlice2)) <span class="comment">// fSlice2 len: 2 ;capacity: 3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice3 len:&quot;</span>, <span class="built_in">len</span>(fSlice3), <span class="string">&quot;;capacity:&quot;</span>, <span class="built_in">cap</span>(fSlice3)) <span class="comment">// fSlice3 len: 4 ;capacity: 4</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-4-切片添加元素"><a href="#6-2-4-切片添加元素" class="headerlink" title="6.2.4 切片添加元素"></a>6.2.4 切片添加元素</h3><ul>
<li><p>添加方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice1 = <span class="built_in">append</span>(slice1, <span class="number">1</span>)</span><br><span class="line">slice1 = <span class="built_in">append</span>(slice1, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 2个元素</span></span><br><span class="line">slice1 = <span class="built_in">append</span>(slice1, slice2...) <span class="comment">// 另一个slice时要加...，不能是数组。</span></span><br></pre></td></tr></table></figure></li>
<li><p>当添加元素的时候，如果当前len&#x3D;&#x3D;cap，即长度将超过容量，切片会按2倍扩容。<strong>多次扩容会造成性能损耗</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list4Append := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    list4Append = <span class="built_in">append</span>(list4Append, i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;len:&quot;</span>, <span class="built_in">len</span>(list4Append),<span class="string">&quot;cap:&quot;</span>, <span class="built_in">cap</span>(list4Append))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<blockquote>
<p>len: 2 cap: 2<br>len: 3 cap: 4<br>len: 4 cap: 4<br>len: 5 cap: 8<br>len: 6 cap: 8<br>len: 7 cap: 8<br>len: 8 cap: 8<br>len: 9 cap: 16<br>len: 10 cap: 16<br>len: 11 cap: 16</p>
</blockquote>
</li>
<li><p><strong>如果切片生成自其他切片或数组，由于切片只是引用，对切片的修改可能会影响先前的切片&#x2F;数组。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numList = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="keyword">var</span> numSlice = numList[<span class="number">0</span>:<span class="number">1</span>]  <span class="comment">// [1]</span></span><br><span class="line">numSlice = <span class="built_in">append</span>(numSlice, <span class="number">5</span>)  <span class="comment">// 往切片[1]后插入一个元素5</span></span><br><span class="line">fmt.Println(numList, numSlice) <span class="comment">// [1,5,3,4] [1,5] 原数组发生了变化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numSlice2 = numList[:]</span><br><span class="line">numSlice2 = <span class="built_in">append</span>(numSlice2, <span class="number">6</span>)</span><br><span class="line">fmt.Println(numList, numSlice, numSlice2) <span class="comment">//  [1 5 3 4] [1 5] [1 5 3 4 6]</span></span><br></pre></td></tr></table></figure>
<p>numSlice是numLis的t引用，容量4，长度1。当append时，numSlice后面填充一个元素，实际上是修改了numList对应位置的内容。<br>numSlice2也是numList引用，容量4，长度4。当append时，容量变为8，但由于numList不能再添加元素，所以numList不变，而numList1元素只覆盖了前两个，也没有变化。</p>
</li>
</ul>
<h3 id="6-2-5-切片删除元素"><a href="#6-2-5-切片删除元素" class="headerlink" title="6.2.5 切片删除元素"></a>6.2.5 切片删除元素</h3><p>go并没有提供删除的方法，可以利用append实现删除，将删除点前后的slice连接，代码接6.2.4，<br>值得注意是的，当append后面接的是另一个slice时，参数后要加<code>...</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numSlice2 = <span class="built_in">append</span>(numSlice2[:<span class="number">1</span>], numSlice2[<span class="number">2</span>:]...) <span class="comment">// [1 5 3 4 6]</span></span><br><span class="line">fmt.Println(numSlice2) <span class="comment">//[1,3,4,6]</span></span><br></pre></td></tr></table></figure>

<p>numSlice2的地址应该没变。</p>
<h2 id="6-2-映射map"><a href="#6-2-映射map" class="headerlink" title="6.2 映射map"></a>6.2 映射map</h2><p>map并非协程安全的，同一时刻只能有一个协程对map操作，可用sync包的 对map加锁 或 线程安全map ，但有性能损失。</p>
<h3 id="6-2-1-声明"><a href="#6-2-1-声明" class="headerlink" title="6.2.1 声明"></a>6.2.1 声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map1 := <span class="keyword">map</span>[keyType] valueType</span><br></pre></td></tr></table></figure>
<h3 id="6-2-2-初始化"><a href="#6-2-2-初始化" class="headerlink" title="6.2.2 初始化"></a>6.2.2 初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化方式1</span></span><br><span class="line"><span class="keyword">var</span> map1 = <span class="keyword">map</span>[keyType] valueType &#123;</span><br><span class="line">    key1:value1,</span><br><span class="line">    key2:value2,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化方式2，根据长度执行默认初始化</span></span><br><span class="line"><span class="keyword">var</span> map1 = <span class="built_in">make</span>(<span class="keyword">map</span>[keyType]valueType, mapCapacity)</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化方式2中，make可以指定map容量，map的多次扩充会低效，</li>
<li>cap()并不能获取map的容量，而len()可以获取map当前长度。</li>
</ul>
<h3 id="6-3-3-遍历"><a href="#6-3-3-遍历" class="headerlink" title="6.3.3 遍历"></a>6.3.3 遍历</h3><ul>
<li>单纯地range遍历map，每次遍历的结果可能不同，若想每次遍历出一样的结果，可以先取出所有键，再根据键遍历。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">score[<span class="string">&quot;he&quot;</span>] = <span class="number">20</span></span><br><span class="line">score[<span class="string">&quot;she&quot;</span>] = <span class="number">30</span></span><br><span class="line">score[<span class="string">&quot;they&quot;</span>] = <span class="number">40</span></span><br><span class="line">score[<span class="string">&quot;it&quot;</span>] = <span class="number">50</span></span><br><span class="line">fmt.Println(score)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(score))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> score &#123;  <span class="comment">// 每次结果不同</span></span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-3-4-删除键值对"><a href="#6-3-4-删除键值对" class="headerlink" title="6.3.4 删除键值对"></a>6.3.4 删除键值对</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(map1, key)</span><br></pre></td></tr></table></figure>
<p>Go语言没有为map提供清空所有元素的方法。并且delete内置函数置只用于map元素删除。</p>
<h2 id="range表达式"><a href="#range表达式" class="headerlink" title="range表达式"></a>range表达式</h2><p>用于容器的迭代</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> first, second := range map1 &#123;  </span><br><span class="line">    fmt.<span class="built_in">Println</span>(i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230506195133868.png" alt="image-20230506195133868"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/11/f541b5c0766a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/f541b5c0766a/" class="post-title-link" itemprop="url">ch3~5-基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-17 00:00:00 / 修改时间：19:47:50" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/Go%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Go基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ch3变量"><a href="#ch3变量" class="headerlink" title="ch3变量"></a>ch3变量</h1><p>声明后一定要使用</p>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> &#123;</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b <span class="type">string</span></span><br><span class="line">    c <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Go会对每个变量对应内存初始化，有默认初始化类型。</p>
<ul>
<li>数字默认为0，bool默认false，切片、映射、函数默认为nil，字符串默认空字符串。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="type">int</span> = <span class="number">1</span> <span class="comment">// 标准初始化格式</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span> <span class="comment">// 编译器推导类型格式，会根据等号右边推导变量类型</span></span><br><span class="line">age := <span class="number">30</span> <span class="comment">// 短变量声明并初始化，使用较多，可同时给多个变量赋值</span></span><br><span class="line">age, sex := <span class="number">30</span>, <span class="literal">false</span> <span class="comment">// 但要保证左边至少有一个新变量，即未定义过的变量才能使用</span></span><br></pre></td></tr></table></figure>

<h3 id="变量交换"><a href="#变量交换" class="headerlink" title="变量交换"></a>变量交换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a <span class="comment">// 从左到右依次赋值</span></span><br><span class="line">a, b, c := <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">c, a, b = a, b, c</span><br><span class="line">fmt.Println(a, b, c)</span><br></pre></td></tr></table></figure>

<h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h3><p>和python一样，是我比较喜欢的，经常用在函数返回。匿名变量不占用命名空间，<strong>无分配内存</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, _ := function() <span class="comment">// 第二个返回值被匿名变量接收</span></span><br></pre></td></tr></table></figure>



<h2 id="3-2-数据类型"><a href="#3-2-数据类型" class="headerlink" title="3.2 数据类型"></a>3.2 数据类型</h2><p><code>reflect.TypeOf()</code>输出变量类型的字符串</p>
<h3 id="3-2-1-整型"><a href="#3-2-1-整型" class="headerlink" title="3.2.1 整型"></a>3.2.1 整型</h3><p><code>int8, int16, int32, int64</code></p>
<p><code>uint8, uint16, uint32, uint64</code></p>
<h3 id="3-2-2-浮点"><a href="#3-2-2-浮点" class="headerlink" title="3.2.2 浮点"></a>3.2.2 浮点</h3><p>仅支持两种浮点数：float32和float64。最大范围分别约为3.4e38 和 1.8e308</p>
<h3 id="3-2-4-字符和转义字符"><a href="#3-2-4-字符和转义字符" class="headerlink" title="3.2.4 字符和转义字符"></a>3.2.4 字符和转义字符</h3><ul>
<li>unit8：ASCII格式</li>
<li>rune：UTF格式，本质是int32类型</li>
</ul>
<h3 id="3-2-7-数据类型转换"><a href="#3-2-7-数据类型转换" class="headerlink" title="3.2.7 数据类型转换"></a>3.2.7 数据类型转换</h3><p>通过类型前置加小括号进行类型转换。但要注意转换后值是否会改变。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 <span class="type">int32</span> = <span class="number">1234567891</span> <span class="comment">// 0x499602d3</span></span><br><span class="line">fmt.Println(a1) <span class="comment">// 1234567891 0x499602d3</span></span><br><span class="line">fmt.Println(<span class="type">int16</span>(a1)) <span class="comment">// 723 0x02d3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针本身也是变量，所以也有地址</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> <span class="comment">// 默认nil</span></span><br></pre></td></tr></table></figure>

<h3 id="取地址-与-解引用"><a href="#取地址-与-解引用" class="headerlink" title="取地址 与 解引用"></a>取地址 与 解引用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line">p := &amp;a <span class="comment">//</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// 1</span></span><br><span class="line">*p = <span class="number">2</span> <span class="comment">// 修改值</span></span><br></pre></td></tr></table></figure>



<p>go指针和C语言指针的一些区别：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/127940853">Go语言才是学习指针的安全之地，关于指针的二三事 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h1 id="ch4常量与运算符"><a href="#ch4常量与运算符" class="headerlink" title="ch4常量与运算符"></a>ch4常量与运算符</h1><h2 id="4-1-常量"><a href="#4-1-常量" class="headerlink" title="4.1 常量"></a>4.1 常量</h2><p>常量可以声明后不使用</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a <span class="type">int</span> = <span class="number">1</span> <span class="comment">// </span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span> <span class="comment">// 编译器推断</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    c = <span class="number">3.14</span></span><br><span class="line">    d		<span class="comment">// 3.14，沿用上一行</span></span><br><span class="line">    e = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h3><p>特殊常量<code>itoa</code>，其在const关键词出现时被重置为0，每新增一行常量声明，<code>itoa</code>进行一次计数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    a = itoa 	<span class="comment">// 0</span></span><br><span class="line">    b		    <span class="comment">// 0</span></span><br><span class="line">    c = <span class="string">&quot;hello&quot;</span>	<span class="comment">// &quot;hello&quot;</span></span><br><span class="line">    d  			<span class="comment">// &quot;hello&quot;</span></span><br><span class="line">    e = itoa 	<span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-2-运算符"><a href="#4-2-运算符" class="headerlink" title="4.2 运算符"></a>4.2 运算符</h2><p>比较少用到，但感觉比较重要的</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230506193025531.png" alt="image-20230506193025531"></p>
<h1 id="ch5-流程控制"><a href="#ch5-流程控制" class="headerlink" title="ch5 流程控制"></a>ch5 流程控制</h1><p>for和if和C一样，只是没有括号。但没有while循环，一个无条件的for即可。</p>
<p>break和continue都可以跟标签，指定continue或break哪个循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OuterLoop:</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++ &#123;</span><br><span class="line">        fmt.Println(j)</span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span> OuterLoop <span class="comment">// 或者 break OuterLoop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><code>fallthrough</code>关键字：匹配成功，会强制执行后续的case。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="number">1</span> + <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;2&quot;</span>) <span class="comment">// 打印</span></span><br><span class="line">	<span class="keyword">fallthrough</span> </span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;3&quot;</span>) <span class="comment">// 打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="goto跳转"><a href="#goto跳转" class="headerlink" title="goto跳转"></a>goto跳转</h2><p>不建议使用，会破坏程序可读性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">goto</span> mygotoflag</span><br><span class="line">fmt.Println(<span class="string">&quot;invalid line&quot;</span>)</span><br><span class="line">mygotoflag:</span><br><span class="line">	fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/11/142928f796c8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/142928f796c8/" class="post-title-link" itemprop="url">ch7-函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-17 00:00:00 / 修改时间：19:48:19" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/Go%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Go基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h1><h2 id="7-1-函数声明"><a href="#7-1-函数声明" class="headerlink" title="7.1 函数声明"></a>7.1 函数声明</h2><ul>
<li>当返回值只有一个时，可以同时忽略返回值列表的<strong>括号</strong>和<strong>返回值变量名</strong>，但不能只忽略括号</li>
<li>当有返回值名时，在函数体内不用额外声明<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(parameterList)</span></span> (returnList) &#123;</span><br><span class="line">    <span class="comment">// func body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回列表声明可以省略，只有单个返回时返回列表括号也可以省略，</span></span><br><span class="line"><span class="comment">// 参数列表同类型也可以省略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>, z <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;       </span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回多个值， 回列表的声明可以省略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">specificValue</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>, <span class="type">string</span>) &#123;       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接返回 返回列表的默认值，此时返回列表的声明不能忽略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defaultValue</span><span class="params">()</span></span> (a <span class="type">int</span>, b <span class="type">float64</span>, c <span class="type">string</span>) &#123;      </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-3-函数变量"><a href="#7-3-函数变量" class="headerlink" title="7.3 函数变量"></a>7.3 函数变量</h2><p>Go中，函数也是一种<strong>类型</strong>，可以将其保存在<strong>变量</strong>中。个人感觉就是函数的别名。仅声明时，值为<code>nil</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> funcValue <span class="function"><span class="keyword">func</span><span class="params">(parameterList)</span></span>(returnList)</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">val funcValue = funcName</span><br><span class="line"><span class="comment">// 直接声明+赋值</span></span><br><span class="line">funcValue := funcName</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addAndSub</span><span class="params">(x, y <span class="type">int</span>)</span></span> (sum <span class="type">int</span>, sub <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y, x - y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f1 <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> (sum <span class="type">int</span>, sub <span class="type">int</span>)  <span class="comment">// 方式1</span></span><br><span class="line">    f1 = addAndSub</span><br><span class="line">    <span class="comment">//var f1 = addAndSub // 方式2</span></span><br><span class="line">    <span class="comment">//f1 := addAndSub // 方式3</span></span><br><span class="line">    sum, sub := f1(<span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">    fmt.Println(sum, sub)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-4-可变参数（本质切片）"><a href="#7-4-可变参数（本质切片）" class="headerlink" title="7.4 可变参数（本质切片）"></a>7.4 可变参数（本质切片）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span> <span class="params">(固定参数列表, valueName ...Type)</span></span>(returnList)&#123;</span><br><span class="line">    <span class="comment">// func body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>固定参数列表可无，且可变参数一般在参数列表末尾</li>
<li>valueName …Type其实就是类型为Type的<strong>切片</strong>变量valueName，所以常会对切片遍历获取参数</li>
<li>go内置函数如<code>fmt.Printf()</code>和 <code>fmt.Println()</code>，都有可变参数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endlessAdd</span><span class="params">(list ...<span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
函数里，如果想传可变参数，可以以<code>(valueName...)</code>传递<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endlessAddShell</span><span class="params">(list...<span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123;      </span><br><span class="line">    <span class="keyword">return</span> endlessAdd(list...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可变参数是切片，所以也可以以切片形式传递可变参数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endlessAdd</span><span class="params">(list []<span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123; <span class="comment">// 切片为参数</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endlessAddShell</span><span class="params">(list...<span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123;   <span class="comment">// 可变参数</span></span><br><span class="line">    <span class="keyword">return</span> endlessAdd(list) <span class="comment">// 切片为参数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-5-匿名函数和闭包"><a href="#7-5-匿名函数和闭包" class="headerlink" title="7.5 匿名函数和闭包"></a>7.5 匿名函数和闭包</h2><h3 id="7-5-1-匿名函数"><a href="#7-5-1-匿名函数" class="headerlink" title="7.5.1 匿名函数"></a>7.5.1 匿名函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(parameterList)</span></span>(returnList) &#123;</span><br><span class="line">    <span class="comment">//func body</span></span><br><span class="line">    &#125;(parameter) <span class="comment">// 直接调用时可填，只定义不填</span></span><br></pre></td></tr></table></figure>
<ul>
<li>顾名思义，与普通函数的区别就是没有函数名</li>
<li>如果想在定义时直接调用，此时尾部直接加括号和参数<code>(parameter)</code></li>
<li>匿名函数也可以赋给一个变量，但此时不能被直接调用，<strong>注意赋值和调用有返回值的使用区别</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数赋值给变量</span></span><br><span class="line">	a := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello &quot;</span> + data)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(a) <span class="comment">// 0x87df60 匿名函数变量地址</span></span><br><span class="line"><span class="comment">// 带返回值匿名函数调用</span></span><br><span class="line">	b := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello &quot;</span> + data)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;(<span class="string">&quot;world&quot;</span>) <span class="comment">// 主要区别就是有没有传参</span></span><br><span class="line">    fmt.Println(b)</span><br><span class="line">    <span class="comment">// fmt.Println(a(&quot;world&quot;))</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-5-2-闭包"><a href="#7-5-2-闭包" class="headerlink" title="7.5.2 闭包"></a>7.5.2 闭包</h3><p>函数嵌套函数，内部函数可以引用外部函数的参数和变量。参数和变量不会被回收。</p>
<p>好处：</p>
<ol>
<li>可以让一个变量长期在内存中不被释放</li>
<li>避免全局变量的污染，和全局变量不同，闭包中的变量无法被外部使用</li>
<li>私有成员的存在，无法被外部调用，只能直接内部调用</li>
</ol>
<ul>
<li>闭包就是包含了自由变量的匿名函数，而这自由变量脱离了原有自由变量环境也不会被删除，闭包作用域内仍然可以使用这个变量。（记忆力）</li>
<li>同一个匿名函数的不同引用环境构成不同闭包。</li>
<li>闭包会对作用域内变量的<strong>引用</strong>修改</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数在函数体内引用了外部变量num形成了闭包，闭包每次对num变量的引用修改</span></span><br><span class="line">num := <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num++ <span class="comment">// 修改了num变量</span></span><br><span class="line">    fmt.Println(&amp;num, num)  <span class="comment">// 0xc000016120 2</span></span><br><span class="line">&#125;() <span class="comment">// 加了()，直接调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := <span class="number">5</span> <span class="comment">// 匿名函数的内部变量</span></span><br><span class="line">    fmt.Println(&amp;num, num) <span class="comment">// 0xc000016128 5</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num++ <span class="comment">// 修改了num变量</span></span><br><span class="line">    fmt.Println(&amp;num, num)  <span class="comment">// 0xc000016120 3</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>另一个理解闭包的程序：<br>即便输入的是常数0（好像是叫无类型变量？），一个闭包的两次调用仍是对该变量0的引用修改。两个闭包互不影响。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="comment">// 参数为int，返回一个无参数的返回值为int的函数/闭包函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a1 := addOne(<span class="number">0</span>) <span class="comment">//定义变量创建了闭包实例，此后每次用a1()，都等价于调用addrOne内部的闭包函数，且参数为0，（注意a1无参数，因为addOne返回无参数的闭包函数）</span></span><br><span class="line">    fmt.Println(a1()) <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(a1()) <span class="comment">// 2</span></span><br><span class="line">    a2 := addOne(<span class="number">100</span>) <span class="comment">// 定义变量创建新的闭包实例</span></span><br><span class="line">    fmt.Println(a2())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-6-延迟执行语句"><a href="#7-6-延迟执行语句" class="headerlink" title="7.6 延迟执行语句"></a>7.6 延迟执行语句</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> 任意语句</span><br></pre></td></tr></table></figure>
<ul>
<li>defer语句会在其所属函数即将返回式，按照出现的顺序逆序被执行，通常用于释放资源</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="7-7-函数传递的本质"><a href="#7-7-函数传递的本质" class="headerlink" title="7.7 函数传递的本质"></a>7.7 函数传递的本质</h2><ul>
<li>值传递：传递的是变量的一个副本，改变这个副本不会实际改变原变量（可以通过传递变量的指针，修改原变量）。</li>
<li>引用传递：传递变量的地址，函数操作变量时会找到地址所保存的变量（这是自动的，而不是传递指针本身去操作指针）。</li>
</ul>
<p><strong>Go里面函数传参只有值传递一种方式</strong>。</p>
<p>但会分成两种情况：</p>
<ul>
<li>对于int，stirng，bool这种类型，传递的是变量的副本。原变量不会被改变。</li>
<li>对于指针、切片、map、channel、函数等变量存放的是一个内存地址值，传递的是原变量指针的副本，因此可以通过指针修改原变量。</li>
</ul>
<blockquote>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_71777195/article/details/125502836">切片作为函数参数是传值还是传引用</a></p>
</blockquote>
<p>demo：Go函数传参方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passByValue</span><span class="params">(num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;passByValue()-- num:%d,  &amp;num:%p\n&quot;</span>, num, &amp;num)</span><br><span class="line">	num = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passByPointer</span><span class="params">(nump *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;passByPointer()-- num:%d,  &amp;nump:%p,  &amp;nump:%p\n&quot;</span>, *nump, nump, &amp;nump)</span><br><span class="line">	*nump = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passSlice</span><span class="params">(slice1 []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;passSlice()-- slice1:%p &amp;slice1:%p \n&quot;</span>, slice1, &amp;slice1)</span><br><span class="line">	<span class="comment">//fmt.Println(&quot;passByPointer：&quot;, slice1, &amp;slice1)</span></span><br><span class="line">	slice1[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="number">3</span></span><br><span class="line">	nump := &amp;num</span><br><span class="line">	fmt.Printf(<span class="string">&quot;main()-- num:%d,  &amp;num或nump:%p,  &amp;nump:%p\n&quot;</span>, num, &amp;num, &amp;nump)</span><br><span class="line">	passByValue(num)</span><br><span class="line">	passByPointer(nump)</span><br><span class="line">	<span class="keyword">var</span> slice1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;main()-- slice1:%p &amp;slice1:%p \n&quot;</span>, slice1, &amp;slice1)</span><br><span class="line">	passSlice(slice1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<table>
<thead>
<tr>
<th align="center">main()</th>
<th align="center">num: 3</th>
<th align="center">&amp;num或nump: 0xc00001a0a8</th>
<th align="center">&amp;nump: 0xc00000a028</th>
</tr>
</thead>
<tbody><tr>
<td align="center">passByValue()</td>
<td align="center">num: 3</td>
<td align="center">&amp;num: 0xc00001a0e0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">passByPointer()</td>
<td align="center">*nump: 3</td>
<td align="center">nump: 0xc00001a0a8</td>
<td align="center">&amp;nump: 0xc00000a038</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>main()</th>
<th>slice1: 0xc00000e120</th>
<th>&amp;slice1: 0xc0000080a8</th>
</tr>
</thead>
<tbody><tr>
<td>passSlice()</td>
<td>slice1: 0xc00000e120</td>
<td>&amp;slice1: 0xc0000080a8</td>
</tr>
</tbody></table>
<ul>
<li>num传给<code>func passByValue(num int) </code>:由于是值传递，传递的是副本，所以函数内num的地址是和main中的num地址不同。</li>
<li>nump传给<code>func passByPointer(nump *int) </code>:在函数里，nump的值和main中nump相同，但nump的地址和main中不同，所以传的是num的指针的副本，仍是值传递。</li>
<li>slice1传给<code>passSlice(slice1 []int)</code>，实际上slice1这个变量存的就是切片地址，因此也是传递指针的副本，值传递。</li>
</ul>
<p><strong>修改副本不会影响原值，但如果副本本身存的是地址，可以通过改地址修改值。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/11/7e766d57970e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/7e766d57970e/" class="post-title-link" itemprop="url">ch8-结构体</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-17 00:00:00 / 修改时间：19:48:24" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/Go%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Go基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第九章：结构体"><a href="#第九章：结构体" class="headerlink" title="第九章：结构体"></a>第九章：结构体</h1><p>go中没有类，但提供结构体，结构体和接口实现了面向对象的编程特征。</p>
<p>目前所理解的结构体，就是一种数据类型，因此可以创建多个实例。而匿名结构体是没有类型的，即不会用匿名结构体创建很多实例，只会有一个实例。</p>
<h2 id="9-2-定义结构体"><a href="#9-2-定义结构体" class="headerlink" title="9.2 定义结构体"></a>9.2 定义结构体</h2><p>关键词type自定义类型，而结构体本身是类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体名 <span class="keyword">struct</span>&#123;</span><br><span class="line">    成员变量<span class="number">1</span> 类型<span class="number">1</span></span><br><span class="line">    成员变量<span class="number">2</span>, 成员变量<span class="number">3</span> 类型<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>同一包不能重复结构体名</li>
<li>结构体、方法名、变量名的首字母为大写，表示可以导出，可以在当前包外访问。</li>
</ul>
<h2 id="9-3-实例化-声明结构体"><a href="#9-3-实例化-声明结构体" class="headerlink" title="9.3 实例化&#x2F;声明结构体"></a>9.3 实例化&#x2F;声明结构体</h2><p>实例化后可以通过<code>.</code>进行赋值。</p>
<p>结构体本身是一种数据类型，在实例化后才会真正分配内存，所以实例化会对内部成员执行默认初始化。</p>
<ul>
<li>var关键字实例化，返回结构体<strong>（不是指针类型）</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例名 结构体名</span><br></pre></td></tr></table></figure></li>
<li>new函数实例化，返回结构体的<strong>指针类型</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例名 = <span class="built_in">new</span>(结构体名)</span><br><span class="line">结构体实例名 := <span class="built_in">new</span>(结构体名)</span><br></pre></td></tr></table></figure></li>
<li>取地址实例化，实际上属于初始化，也<strong>返回结构体的指针类型</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构体实例名 := &amp;结构体名&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-3-初始化结构体"><a href="#9-3-初始化结构体" class="headerlink" title="9.3 初始化结构体"></a>9.3 初始化结构体</h2><p>声明同时赋值</p>
<p>两者初始化方式，第一种较为繁琐；第二种需要按照成员变量定义<strong>顺序</strong>初始化，且必须初始化<strong>所有</strong>成员变量。两种方式<strong>不能混用</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结构体实例名 := 结构体名&#123;</span><br><span class="line">    成员变量<span class="number">1</span>: 值<span class="number">1</span>,</span><br><span class="line">    成员变量<span class="number">1</span>: 值<span class="number">2</span>，</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结构体实例名 := 结构体名&#123;</span><br><span class="line">    值<span class="number">1</span>,</span><br><span class="line">    值<span class="number">2</span>，</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="9-5-结构体方法"><a href="#9-5-结构体方法" class="headerlink" title="9.5 结构体方法"></a>9.5 结构体方法</h2><p>注意结构体方法和普通函数的不同：多了<strong>接收者</strong>的概念，个人理解为是调用该方法的主体实例。</p>
<p>定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者名 接收者类型)</span></span> funcName(para)(returnList) &#123;</span><br><span class="line">    <span class="comment">// func body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-5-1-指针类型与值类型接收者（重要）"><a href="#9-5-1-指针类型与值类型接收者（重要）" class="headerlink" title="9.5.1 指针类型与值类型接收者（重要）"></a>9.5.1 指针类型与值类型接收者（重要）</h3><ul>
<li><p>当<strong>接收者</strong>类型为（结构体）指针，使用<strong>指针&#x2F;非指针</strong>类型实例（结构体）调用该函数，可以改变成员变量值。</p>
</li>
<li><p>接收者类型为值，即便使用指针调用函数，也不能改编成员变量的值。</p>
</li>
</ul>
<p><strong>接收者</strong>类型为是在结构体方法定义时，接收者是否为指针；<strong>指针&#x2F;非指针</strong>类型实例是指调用这个方法的结构体是否为指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针类型接收者</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> book <span class="keyword">struct</span> &#123;</span><br><span class="line">	bookId    <span class="type">uint</span></span><br><span class="line">	bookTitle <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者，即使调用者不是指针，也能改变成员</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(book1 *book)</span></span> changeTitle() &#123;</span><br><span class="line">	book1.bookTitle = <span class="string">&quot;golang&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值接收者，无论如何都无法改变book1的成员</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(book1 book)</span></span> changeId() &#123;</span><br><span class="line">	book1.bookId = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> book1 book  <span class="comment">// 返回结构体</span></span><br><span class="line">	book1.changeTitle() <span class="comment">// 由于定义时是指针接收者，可以改变成员</span></span><br><span class="line">	book1.changeId() <span class="comment">// 由于定义时是值接收者，即使是结构体指针调用，也无法改变成员</span></span><br><span class="line">	fmt.Println(book1)</span><br><span class="line"></span><br><span class="line">	book2 := <span class="built_in">new</span>(book)  <span class="comment">// 返回结构体指针</span></span><br><span class="line">	book2.changeTitle() <span class="comment">// 由于定义时是指针接收者，可以改变成员</span></span><br><span class="line">	book2.changeId()    <span class="comment">// 由于定义时是值接收者，即使是结构体指针调用，也无法改变成员</span></span><br><span class="line">	fmt.Println(book2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>{0 golang}<br>&amp;{0 golang}</p>
</blockquote>
<h2 id="9-6-结构体内嵌"><a href="#9-6-结构体内嵌" class="headerlink" title="9.6 结构体内嵌"></a>9.6 结构体内嵌</h2><p>套娃，可以构建一种继承的关系。结构体实例化后，可以访问其内嵌结构体的所有成员变量和方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">	bookId    <span class="type">uint</span></span><br><span class="line">	bookTitle <span class="type">string</span></span><br><span class="line">	price     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">type</span> BookBorrow <span class="keyword">struct</span> &#123;</span><br><span class="line">	Book  <span class="comment">// 内嵌结构体</span></span><br><span class="line">    <span class="comment">// book Book // 注释写法</span></span><br><span class="line">	borrowTime <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化结构体内嵌</span></span><br><span class="line">    bookBorrow1 := &amp;BookBorrow&#123;</span><br><span class="line">		Book: Book&#123;<span class="number">1</span>, <span class="string">&quot;golang&quot;</span>, <span class="number">1</span>&#125;, <span class="comment">// 写法---1</span></span><br><span class="line">        <span class="comment">// book: Book&#123;1, &quot;golang&quot;, 1&#125;, // 写法---2</span></span><br><span class="line">		borrowTime: <span class="string">&quot;today&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按照写法1可以直接修改price，写法1相当于直接将book结构体实例的成员放入BookBorrow，而没有在BookBorrow里给Book结构体实例命名</span></span><br><span class="line">	bookBorrow1.borrowTime = <span class="string">&quot;tomorrow&quot;</span></span><br><span class="line">	bookBorrow1.price = <span class="number">10</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是按写法2，不能忽略book，因为Book结构体实例已经被命名成book</span></span><br><span class="line">    <span class="comment">// bookBorrow1.book.price = 10 // 写法2</span></span><br><span class="line">	<span class="built_in">println</span>(bookBorrow1) <span class="comment">// &amp;&#123;&#123;1 golang 10&#125; tomorrow&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-7-匿名结构体"><a href="#9-7-匿名结构体" class="headerlink" title="9.7 匿名结构体"></a>9.7 匿名结构体</h2><p>匿名结构体无需type关键词，但在定义时要创建对象（而普通结构体可以只定义）。</p>
<p>其实就是没有结构体的<strong>定义</strong>，匿名结构体的定义和变量一样，所以至少会默认初始化创建。</p>
<p>只不过其缺点就是无法复用，再定义一个完全一样的结构体，要重新把结构体的成员重新写一次，所以不推荐在需要多个结构体实例时使用。</p>
<p>匿名结构体有其使用场景：组织全局变量、构建数据模板和解析JSON。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/444072574">一文读懂Go语言匿名结构体使用场景 - 知乎 (zhihu.com)</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">结构体实例 := <span class="keyword">struct</span>&#123;</span><br><span class="line">    成员<span class="number">1</span> 类型<span class="number">1</span></span><br><span class="line">    成员<span class="number">2</span> 类型<span class="number">2</span></span><br><span class="line">&#125; &#123;</span><br><span class="line">    成员<span class="number">1</span>: 值<span class="number">1</span>,</span><br><span class="line">    成员<span class="number">2</span>: 值<span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> 结构体实例 <span class="keyword">struct</span>&#123;</span><br><span class="line">    成员<span class="number">1</span> 类型<span class="number">1</span></span><br><span class="line">    成员<span class="number">2</span> 类型<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再用. 赋值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unanimous_struct = <span class="keyword">struct</span> &#123;</span><br><span class="line">   bookId    <span class="type">uint</span></span><br><span class="line">   bookTitle <span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">   <span class="number">1</span>,</span><br><span class="line">   <span class="string">&quot;unanimous&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(unanimous_struct)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/04/680107d7b04b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/680107d7b04b/" class="post-title-link" itemprop="url">ch1-基于TCP的服务器实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-20 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-20T00:00:00+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-17 20:08:02" itemprop="dateModified" datetime="2023-11-17T20:08:02+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230414100114373.png" alt="image-20230414100114373"></p>
<h1 id="一、创建socket"><a href="#一、创建socket" class="headerlink" title="一、创建socket"></a>一、创建socket</h1><p>作用为确定连接的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数：</p>
<ul>
<li><p>domain：协议族，协议族决定了socket的地址类型,在通信中必须采用相应的地址。</p>
<ul>
<li>PF_INET：ipv4互联网协议族</li>
<li>PF_INET6：ipv6互联网协议族</li>
<li>PF_LOCAL</li>
<li>PF_PACKET</li>
<li>PF_IPX</li>
</ul>
</li>
<li><p>type: 指定socket的数据传输方式（因为domain的协议族也可能有多个传输方式）:</p>
<ul>
<li><p>SOCK_STREAM：基于TCP的流格式套接字，不存在数据边界（<strong>因为该套接字有缓冲</strong>，发送方发多少次，接收方可以只收一次）</p>
<blockquote>
<p>缓冲会不会满？会，如果read的速度比收数据的速度满，缓冲会满，但不会丢失数据，因为如果缓冲满了，套接字会停止传输。</p>
</blockquote>
</li>
<li><p>SOCK_DGRAM：基于UDP的数据报格式套接字，存在数据边界（发送方发多少次，接收方收多少次）</p>
</li>
</ul>
</li>
<li><p>protocol：实际的传输协议，第一个参数决定第三个参数可选范围。</p>
<ul>
<li>常见的协议有IPPROTO_TCP、IPPROTO_UDP、 IPPROTO_SCTP、IPPROTO_TIPC他们分别对应这TCP传输协议,UDP传输协议,STCP传输协议,TIPC传输协议。当protocol为0时，会自动选择type类型对应的默认协议。</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：成功时返回一个唯一整数【文件描述符】，失败时返回-1</p>
</li>
<li><p>注意事项<br>第三个参数大多数时候传0，即保持默认，除非遇到下面的情况：<br><code>同一协议族中存在多个 数据传输方式 相同的协议（即指定了domain和type，仍不能确定某一协议）</code></p>
</li>
<li><p>例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPv4家族中面向连接的套接字， IPPROTO_TCP可省略填0</span></span><br><span class="line"><span class="type">int</span> tcp_socket = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP)</span><br><span class="line"><span class="comment">// IPv4家族中面向消息的套接字，同样可省略</span></span><br><span class="line"><span class="type">int</span> udp_socket = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, IPPROTO_UDP) </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二、-IP地址、端口信息存储"><a href="#二、-IP地址、端口信息存储" class="headerlink" title="二、 IP地址、端口信息存储"></a>二、 IP地址、端口信息存储</h1><p>用于存放要连接的<strong>IP地址</strong>和<strong>端口号</strong>，并指定地址族</p>
<p>此部分需要注意两种结构体<code>sockaddr</code>和<code>sockaddr_in</code>。</p>
<p>直接向<code>sockaddr</code>写入IP和端口信息较为麻烦，而设置<code>sockaddr_in</code>较为方便；但由于后续的传参要用到<code>sockaddr</code>，而两种类型是相似的，直接强制类型转换即可。</p>
<p>另外，<code>sockaddr_in</code>是表示IPv4的结构体，但为什么还要设置地址族<code>sin_family</code>。这是为了和<code>sockaddr</code>保持一致，而sockaddr并非只为IPv4设计。</p>
<h3 id="结构体成员细节"><a href="#结构体成员细节" class="headerlink" title="结构体成员细节"></a>结构体成员细节</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//早期的sockaddr，并非只为IPv4设计</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">sa_family_t</span> sa_family; <span class="comment">/* adress family: AF_XXX */</span> </span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];<span class="comment">/* 14 bytes of protocol */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IPv4的sockaddr</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family;                 <span class="comment">//地址族（Address Family），也就是地址类型</span></span><br><span class="line">    <span class="type">uint16_t</span>        sin_port;                   <span class="comment">//16位的端口号，以网络字节序保存</span></span><br><span class="line">    <span class="keyword">struct</span>            <span class="title class_">in_addr</span>  sin_addr;     <span class="comment">//32位IP地址</span></span><br><span class="line">    <span class="type">char</span>              sin_zero[<span class="number">8</span>];             <span class="comment">//不使用，一般用0填充，目的是与sockaddr结构体保持一致</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中in_addr</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">in_addr_t</span> s_addr; <span class="comment">/*32-bit IPV4 address*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>sin_family：地址族（Address Family）<ul>
<li>AF_INET：ipv4网络协议地址族</li>
<li>AF_INET6：ipv6</li>
<li>AF_LOCAL：</li>
</ul>
</li>
<li>sin_port：以<strong>网络字节序</strong>保存16位端口号</li>
<li>sin_addr：也是一个结构体，但内部只有一个32位的成员s_addr，存放的是IP地址的<strong>网络字节序</strong>。</li>
</ul>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230413123150638.png" alt="image-20230413123150638" style="zoom:50%;" />

<p>向sockaddr_in注入地址时，需要将<strong>ip地址的字符串形式</strong>和<strong>端口号的主机字节序形式</strong>转化为<strong>网络字节序</strong>的形式；而相反地，网络字节序也能转化回字符串形式和主机字节序形式。（字符串形式本质是ASCII码存储的形式，在主机也是以主机字节序存储，也要转化为网络字节序）</p>
<p><strong>值得注意的是，除了向sockaddr_in结构体填充数据外，其他情况无需考虑字节序问题。</strong></p>
<h3 id="sockaddr-in结构体设置例程"><a href="#sockaddr-in结构体设置例程" class="headerlink" title="sockaddr_in结构体设置例程"></a>sockaddr_in结构体设置例程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">serv_addr.sin_family = AF_INET; <span class="comment">//选择协议族为IPV4 </span></span><br><span class="line">serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT); <span class="comment">//绑定我们自定义的端口号，客户端程序和我们服务器程序通讯时，就要往这个端口连接和传送数据 </span></span><br><span class="line">serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"><span class="comment">// 一个服务器可能有多块网卡，每个网卡也可能配置多个IP地址，所以用INADDR_ANY，表示服务器的所有可用IP地址，这样监听到9000端口，无论是哪个IP地址都能收到</span></span><br></pre></td></tr></table></figure>

<h2 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h2><h3 id="1-大小端"><a href="#1-大小端" class="headerlink" title="1 大小端"></a>1 大小端</h3><p>假设主机字节序中，存储是数据是0x12345678</p>
<ul>
<li>大端模式（网络字节序）：高位字节存放在内存的低地址处</li>
</ul>
<table>
<thead>
<tr>
<th>数据</th>
<th>12</th>
<th>34</th>
<th>56</th>
<th>78</th>
</tr>
</thead>
<tbody><tr>
<td>地址</td>
<td>0x00</td>
<td>0x01</td>
<td>0x02</td>
<td>0x03</td>
</tr>
</tbody></table>
<p>大端适合网络传输（流方式或者缓冲区）一次读一个字节，然后解析字节，读下一个字节。</p>
<ul>
<li>小端模式：高位字节存放在内存的高地址处</li>
</ul>
<table>
<thead>
<tr>
<th>数据</th>
<th>78</th>
<th>56</th>
<th>34</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>地址</td>
<td>0x00</td>
<td>0x01</td>
<td>0x02</td>
<td>0x03</td>
</tr>
</tbody></table>
<p>小端适合逻辑电路</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/458844566/answer/2567243550">https://www.zhihu.com/question/458844566/answer/2567243550</a></p>
</blockquote>
<h3 id="端口号的网络字节序转换"><a href="#端口号的网络字节序转换" class="headerlink" title="端口号的网络字节序转换"></a>端口号的网络字节序转换</h3><p>然后介绍4种转化字节的方法。htons中h表示主机host，n表示网络network，s表示short，所以是h、to、n、s、l的排列组合，htons解释为把short型数据从主机字节序列转化为网络字节序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">htons</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">ntohs</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">htonl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">ntohl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>转化实例</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> host_port = <span class="number">0x1234</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> net_port;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> host_port_l = <span class="number">0x12345678</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> net_port_l;</span><br><span class="line">	</span><br><span class="line">	net_port = <span class="built_in">htons</span>(host_port);</span><br><span class="line">	net_port_l = <span class="built_in">htonl</span>(host_port_l);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Host ordered port short: %#x \n&quot;</span>, host_port);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Nerwork ordered port short: %#x \n&quot;</span>, net_port);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Host ordered port long: %#xl \n&quot;</span>, host_port_l);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Nerwork ordered port long: %#xl \n&quot;</span>, net_port_l);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图小端cpu的转化结果，若是在大端CPU上，则不会变化<br><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230413115930385.png" alt="image-20230413115930385"></p>
<h3 id="ip地址的网络字节序转换"><a href="#ip地址的网络字节序转换" class="headerlink" title="ip地址的网络字节序转换"></a>ip地址的网络字节序转换</h3><p>用到的函数分别inet_addr()、inet_aton()、inet_ntoa()、inet_pton()、inet_ntop()，转化的方向如下图。</p>
<p><img src="https://github.com/drinkwateronly/Image-Host/blob/main/iimage/image-20230413115034891.png?raw=true" alt="image-20230413115034891"></p>
<h4 id="2-1-inet-addr"><a href="#2-1-inet-addr" class="headerlink" title="2.1 inet_addr()"></a>2.1 inet_addr()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：是将一个点分十进制ipv4的IP地址转换32位大端网络字节序整数</li>
<li>参数：点分十进制的ip地址字符串ip</li>
<li>返回值：成功时返回32位大端整数，失败返回INADDR_NONE</li>
</ul>
<h4 id="2-2-inet-aton-和inet-ntoa"><a href="#2-2-inet-aton-和inet-ntoa" class="headerlink" title="2.2 inet_aton()和inet_ntoa()"></a>2.2 inet_aton()和inet_ntoa()</h4><p><code>inet_addr()</code>直接返回结果，而<code>inet_aton()</code>将转换结果直接写入传入的参数中，方便向sockaddr_in注入IP地址。<br>记法：ASCII to network &#x2F; network to ASCII</p>
<h5 id="inet-aton"><a href="#inet-aton" class="headerlink" title="inet_aton()"></a>inet_aton()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="keyword">struct</span> in_addr *addr)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：是将一个点分十进制的ipv4的IP地址转换32位大端网络字节序整数，结果直接填入in_addr中，使用频率比<code>inet_addr()</code>多。</li>
<li>参数：</li>
</ul>
<blockquote>
<ol>
<li>string: 点分十进制的ip地址字符串ip</li>
<li>addr: 属于sockaddr_in结构体的结构体in_addr地址</li>
</ol>
</blockquote>
<ul>
<li>返回值：成功时返回1，失败返回0</li>
</ul>
<h5 id="inet-ntoa"><a href="#inet-ntoa" class="headerlink" title="inet_ntoa()"></a>inet_ntoa()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr *addr )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：是将一个32位大端网络字节序整数转换为点分十进制的ipv4的IP地址。</li>
<li>参数：</li>
</ul>
<blockquote>
<ol>
<li>addr: 属于sockaddr_in结构体的结构体in_addr地址</li>
</ol>
</blockquote>
<ul>
<li>返回值：存放转化结果的首地址，char*指针，要提前分配空间。失败时返回-1。</li>
</ul>
<h4 id="2-3-inet-pton-inet-ntop"><a href="#2-3-inet-pton-inet-ntop" class="headerlink" title="2.3 inet_pton()inet_ntop()"></a>2.3 inet_pton()inet_ntop()</h4><p>前面的只适用于ipv4地址，这两个适用于ipv4和ipv6，因此使用时要指定地址族<br>记法：presentation to numeric &#x2F; numeric to presentation</p>
<h5 id="inet-pton"><a href="#inet-pton" class="headerlink" title="inet_pton()"></a>inet_pton()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *ip, <span class="type">void</span> *dst)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：将ipv4或者ipv6的字符串ip地址转换为大端网络字节序整数</li>
<li>参数：</li>
</ul>
<blockquote>
<ol>
<li>af: 地址族，取值为AF_INET和AF_INET6，分别ipv4和ipv6</li>
<li>ip：要转化的ip字符串首地址</li>
<li>dst：接收转化后大端网络字节序整数结果的地址，ipv4可以用sin_addr</li>
</ol>
</blockquote>
<ul>
<li>返回值：如果函数出错将返回一个负值，并将errno设置为EAFNOSUPPORT，如果参数af指定的地址族和ip格式不对，函数将返回0。</li>
</ul>
<h5 id="inet-ntop"><a href="#inet-ntop" class="headerlink" title="inet_ntop()"></a>inet_ntop()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> cnt)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：将为大端网络字节序整数转换为ipv4或者ipv6的字符串ip地址</li>
<li>参数：</li>
</ul>
<blockquote>
<ol>
<li>af: 地址族，取值为AF_INET和AF_INET6，分别ipv4和ipv6</li>
<li>src：大端网络字节序整数首地址地址，ipv4可以用sin_addr</li>
<li>dst：接收转化后的ip地址字符串首地址（缓冲区）</li>
<li>cnt：dst缓冲区大小</li>
</ol>
</blockquote>
<ul>
<li>返回值：<br>如果缓存区太小无法存储地址的值，则返回一个空指针，并将errno置为ENOSPC。若无错误发生，Inet_ntop()函数返回一个指向缓冲区的指针。</li>
</ul>
<h4 id="2-4例程"><a href="#2-4例程" class="headerlink" title="2.4例程"></a>2.4例程</h4><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">char</span> ip1[] = <span class="string">&quot;192.168.0.74&quot;</span>;  </span><br><span class="line">    <span class="type">char</span> fakeip[] = <span class="string">&quot;192.256.0.74&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_inet</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    inet_addr()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip %s converting\n&quot;</span>,ip1);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> net_ordered_addr = inet_addr(ip1);</span><br><span class="line">    <span class="keyword">if</span>(net_ordered_addr == INADDR_NONE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_addr() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_addr() success: network ordered integer addr: %#x \n\n&quot;</span>,</span><br><span class="line">            net_ordered_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fake ip</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake ip %s converting\n&quot;</span>, fakeip);</span><br><span class="line">    net_ordered_addr = inet_addr(fakeip);</span><br><span class="line">    <span class="keyword">if</span>(inet_aton(fakeip,&amp;addr_inet.sin_addr)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_addr() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_addr() success: network ordered integer addr: %#x \n\n&quot;</span>,</span><br><span class="line">            net_ordered_addr);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    inet_aton() and inet_ntoa()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip %s converting\n&quot;</span>,ip1);</span><br><span class="line">    <span class="keyword">if</span>(inet_aton(ip1,&amp;addr_inet.sin_addr)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_aton() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_aton() success: network ordered integer addr: %#x \n\n&quot;</span>,</span><br><span class="line">            addr_inet.sin_addr.s_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;network odered addr %#x converting\n&quot;</span>,addr_inet.sin_addr.s_addr);</span><br><span class="line">    <span class="type">char</span> *ip_new;</span><br><span class="line">    ip_new = inet_ntoa(addr_inet.sin_addr);</span><br><span class="line">    <span class="keyword">if</span>(ip_new[<span class="number">0</span>]== <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_ntoa() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_ntoa() success: ip: %s \n\n&quot;</span>, ip_new);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    inet_pton() and inet_ntop()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">char</span> ip2[] = <span class="string">&quot;255.255.255.255&quot;</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip %s converting\n&quot;</span>, ip2);</span><br><span class="line">    <span class="keyword">if</span>(!inet_pton(AF_INET, ip2, (<span class="type">void</span> *) &amp;addr_inet.sin_addr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton() success: network ordered integer addr: %#x \n\n&quot;</span>,</span><br><span class="line">            addr_inet.sin_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> ip2_new[<span class="number">16</span>];  <span class="comment">//ipv4的字符串长度为16字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;network odered addr %#x converting\n&quot;</span>, addr_inet.sin_addr.s_addr);</span><br><span class="line">    <span class="keyword">if</span>(!inet_ntop(AF_INET, (<span class="type">void</span> *) &amp;addr_inet.sin_addr, ip2_new, <span class="keyword">sizeof</span>(ip2_new)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton() success: ip: %s \n\n&quot;</span>, ip2_new);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><h1 id="三、向套接字分配网络地址"><a href="#三、向套接字分配网络地址" class="headerlink" title="三、向套接字分配网络地址"></a>三、向套接字分配网络地址</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：bind 能够将socket文件描述符、端口号和ip绑定到一起。因为socket只指明了协议。</li>
<li>返回值：成功时返回0，失败返回-1</li>
<li>参数：<ul>
<li>sockfd： 表示socket函数创建的通信文件描述符</li>
<li>addr： struct sockaddr_in或sockaddr的首地址，用于设定要绑定的ip和端口</li>
<li>addrlen： 表示所指定addr结构体的大小</li>
</ul>
</li>
</ul>
<h1 id="四、进入-等待连接请求-状态"><a href="#四、进入-等待连接请求-状态" class="headerlink" title="四、进入 等待连接请求 状态"></a>四、进入 等待连接请求 状态</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：<br>将套接字文件描述符从主动（<strong>主动向对方发送数据</strong>）转为被动文件描述符，然后用于被动监听客户端的连接</li>
<li>参数：<ul>
<li>sockfd：socket文件描述符</li>
<li>backlog：指定队列的容量，一般设置队列的容量为2，3即可。队列的最大容量需要小于30</li>
</ul>
</li>
<li>返回值：成功返回0，失败返回-1， errno被设置</li>
</ul>
<p><code>listen()</code>函数不会阻塞，它仅将该套接字和套接字对应的连接队列长度告诉 Linux 内核后结束。<strong>当客户端connect，内核自动完成TCP三次握手</strong>。然后建立好的连接会自动存储到<code>listen()</code>所创建的队列中。</p>
<p>注意，在<code>listen()</code>调用之前，客户端如果调用<code>connect()</code>会发生错误。</p>
<h2 id="4-1-listen队列剖析"><a href="#4-1-listen队列剖析" class="headerlink" title="4.1 listen队列剖析"></a>4.1 listen队列剖析</h2><h3 id="4-1-1-两个队列"><a href="#4-1-1-两个队列" class="headerlink" title="4.1.1 两个队列"></a>4.1.1 两个队列</h3><p>对于一个调用<code>listen</code>的套接字，OS会为其维护两个队列</p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230421101903025.png" alt="image-20230421101903025" style="zoom:50%;" />

<ul>
<li><p>未完成连接队列：</p>
<p>当客户端发送TCP握手第一次握手（SYN），服务器端会在未完成连接队列创建一个对应项，该项可以看作是一个半连接，状态从<code>LISTEN</code>变成<code>SYN_RCVD</code>，同时服务器向客户端第二次握手（SYN+ACK），等待来自客户端的第三次握手。</p>
</li>
<li><p>已完成连接队列</p>
<p>三次握手完成后，连接变成<code>ESTABLISHED</code>状态，放入已连接队列中</p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230421102441451.png" alt="image-20230421102441451" style="zoom: 67%;" />

<p>有两个RTT，分别针对客户端与服务器而言。三次握手需要大约187ms建立，比较慢。</p>
</li>
</ul>
<h3 id="4-1-2-出现的问题与如何避免"><a href="#4-1-2-出现的问题与如何避免" class="headerlink" title="4.1.2 出现的问题与如何避免"></a>4.1.2 出现的问题与如何避免</h3><p>可以看到客户端的<code>connect</code>是收到第二次握手包就返回了，如果客户端迟迟不发送第三个握手包，该半连接项约75s就会被OS删除。</p>
<p>如果队列已满，客户端发送来SYN请求，服务器不会回应，几次后客户端认为连接失败。</p>
<p>进而产生了一种攻击：SYN攻击，即客户端一直只发送第一个握手包，使得队列超过<code>backlog</code>，使得队列变满，正常用户无法连接。</p>
<ul>
<li>原本<code>listen</code>函数<code>backlog</code>参数的含义是以上两个队列之和</li>
<li>后来改成：<strong>指定套接字（服务器监听套接字）上内核为其排队的最大已完成连接数</strong>，也就是<code>ESTABLISHED</code>队列的长度，忽略了<code>SYN_RCVD</code>队列长度。此时程序员只需要关心尽快用<code>accept</code>（下一节内容）将连接取走腾出位置。但实际上仍有未完成连接队列，只不过OS会对他处理。</li>
</ul>
<h1 id="五、受理客户端请求"><a href="#五、受理客户端请求" class="headerlink" title="五、受理客户端请求"></a>五、受理客户端请求</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>函数功能：<br>从established 状态的连接队列头部取出一个已经完成的连接，<strong>产生用于数据IO的套接字（返回值）</strong>。</p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230414104357561.png" alt="image-20230414104357561" style="zoom: 67%;" />
</li>
<li><p>函数返回值：成功返回<strong>套接字描述符</strong>，失败返回-1</p>
</li>
<li><p>参数</p>
<ul>
<li>sockfd：表示socket创建的监听socket描述符</li>
<li>addr：用于存放发起连接请求的那个客户端的地址结构体sockaddr地址</li>
<li>addrlen：存放第二个参数addr的大小的变量地址</li>
</ul>
</li>
</ul>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul>
<li><p><strong>注意两个套接字，<code>socket()</code>生成的套接字是用于<code>bind</code>绑定和<code>listen</code>监听和<code>accept</code>受理请求，而<code>accept</code>生成的套接字用于和客户端交换数据。</strong></p>
</li>
<li><p>套接字文件描述符默认是阻塞的，即如果没有客户端请求连接的时候，此时accept会<strong>阻塞</strong>，直到有客户端连接；如果不想套接字文件描述符阻塞，则可以创建套接字 socket函数 时指定type为SOCK_NOBLOCK。</p>
</li>
<li><p>如果accept没来得及取走一个连接，由于三次握手已经完成，套接字已经创建，此时客户端发送数据过来，就会发送到套接字的接收缓冲区，缓冲区大小就是最大能接受的数据量。</p>
</li>
</ul>
<h1 id="六、数据传输"><a href="#六、数据传输" class="headerlink" title="六、数据传输"></a>六、数据传输</h1><p>此后就可以通过操作<code>accept</code>所返回套接字对客户端进行IO数据传输。可以使用系统I&#x2F;O直接对文件描述符操作，也可以将文件描述符转为FILE指针用C标准库IO操作。</p>
<h1 id="七、关闭连接"><a href="#七、关闭连接" class="headerlink" title="七、关闭连接"></a>七、关闭连接</h1><p>对客户端的服务结束后，调用<code>close</code>关闭套接字，即关闭了连接。流的概念是通过<strong>相互连接的套接字</strong>进入数据交换的状态，下图展示了TCP套接字的流。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415131850510.png" alt="image-20230415131850510"></p>
<p><code>close</code>意味着完全断开两个流，这样的关闭方式不够优雅。可以使用<code>shutdown</code>进行半关闭。这样的话在一端传递完数据半关闭连接后，另一端仍能传递数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> howto)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li>sock：要关闭的socket</li>
<li>howto：如何关闭<ul>
<li>SHUT_RD：断开输入流</li>
<li>SHUT_WR：断开输出流</li>
<li>SHUT_RDWR：同时断开</li>
</ul>
</li>
</ul>
</li>
<li>返回：成功0，失败-1</li>
</ul>
<h1 id="八、服务器代码例程"><a href="#八、服务器代码例程" class="headerlink" title="八、服务器代码例程"></a>八、服务器代码例程</h1><p>来自《C++新经典 Linux C++通信架构实战》</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9000  <span class="comment">//本服务器要监听的端口号，一般1024以下的端口很多都是属于周知端口，所以我们一般采用1024之后的数字做端口号</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">//这些演示代码的写法都是固定套路，一般都这么写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器的socket套接字【文件描述符】</span></span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>                  <span class="comment">//服务器的地址结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));        <span class="comment">//初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置本服务器要监听的地址和端口，这样客户端才能连接到该地址和端口并发送数据</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;                <span class="comment">//选择协议族为IPV4</span></span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);         <span class="comment">//绑定我们自定义的端口号，客户端程序和我们服务器程序通讯时，就要往这个端口连接和传送数据</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">//监听本地所有的IP地址；INADDR_ANY表示的是一个服务器上所有的网卡（服务器可能不止一个网卡）多个本地ip地址都进行绑定端口号，进行侦听。</span></span><br><span class="line"></span><br><span class="line">    bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));<span class="comment">//绑定服务器地址结构体</span></span><br><span class="line">    listen(listenfd, <span class="number">32</span>);     <span class="comment">//参数2表示服务器可以积压的未处理完的连入请求总个数，客户端来一个未连入的请求，请求数+1，连入请求完成，c/s之间进入正常通讯后，请求数-1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> connfd;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pcontent = <span class="string">&quot;I sent sth to client!&quot;</span>; <span class="comment">//指向常量字符串区的指针</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//卡在这里，等客户单连接，客户端连入后，该函数走下去【注意这里返回的是一个新的socket——connfd，后续本服务器就用connfd和客户端之间收发数据，而原有的lisenfd依旧用于继续监听其他连接】        </span></span><br><span class="line">        connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据包给客户端</span></span><br><span class="line">        write(connfd,pcontent,<span class="built_in">strlen</span>(pcontent)); <span class="comment">//注意第一个参数是accept返回的connfd套接字</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只给客户端发送一个信息，然后直接关闭套接字连接；</span></span><br><span class="line">        close(connfd); </span><br><span class="line">    &#125; <span class="comment">//end for</span></span><br><span class="line">    close(listenfd);     <span class="comment">//实际本简单范例走不到这里，这句暂时看起来没啥用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Wallnut</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>



    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"drinkwateronly/comments","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
