<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"drinkwateronly.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Wallnut">
<meta property="og:url" content="https://drinkwateronly.github.io/page/2/index.html">
<meta property="og:site_name" content="Wallnut">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wallnut">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://drinkwateronly.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Wallnut</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Wallnut</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wallnut"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Wallnut</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/drinkwateronly" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;drinkwateronly" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/11/17/Golang/Tutorial/ch3~5%20%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/17/Golang/Tutorial/ch3~5%20%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">ch3~5-基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-17 00:00:00 / 修改时间：19:47:50" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/Go%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Go基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ch3变量"><a href="#ch3变量" class="headerlink" title="ch3变量"></a>ch3变量</h1><p>声明后一定要使用</p>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> &#123;</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b <span class="type">string</span></span><br><span class="line">    c <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Go会对每个变量对应内存初始化，有默认初始化类型。</p>
<ul>
<li>数字默认为0，bool默认false，切片、映射、函数默认为nil，字符串默认空字符串。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="type">int</span> = <span class="number">1</span> <span class="comment">// 标准初始化格式</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span> <span class="comment">// 编译器推导类型格式，会根据等号右边推导变量类型</span></span><br><span class="line">age := <span class="number">30</span> <span class="comment">// 短变量声明并初始化，使用较多，可同时给多个变量赋值</span></span><br><span class="line">age, sex := <span class="number">30</span>, <span class="literal">false</span> <span class="comment">// 但要保证左边至少有一个新变量，即未定义过的变量才能使用</span></span><br></pre></td></tr></table></figure>

<h3 id="变量交换"><a href="#变量交换" class="headerlink" title="变量交换"></a>变量交换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a <span class="comment">// 从左到右依次赋值</span></span><br><span class="line">a, b, c := <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">c, a, b = a, b, c</span><br><span class="line">fmt.Println(a, b, c)</span><br></pre></td></tr></table></figure>

<h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h3><p>和python一样，是我比较喜欢的，经常用在函数返回。匿名变量不占用命名空间，<strong>无分配内存</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, _ := function() <span class="comment">// 第二个返回值被匿名变量接收</span></span><br></pre></td></tr></table></figure>



<h2 id="3-2-数据类型"><a href="#3-2-数据类型" class="headerlink" title="3.2 数据类型"></a>3.2 数据类型</h2><p><code>reflect.TypeOf()</code>输出变量类型的字符串</p>
<h3 id="3-2-1-整型"><a href="#3-2-1-整型" class="headerlink" title="3.2.1 整型"></a>3.2.1 整型</h3><p><code>int8, int16, int32, int64</code></p>
<p><code>uint8, uint16, uint32, uint64</code></p>
<h3 id="3-2-2-浮点"><a href="#3-2-2-浮点" class="headerlink" title="3.2.2 浮点"></a>3.2.2 浮点</h3><p>仅支持两种浮点数：float32和float64。最大范围分别约为3.4e38 和 1.8e308</p>
<h3 id="3-2-4-字符和转义字符"><a href="#3-2-4-字符和转义字符" class="headerlink" title="3.2.4 字符和转义字符"></a>3.2.4 字符和转义字符</h3><ul>
<li>unit8：ASCII格式</li>
<li>rune：UTF格式，本质是int32类型</li>
</ul>
<h3 id="3-2-7-数据类型转换"><a href="#3-2-7-数据类型转换" class="headerlink" title="3.2.7 数据类型转换"></a>3.2.7 数据类型转换</h3><p>通过类型前置加小括号进行类型转换。但要注意转换后值是否会改变。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 <span class="type">int32</span> = <span class="number">1234567891</span> <span class="comment">// 0x499602d3</span></span><br><span class="line">fmt.Println(a1) <span class="comment">// 1234567891 0x499602d3</span></span><br><span class="line">fmt.Println(<span class="type">int16</span>(a1)) <span class="comment">// 723 0x02d3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针本身也是变量，所以也有地址</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> <span class="comment">// 默认nil</span></span><br></pre></td></tr></table></figure>

<h3 id="取地址-与-解引用"><a href="#取地址-与-解引用" class="headerlink" title="取地址 与 解引用"></a>取地址 与 解引用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line">p := &amp;a <span class="comment">//</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// 1</span></span><br><span class="line">*p = <span class="number">2</span> <span class="comment">// 修改值</span></span><br></pre></td></tr></table></figure>



<p>go指针和C语言指针的一些区别：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/127940853">Go语言才是学习指针的安全之地，关于指针的二三事 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h1 id="ch4常量与运算符"><a href="#ch4常量与运算符" class="headerlink" title="ch4常量与运算符"></a>ch4常量与运算符</h1><h2 id="4-1-常量"><a href="#4-1-常量" class="headerlink" title="4.1 常量"></a>4.1 常量</h2><p>常量可以声明后不使用</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a <span class="type">int</span> = <span class="number">1</span> <span class="comment">// </span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span> <span class="comment">// 编译器推断</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    c = <span class="number">3.14</span></span><br><span class="line">    d		<span class="comment">// 3.14，沿用上一行</span></span><br><span class="line">    e = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h3><p>特殊常量<code>itoa</code>，其在const关键词出现时被重置为0，每新增一行常量声明，<code>itoa</code>进行一次计数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    a = itoa 	<span class="comment">// 0</span></span><br><span class="line">    b		    <span class="comment">// 0</span></span><br><span class="line">    c = <span class="string">&quot;hello&quot;</span>	<span class="comment">// &quot;hello&quot;</span></span><br><span class="line">    d  			<span class="comment">// &quot;hello&quot;</span></span><br><span class="line">    e = itoa 	<span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-2-运算符"><a href="#4-2-运算符" class="headerlink" title="4.2 运算符"></a>4.2 运算符</h2><p>比较少用到，但感觉比较重要的</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230506193025531.png" alt="image-20230506193025531"></p>
<h1 id="ch5-流程控制"><a href="#ch5-流程控制" class="headerlink" title="ch5 流程控制"></a>ch5 流程控制</h1><p>for和if和C一样，只是没有括号。但没有while循环，一个无条件的for即可。</p>
<p>break和continue都可以跟标签，指定continue或break哪个循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OuterLoop:</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++ &#123;</span><br><span class="line">        fmt.Println(j)</span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span> OuterLoop <span class="comment">// 或者 break OuterLoop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><code>fallthrough</code>关键字：匹配成功，会强制执行后续的case。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="number">1</span> + <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;2&quot;</span>) <span class="comment">// 打印</span></span><br><span class="line">	<span class="keyword">fallthrough</span> </span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;3&quot;</span>) <span class="comment">// 打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="goto跳转"><a href="#goto跳转" class="headerlink" title="goto跳转"></a>goto跳转</h2><p>不建议使用，会破坏程序可读性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">goto</span> mygotoflag</span><br><span class="line">fmt.Println(<span class="string">&quot;invalid line&quot;</span>)</span><br><span class="line">mygotoflag:</span><br><span class="line">	fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/11/17/Golang/Tutorial/ch7%20%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/17/Golang/Tutorial/ch7%20%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">ch7-函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-17 00:00:00 / 修改时间：19:48:19" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/Go%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Go基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h1><h2 id="7-1-函数声明"><a href="#7-1-函数声明" class="headerlink" title="7.1 函数声明"></a>7.1 函数声明</h2><ul>
<li>当返回值只有一个时，可以同时忽略返回值列表的<strong>括号</strong>和<strong>返回值变量名</strong>，但不能只忽略括号</li>
<li>当有返回值名时，在函数体内不用额外声明<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(parameterList)</span></span> (returnList) &#123;</span><br><span class="line">    <span class="comment">// func body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回列表声明可以省略，只有单个返回时返回列表括号也可以省略，</span></span><br><span class="line"><span class="comment">// 参数列表同类型也可以省略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>, z <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;       </span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回多个值， 回列表的声明可以省略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">specificValue</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>, <span class="type">string</span>) &#123;       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接返回 返回列表的默认值，此时返回列表的声明不能忽略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defaultValue</span><span class="params">()</span></span> (a <span class="type">int</span>, b <span class="type">float64</span>, c <span class="type">string</span>) &#123;      </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-3-函数变量"><a href="#7-3-函数变量" class="headerlink" title="7.3 函数变量"></a>7.3 函数变量</h2><p>Go中，函数也是一种<strong>类型</strong>，可以将其保存在<strong>变量</strong>中。个人感觉就是函数的别名。仅声明时，值为<code>nil</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> funcValue <span class="function"><span class="keyword">func</span><span class="params">(parameterList)</span></span>(returnList)</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">val funcValue = funcName</span><br><span class="line"><span class="comment">// 直接声明+赋值</span></span><br><span class="line">funcValue := funcName</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addAndSub</span><span class="params">(x, y <span class="type">int</span>)</span></span> (sum <span class="type">int</span>, sub <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y, x - y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f1 <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> (sum <span class="type">int</span>, sub <span class="type">int</span>)  <span class="comment">// 方式1</span></span><br><span class="line">    f1 = addAndSub</span><br><span class="line">    <span class="comment">//var f1 = addAndSub // 方式2</span></span><br><span class="line">    <span class="comment">//f1 := addAndSub // 方式3</span></span><br><span class="line">    sum, sub := f1(<span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">    fmt.Println(sum, sub)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-4-可变参数（本质切片）"><a href="#7-4-可变参数（本质切片）" class="headerlink" title="7.4 可变参数（本质切片）"></a>7.4 可变参数（本质切片）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span> <span class="params">(固定参数列表, valueName ...Type)</span></span>(returnList)&#123;</span><br><span class="line">    <span class="comment">// func body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>固定参数列表可无，且可变参数一般在参数列表末尾</li>
<li>valueName …Type其实就是类型为Type的<strong>切片</strong>变量valueName，所以常会对切片遍历获取参数</li>
<li>go内置函数如<code>fmt.Printf()</code>和 <code>fmt.Println()</code>，都有可变参数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endlessAdd</span><span class="params">(list ...<span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
函数里，如果想传可变参数，可以以<code>(valueName...)</code>传递<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endlessAddShell</span><span class="params">(list...<span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123;      </span><br><span class="line">    <span class="keyword">return</span> endlessAdd(list...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可变参数是切片，所以也可以以切片形式传递可变参数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endlessAdd</span><span class="params">(list []<span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123; <span class="comment">// 切片为参数</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endlessAddShell</span><span class="params">(list...<span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123;   <span class="comment">// 可变参数</span></span><br><span class="line">    <span class="keyword">return</span> endlessAdd(list) <span class="comment">// 切片为参数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-5-匿名函数和闭包"><a href="#7-5-匿名函数和闭包" class="headerlink" title="7.5 匿名函数和闭包"></a>7.5 匿名函数和闭包</h2><h3 id="7-5-1-匿名函数"><a href="#7-5-1-匿名函数" class="headerlink" title="7.5.1 匿名函数"></a>7.5.1 匿名函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(parameterList)</span></span>(returnList) &#123;</span><br><span class="line">    <span class="comment">//func body</span></span><br><span class="line">    &#125;(parameter) <span class="comment">// 直接调用时可填，只定义不填</span></span><br></pre></td></tr></table></figure>
<ul>
<li>顾名思义，与普通函数的区别就是没有函数名</li>
<li>如果想在定义时直接调用，此时尾部直接加括号和参数<code>(parameter)</code></li>
<li>匿名函数也可以赋给一个变量，但此时不能被直接调用，<strong>注意赋值和调用有返回值的使用区别</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数赋值给变量</span></span><br><span class="line">	a := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello &quot;</span> + data)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(a) <span class="comment">// 0x87df60 匿名函数变量地址</span></span><br><span class="line"><span class="comment">// 带返回值匿名函数调用</span></span><br><span class="line">	b := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello &quot;</span> + data)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;(<span class="string">&quot;world&quot;</span>) <span class="comment">// 主要区别就是有没有传参</span></span><br><span class="line">    fmt.Println(b)</span><br><span class="line">    <span class="comment">// fmt.Println(a(&quot;world&quot;))</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-5-2-闭包"><a href="#7-5-2-闭包" class="headerlink" title="7.5.2 闭包"></a>7.5.2 闭包</h3><p>函数嵌套函数，内部函数可以引用外部函数的参数和变量。参数和变量不会被回收。</p>
<p>好处：</p>
<ol>
<li>可以让一个变量长期在内存中不被释放</li>
<li>避免全局变量的污染，和全局变量不同，闭包中的变量无法被外部使用</li>
<li>私有成员的存在，无法被外部调用，只能直接内部调用</li>
</ol>
<ul>
<li>闭包就是包含了自由变量的匿名函数，而这自由变量脱离了原有自由变量环境也不会被删除，闭包作用域内仍然可以使用这个变量。（记忆力）</li>
<li>同一个匿名函数的不同引用环境构成不同闭包。</li>
<li>闭包会对作用域内变量的<strong>引用</strong>修改</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数在函数体内引用了外部变量num形成了闭包，闭包每次对num变量的引用修改</span></span><br><span class="line">num := <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num++ <span class="comment">// 修改了num变量</span></span><br><span class="line">    fmt.Println(&amp;num, num)  <span class="comment">// 0xc000016120 2</span></span><br><span class="line">&#125;() <span class="comment">// 加了()，直接调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := <span class="number">5</span> <span class="comment">// 匿名函数的内部变量</span></span><br><span class="line">    fmt.Println(&amp;num, num) <span class="comment">// 0xc000016128 5</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num++ <span class="comment">// 修改了num变量</span></span><br><span class="line">    fmt.Println(&amp;num, num)  <span class="comment">// 0xc000016120 3</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>另一个理解闭包的程序：<br>即便输入的是常数0（好像是叫无类型变量？），一个闭包的两次调用仍是对该变量0的引用修改。两个闭包互不影响。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="comment">// 参数为int，返回一个无参数的返回值为int的函数/闭包函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a1 := addOne(<span class="number">0</span>) <span class="comment">//定义变量创建了闭包实例，此后每次用a1()，都等价于调用addrOne内部的闭包函数，且参数为0，（注意a1无参数，因为addOne返回无参数的闭包函数）</span></span><br><span class="line">    fmt.Println(a1()) <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(a1()) <span class="comment">// 2</span></span><br><span class="line">    a2 := addOne(<span class="number">100</span>) <span class="comment">// 定义变量创建新的闭包实例</span></span><br><span class="line">    fmt.Println(a2())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-6-延迟执行语句"><a href="#7-6-延迟执行语句" class="headerlink" title="7.6 延迟执行语句"></a>7.6 延迟执行语句</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> 任意语句</span><br></pre></td></tr></table></figure>
<ul>
<li>defer语句会在其所属函数即将返回式，按照出现的顺序逆序被执行，通常用于释放资源</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="7-7-函数传递的本质"><a href="#7-7-函数传递的本质" class="headerlink" title="7.7 函数传递的本质"></a>7.7 函数传递的本质</h2><ul>
<li>值传递：传递的是变量的一个副本，改变这个副本不会实际改变原变量（可以通过传递变量的指针，修改原变量）。</li>
<li>引用传递：传递变量的地址，函数操作变量时会找到地址所保存的变量（这是自动的，而不是传递指针本身去操作指针）。</li>
</ul>
<p><strong>Go里面函数传参只有值传递一种方式</strong>。</p>
<p>但会分成两种情况：</p>
<ul>
<li>对于int，stirng，bool这种类型，传递的是变量的副本。原变量不会被改变。</li>
<li>对于指针、切片、map、channel、函数等变量存放的是一个内存地址值，传递的是原变量指针的副本，因此可以通过指针修改原变量。</li>
</ul>
<blockquote>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_71777195/article/details/125502836">切片作为函数参数是传值还是传引用</a></p>
</blockquote>
<p>demo：Go函数传参方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passByValue</span><span class="params">(num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;passByValue()-- num:%d,  &amp;num:%p\n&quot;</span>, num, &amp;num)</span><br><span class="line">	num = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passByPointer</span><span class="params">(nump *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;passByPointer()-- num:%d,  &amp;nump:%p,  &amp;nump:%p\n&quot;</span>, *nump, nump, &amp;nump)</span><br><span class="line">	*nump = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passSlice</span><span class="params">(slice1 []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;passSlice()-- slice1:%p &amp;slice1:%p \n&quot;</span>, slice1, &amp;slice1)</span><br><span class="line">	<span class="comment">//fmt.Println(&quot;passByPointer：&quot;, slice1, &amp;slice1)</span></span><br><span class="line">	slice1[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="number">3</span></span><br><span class="line">	nump := &amp;num</span><br><span class="line">	fmt.Printf(<span class="string">&quot;main()-- num:%d,  &amp;num或nump:%p,  &amp;nump:%p\n&quot;</span>, num, &amp;num, &amp;nump)</span><br><span class="line">	passByValue(num)</span><br><span class="line">	passByPointer(nump)</span><br><span class="line">	<span class="keyword">var</span> slice1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;main()-- slice1:%p &amp;slice1:%p \n&quot;</span>, slice1, &amp;slice1)</span><br><span class="line">	passSlice(slice1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<table>
<thead>
<tr>
<th align="center">main()</th>
<th align="center">num: 3</th>
<th align="center">&amp;num或nump: 0xc00001a0a8</th>
<th align="center">&amp;nump: 0xc00000a028</th>
</tr>
</thead>
<tbody><tr>
<td align="center">passByValue()</td>
<td align="center">num: 3</td>
<td align="center">&amp;num: 0xc00001a0e0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">passByPointer()</td>
<td align="center">*nump: 3</td>
<td align="center">nump: 0xc00001a0a8</td>
<td align="center">&amp;nump: 0xc00000a038</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>main()</th>
<th>slice1: 0xc00000e120</th>
<th>&amp;slice1: 0xc0000080a8</th>
</tr>
</thead>
<tbody><tr>
<td>passSlice()</td>
<td>slice1: 0xc00000e120</td>
<td>&amp;slice1: 0xc0000080a8</td>
</tr>
</tbody></table>
<ul>
<li>num传给<code>func passByValue(num int) </code>:由于是值传递，传递的是副本，所以函数内num的地址是和main中的num地址不同。</li>
<li>nump传给<code>func passByPointer(nump *int) </code>:在函数里，nump的值和main中nump相同，但nump的地址和main中不同，所以传的是num的指针的副本，仍是值传递。</li>
<li>slice1传给<code>passSlice(slice1 []int)</code>，实际上slice1这个变量存的就是切片地址，因此也是传递指针的副本，值传递。</li>
</ul>
<p><strong>修改副本不会影响原值，但如果副本本身存的是地址，可以通过改地址修改值。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/11/17/Golang/Tutorial/ch6%20%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/17/Golang/Tutorial/ch6%20%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">ch6-内置容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-17 00:00:00 / 修改时间：19:48:14" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/Go%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Go基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第六章-Go语言内置容器"><a href="#第六章-Go语言内置容器" class="headerlink" title="第六章 Go语言内置容器"></a>第六章 Go语言内置容器</h1><p>数组array、切片slice、映射map</p>
<p>引用类型是一种特殊类型，它们包括切片（slice）、映射（map）和通道（channel）等。与基本类型（如整数、浮点数和布尔值）不同，引用类型具有更灵活的内存分配和操作方式</p>
<h2 id="6-1-数组"><a href="#6-1-数组" class="headerlink" title="6.1 数组"></a>6.1 数组</h2><p><strong>数组大小固定，不能通过数组本身增加删除元素</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组声明</span></span><br><span class="line"><span class="keyword">var</span> array1 [<span class="number">3</span>]<span class="type">int</span> </span><br><span class="line"><span class="comment">// 初始化数组</span></span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment">// 指定大小</span></span><br><span class="line"><span class="keyword">var</span> array2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment">// 编译器根据初始化元素个数指定大小</span></span><br></pre></td></tr></table></figure>


<h2 id="6-1-切片slice"><a href="#6-1-切片slice" class="headerlink" title="6.1 切片slice"></a>6.1 切片slice</h2><ul>
<li><strong>切片并不存储任何元素，是对现有数组的引用</strong></li>
<li>切片结构：地址、长度、容量。<ul>
<li>长度指当前切片所含有的元素个数，</li>
<li>容量指切片所能容纳的元素个数，</li>
<li>如果是在数组&#x2F;切片截取生成的切片，新切片地址是在数组&#x2F;切片<strong>截取位置的地址</strong>。</li>
</ul>
</li>
</ul>
<h3 id="6-2-1-切片生成方式"><a href="#6-2-1-切片生成方式" class="headerlink" title="6.2.1 切片生成方式"></a>6.2.1 切片生成方式</h3><ul>
<li><p>从数组&#x2F;切片上截取生成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 = 数组或切片[<span class="number">1</span>:<span class="number">4</span>]  <span class="comment">// 切片元素来自数组或切片的第1~3个元素。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>直接生成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 = []<span class="keyword">type</span> &#123;item1,itme2,itme3&#125; <span class="comment">// 注意，[]内放数字或`...`时为数组，什么都不放是切片。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>make生成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="type">int</span> <span class="built_in">len</span>, <span class="type">int</span> <span class="built_in">cap</span>)  <span class="comment">// 指定切片类型，长度和容量，默认初始化。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> fruit = [<span class="number">4</span>]<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;pineapple&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 切片生成方式1：从数组上生成</span></span><br><span class="line">fSlice1 := fruit[<span class="number">1</span>:]</span><br><span class="line"><span class="comment">// 切片生成方式2：从切片上生成</span></span><br><span class="line">fSlice2 := fSlice1[:<span class="number">2</span>]</span><br><span class="line"><span class="comment">// 切片生成方式3：直接生成</span></span><br><span class="line">fSlice3 := []<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;pineapple&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 切片生成方式4：make生成</span></span><br><span class="line">slice4 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;fruit:&quot;</span>, fruit)  <span class="comment">// fruit: [apple banana orange pineapple]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice1:&quot;</span>, fSlice1) <span class="comment">//  [banana orange pineapple]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice2:&quot;</span>, fSlice2) <span class="comment">//  [banana orange]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice3:&quot;</span>, fSlice3) <span class="comment">// [apple banana orange pineapple]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;slice3:&quot;</span>, slice4) <span class="comment">// [0 0 0]</span></span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Printf(<span class="string">&quot;fruit type: %T \n&quot;</span>, fruit) <span class="comment">// fruit type: [4]string</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;fSlice1 type: %T \n&quot;</span>, fSlice1) <span class="comment">// fSlice1 type: []string</span></span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Println(<span class="string">&quot;fruit addr:&quot;</span>, &amp;fruit[<span class="number">0</span>]) <span class="comment">// 0xc000024080</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice1 addr:&quot;</span>, &amp;fSlice1[<span class="number">0</span>]) <span class="comment">// 0xc000024090</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice2 addr:&quot;</span>, &amp;fSlice2[<span class="number">0</span>]) <span class="comment">// 0xc000024090</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice3 addr:&quot;</span>, &amp;fSlice3[<span class="number">0</span>]) <span class="comment">// 0xc0000240c0</span></span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Println(<span class="string">&quot;fruit len:&quot;</span>, <span class="built_in">len</span>(fruit), <span class="string">&quot;;capacity:&quot;</span>, <span class="built_in">cap</span>(fruit)) <span class="comment">// fruit len: 4 ;capacity: 4</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice1 len:&quot;</span>, <span class="built_in">len</span>(fSlice1), <span class="string">&quot;;capacity:&quot;</span>, <span class="built_in">cap</span>(fSlice1)) <span class="comment">// fSlice1 len: 3 ;capacity: 3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice2 len:&quot;</span>, <span class="built_in">len</span>(fSlice2), <span class="string">&quot;;capacity:&quot;</span>, <span class="built_in">cap</span>(fSlice2)) <span class="comment">// fSlice2 len: 2 ;capacity: 3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;fSlice3 len:&quot;</span>, <span class="built_in">len</span>(fSlice3), <span class="string">&quot;;capacity:&quot;</span>, <span class="built_in">cap</span>(fSlice3)) <span class="comment">// fSlice3 len: 4 ;capacity: 4</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-4-切片添加元素"><a href="#6-2-4-切片添加元素" class="headerlink" title="6.2.4 切片添加元素"></a>6.2.4 切片添加元素</h3><ul>
<li><p>添加方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice1 = <span class="built_in">append</span>(slice1, <span class="number">1</span>)</span><br><span class="line">slice1 = <span class="built_in">append</span>(slice1, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 2个元素</span></span><br><span class="line">slice1 = <span class="built_in">append</span>(slice1, slice2...) <span class="comment">// 另一个slice时要加...，不能是数组。</span></span><br></pre></td></tr></table></figure></li>
<li><p>当添加元素的时候，如果当前len&#x3D;&#x3D;cap，即长度将超过容量，切片会按2倍扩容。<strong>多次扩容会造成性能损耗</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list4Append := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    list4Append = <span class="built_in">append</span>(list4Append, i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;len:&quot;</span>, <span class="built_in">len</span>(list4Append),<span class="string">&quot;cap:&quot;</span>, <span class="built_in">cap</span>(list4Append))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<blockquote>
<p>len: 2 cap: 2<br>len: 3 cap: 4<br>len: 4 cap: 4<br>len: 5 cap: 8<br>len: 6 cap: 8<br>len: 7 cap: 8<br>len: 8 cap: 8<br>len: 9 cap: 16<br>len: 10 cap: 16<br>len: 11 cap: 16</p>
</blockquote>
</li>
<li><p><strong>如果切片生成自其他切片或数组，由于切片只是引用，对切片的修改可能会影响先前的切片&#x2F;数组。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numList = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="keyword">var</span> numSlice = numList[<span class="number">0</span>:<span class="number">1</span>]  <span class="comment">// [1]</span></span><br><span class="line">numSlice = <span class="built_in">append</span>(numSlice, <span class="number">5</span>)  <span class="comment">// 往切片[1]后插入一个元素5</span></span><br><span class="line">fmt.Println(numList, numSlice) <span class="comment">// [1,5,3,4] [1,5] 原数组发生了变化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numSlice2 = numList[:]</span><br><span class="line">numSlice2 = <span class="built_in">append</span>(numSlice2, <span class="number">6</span>)</span><br><span class="line">fmt.Println(numList, numSlice, numSlice2) <span class="comment">//  [1 5 3 4] [1 5] [1 5 3 4 6]</span></span><br></pre></td></tr></table></figure>
<p>numSlice是numLis的t引用，容量4，长度1。当append时，numSlice后面填充一个元素，实际上是修改了numList对应位置的内容。<br>numSlice2也是numList引用，容量4，长度4。当append时，容量变为8，但由于numList不能再添加元素，所以numList不变，而numList1元素只覆盖了前两个，也没有变化。</p>
</li>
</ul>
<h3 id="6-2-5-切片删除元素"><a href="#6-2-5-切片删除元素" class="headerlink" title="6.2.5 切片删除元素"></a>6.2.5 切片删除元素</h3><p>go并没有提供删除的方法，可以利用append实现删除，将删除点前后的slice连接，代码接6.2.4，<br>值得注意是的，当append后面接的是另一个slice时，参数后要加<code>...</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numSlice2 = <span class="built_in">append</span>(numSlice2[:<span class="number">1</span>], numSlice2[<span class="number">2</span>:]...) <span class="comment">// [1 5 3 4 6]</span></span><br><span class="line">fmt.Println(numSlice2) <span class="comment">//[1,3,4,6]</span></span><br></pre></td></tr></table></figure>

<p>numSlice2的地址应该没变。</p>
<h2 id="6-2-映射map"><a href="#6-2-映射map" class="headerlink" title="6.2 映射map"></a>6.2 映射map</h2><p>map并非协程安全的，同一时刻只能有一个协程对map操作，可用sync包的 对map加锁 或 线程安全map ，但有性能损失。</p>
<h3 id="6-2-1-声明"><a href="#6-2-1-声明" class="headerlink" title="6.2.1 声明"></a>6.2.1 声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map1 := <span class="keyword">map</span>[keyType] valueType</span><br></pre></td></tr></table></figure>
<h3 id="6-2-2-初始化"><a href="#6-2-2-初始化" class="headerlink" title="6.2.2 初始化"></a>6.2.2 初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化方式1</span></span><br><span class="line"><span class="keyword">var</span> map1 = <span class="keyword">map</span>[keyType] valueType &#123;</span><br><span class="line">    key1:value1,</span><br><span class="line">    key2:value2,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化方式2，根据长度执行默认初始化</span></span><br><span class="line"><span class="keyword">var</span> map1 = <span class="built_in">make</span>(<span class="keyword">map</span>[keyType]valueType, mapCapacity)</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化方式2中，make可以指定map容量，map的多次扩充会低效，</li>
<li>cap()并不能获取map的容量，而len()可以获取map当前长度。</li>
</ul>
<h3 id="6-3-3-遍历"><a href="#6-3-3-遍历" class="headerlink" title="6.3.3 遍历"></a>6.3.3 遍历</h3><ul>
<li>单纯地range遍历map，每次遍历的结果可能不同，若想每次遍历出一样的结果，可以先取出所有键，再根据键遍历。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">score[<span class="string">&quot;he&quot;</span>] = <span class="number">20</span></span><br><span class="line">score[<span class="string">&quot;she&quot;</span>] = <span class="number">30</span></span><br><span class="line">score[<span class="string">&quot;they&quot;</span>] = <span class="number">40</span></span><br><span class="line">score[<span class="string">&quot;it&quot;</span>] = <span class="number">50</span></span><br><span class="line">fmt.Println(score)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(score))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> score &#123;  <span class="comment">// 每次结果不同</span></span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-3-4-删除键值对"><a href="#6-3-4-删除键值对" class="headerlink" title="6.3.4 删除键值对"></a>6.3.4 删除键值对</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(map1, key)</span><br></pre></td></tr></table></figure>
<p>Go语言没有为map提供清空所有元素的方法。并且delete内置函数置只用于map元素删除。</p>
<h2 id="range表达式"><a href="#range表达式" class="headerlink" title="range表达式"></a>range表达式</h2><p>用于容器的迭代</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> first, second := range map1 &#123;  </span><br><span class="line">    fmt.<span class="built_in">Println</span>(i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230506195133868.png" alt="image-20230506195133868"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/11/17/Golang/Tutorial/ch8%20%E7%BB%93%E6%9E%84%E4%BD%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/17/Golang/Tutorial/ch8%20%E7%BB%93%E6%9E%84%E4%BD%93/" class="post-title-link" itemprop="url">ch8-结构体</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-17 00:00:00 / 修改时间：19:48:24" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/Go%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Go基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第九章：结构体"><a href="#第九章：结构体" class="headerlink" title="第九章：结构体"></a>第九章：结构体</h1><p>go中没有类，但提供结构体，结构体和接口实现了面向对象的编程特征。</p>
<p>目前所理解的结构体，就是一种数据类型，因此可以创建多个实例。而匿名结构体是没有类型的，即不会用匿名结构体创建很多实例，只会有一个实例。</p>
<h2 id="9-2-定义结构体"><a href="#9-2-定义结构体" class="headerlink" title="9.2 定义结构体"></a>9.2 定义结构体</h2><p>关键词type自定义类型，而结构体本身是类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体名 <span class="keyword">struct</span>&#123;</span><br><span class="line">    成员变量<span class="number">1</span> 类型<span class="number">1</span></span><br><span class="line">    成员变量<span class="number">2</span>, 成员变量<span class="number">3</span> 类型<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>同一包不能重复结构体名</li>
<li>结构体、方法名、变量名的首字母为大写，表示可以导出，可以在当前包外访问。</li>
</ul>
<h2 id="9-3-实例化-声明结构体"><a href="#9-3-实例化-声明结构体" class="headerlink" title="9.3 实例化&#x2F;声明结构体"></a>9.3 实例化&#x2F;声明结构体</h2><p>实例化后可以通过<code>.</code>进行赋值。</p>
<p>结构体本身是一种数据类型，在实例化后才会真正分配内存，所以实例化会对内部成员执行默认初始化。</p>
<ul>
<li>var关键字实例化，返回结构体<strong>（不是指针类型）</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例名 结构体名</span><br></pre></td></tr></table></figure></li>
<li>new函数实例化，返回结构体的<strong>指针类型</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例名 = <span class="built_in">new</span>(结构体名)</span><br><span class="line">结构体实例名 := <span class="built_in">new</span>(结构体名)</span><br></pre></td></tr></table></figure></li>
<li>取地址实例化，实际上属于初始化，也<strong>返回结构体的指针类型</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构体实例名 := &amp;结构体名&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-3-初始化结构体"><a href="#9-3-初始化结构体" class="headerlink" title="9.3 初始化结构体"></a>9.3 初始化结构体</h2><p>声明同时赋值</p>
<p>两者初始化方式，第一种较为繁琐；第二种需要按照成员变量定义<strong>顺序</strong>初始化，且必须初始化<strong>所有</strong>成员变量。两种方式<strong>不能混用</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结构体实例名 := 结构体名&#123;</span><br><span class="line">    成员变量<span class="number">1</span>: 值<span class="number">1</span>,</span><br><span class="line">    成员变量<span class="number">1</span>: 值<span class="number">2</span>，</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结构体实例名 := 结构体名&#123;</span><br><span class="line">    值<span class="number">1</span>,</span><br><span class="line">    值<span class="number">2</span>，</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="9-5-结构体方法"><a href="#9-5-结构体方法" class="headerlink" title="9.5 结构体方法"></a>9.5 结构体方法</h2><p>注意结构体方法和普通函数的不同：多了<strong>接收者</strong>的概念，个人理解为是调用该方法的主体实例。</p>
<p>定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者名 接收者类型)</span></span> funcName(para)(returnList) &#123;</span><br><span class="line">    <span class="comment">// func body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-5-1-指针类型与值类型接收者（重要）"><a href="#9-5-1-指针类型与值类型接收者（重要）" class="headerlink" title="9.5.1 指针类型与值类型接收者（重要）"></a>9.5.1 指针类型与值类型接收者（重要）</h3><ul>
<li><p>当<strong>接收者</strong>类型为（结构体）指针，使用<strong>指针&#x2F;非指针</strong>类型实例（结构体）调用该函数，可以改变成员变量值。</p>
</li>
<li><p>接收者类型为值，即便使用指针调用函数，也不能改编成员变量的值。</p>
</li>
</ul>
<p><strong>接收者</strong>类型为是在结构体方法定义时，接收者是否为指针；<strong>指针&#x2F;非指针</strong>类型实例是指调用这个方法的结构体是否为指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针类型接收者</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> book <span class="keyword">struct</span> &#123;</span><br><span class="line">	bookId    <span class="type">uint</span></span><br><span class="line">	bookTitle <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者，即使调用者不是指针，也能改变成员</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(book1 *book)</span></span> changeTitle() &#123;</span><br><span class="line">	book1.bookTitle = <span class="string">&quot;golang&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值接收者，无论如何都无法改变book1的成员</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(book1 book)</span></span> changeId() &#123;</span><br><span class="line">	book1.bookId = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> book1 book  <span class="comment">// 返回结构体</span></span><br><span class="line">	book1.changeTitle() <span class="comment">// 由于定义时是指针接收者，可以改变成员</span></span><br><span class="line">	book1.changeId() <span class="comment">// 由于定义时是值接收者，即使是结构体指针调用，也无法改变成员</span></span><br><span class="line">	fmt.Println(book1)</span><br><span class="line"></span><br><span class="line">	book2 := <span class="built_in">new</span>(book)  <span class="comment">// 返回结构体指针</span></span><br><span class="line">	book2.changeTitle() <span class="comment">// 由于定义时是指针接收者，可以改变成员</span></span><br><span class="line">	book2.changeId()    <span class="comment">// 由于定义时是值接收者，即使是结构体指针调用，也无法改变成员</span></span><br><span class="line">	fmt.Println(book2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>{0 golang}<br>&amp;{0 golang}</p>
</blockquote>
<h2 id="9-6-结构体内嵌"><a href="#9-6-结构体内嵌" class="headerlink" title="9.6 结构体内嵌"></a>9.6 结构体内嵌</h2><p>套娃，可以构建一种继承的关系。结构体实例化后，可以访问其内嵌结构体的所有成员变量和方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">	bookId    <span class="type">uint</span></span><br><span class="line">	bookTitle <span class="type">string</span></span><br><span class="line">	price     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">type</span> BookBorrow <span class="keyword">struct</span> &#123;</span><br><span class="line">	Book  <span class="comment">// 内嵌结构体</span></span><br><span class="line">    <span class="comment">// book Book // 注释写法</span></span><br><span class="line">	borrowTime <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化结构体内嵌</span></span><br><span class="line">    bookBorrow1 := &amp;BookBorrow&#123;</span><br><span class="line">		Book: Book&#123;<span class="number">1</span>, <span class="string">&quot;golang&quot;</span>, <span class="number">1</span>&#125;, <span class="comment">// 写法---1</span></span><br><span class="line">        <span class="comment">// book: Book&#123;1, &quot;golang&quot;, 1&#125;, // 写法---2</span></span><br><span class="line">		borrowTime: <span class="string">&quot;today&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按照写法1可以直接修改price，写法1相当于直接将book结构体实例的成员放入BookBorrow，而没有在BookBorrow里给Book结构体实例命名</span></span><br><span class="line">	bookBorrow1.borrowTime = <span class="string">&quot;tomorrow&quot;</span></span><br><span class="line">	bookBorrow1.price = <span class="number">10</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是按写法2，不能忽略book，因为Book结构体实例已经被命名成book</span></span><br><span class="line">    <span class="comment">// bookBorrow1.book.price = 10 // 写法2</span></span><br><span class="line">	<span class="built_in">println</span>(bookBorrow1) <span class="comment">// &amp;&#123;&#123;1 golang 10&#125; tomorrow&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-7-匿名结构体"><a href="#9-7-匿名结构体" class="headerlink" title="9.7 匿名结构体"></a>9.7 匿名结构体</h2><p>匿名结构体无需type关键词，但在定义时要创建对象（而普通结构体可以只定义）。</p>
<p>其实就是没有结构体的<strong>定义</strong>，匿名结构体的定义和变量一样，所以至少会默认初始化创建。</p>
<p>只不过其缺点就是无法复用，再定义一个完全一样的结构体，要重新把结构体的成员重新写一次，所以不推荐在需要多个结构体实例时使用。</p>
<p>匿名结构体有其使用场景：组织全局变量、构建数据模板和解析JSON。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/444072574">一文读懂Go语言匿名结构体使用场景 - 知乎 (zhihu.com)</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">结构体实例 := <span class="keyword">struct</span>&#123;</span><br><span class="line">    成员<span class="number">1</span> 类型<span class="number">1</span></span><br><span class="line">    成员<span class="number">2</span> 类型<span class="number">2</span></span><br><span class="line">&#125; &#123;</span><br><span class="line">    成员<span class="number">1</span>: 值<span class="number">1</span>,</span><br><span class="line">    成员<span class="number">2</span>: 值<span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> 结构体实例 <span class="keyword">struct</span>&#123;</span><br><span class="line">    成员<span class="number">1</span> 类型<span class="number">1</span></span><br><span class="line">    成员<span class="number">2</span> 类型<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再用. 赋值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unanimous_struct = <span class="keyword">struct</span> &#123;</span><br><span class="line">   bookId    <span class="type">uint</span></span><br><span class="line">   bookTitle <span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">   <span class="number">1</span>,</span><br><span class="line">   <span class="string">&quot;unanimous&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(unanimous_struct)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/04/20/network_programming/ch2-%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/20/network_programming/ch2-%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">ch2-基于TCP的客户端实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-20 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-20T00:00:00+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-17 20:08:09" itemprop="dateModified" datetime="2023-11-17T20:08:09+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230414100114373.png" alt="image-20230414100114373"></p>
<h1 id="一、创建socket"><a href="#一、创建socket" class="headerlink" title="一、创建socket"></a>一、创建socket</h1><h1 id="二、-服务器的IP地址、端口信息结构体"><a href="#二、-服务器的IP地址、端口信息结构体" class="headerlink" title="二、 服务器的IP地址、端口信息结构体"></a>二、 服务器的IP地址、端口信息结构体</h1><h1 id="三、请求连接服务器"><a href="#三、请求连接服务器" class="headerlink" title="三、请求连接服务器"></a>三、请求连接服务器</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* server_addr, <span class="type">socklen_t</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数<ul>
<li>sockfd：套接字文件描述符</li>
<li>server_addr：sockaddr结构体指针，<strong>存放目标服务器的IP地址与端口号</strong>。我们构建的是sockaddr_id结构体，但两种结构体都是16字节，结构相似，可以进行强制类型转换。</li>
<li>addrlen：sockaddr的长度，sizeof()即可。</li>
</ul>
</li>
<li>返回值，成功0，失败-1。</li>
</ul>
<p><code>connect</code>并不意味着服务器端调用<code>accept</code>，可能会进入等待队列，<strong>这个函数的作用仅是通知 Linux 内核，让内核完成 TCP 三次握手连接。</strong></p>
<p><code>connect</code>会阻塞，直到连接成功&#x2F;失败。</p>
<p><code>connect</code>函数第二个参数保存的是目标服务器的结构体地址信息，那么客户端socket的地址信息在哪？：客户端IP地址和端口在调用<code>connect</code>时自动分配，无需<code>bind</code>，IP地址则是主机IP，端口随机。</p>
<h1 id="四、五、数据I-O与关闭连接"><a href="#四、五、数据I-O与关闭连接" class="headerlink" title="四、五、数据I&#x2F;O与关闭连接"></a>四、五、数据I&#x2F;O与关闭连接</h1><h1 id="六、服务器代码例程"><a href="#六、服务器代码例程" class="headerlink" title="六、服务器代码例程"></a>六、服务器代码例程</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9000    <span class="comment">//要连接到的服务器端口，服务器必须在这个端口上listen着</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv)</span></span>&#123;    </span><br><span class="line">    <span class="comment">//这些演示代码的写法都是固定套路，一般都这么写</span></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建客户端socket，地址家族，套接字类型，套接字协议</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置要连接到的服务器的信息</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;                <span class="comment">//选择协议族为IPV4</span></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT);         <span class="comment">//连接到的服务器端口，服务器监听这个地址</span></span><br><span class="line">    <span class="comment">//这里为了方便演示，要连接的服务器地址固定写</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">inet_pton</span>(AF_INET,<span class="string">&quot;192.168.1.126&quot;</span>,&amp;serv_addr.sin_addr) &lt;= <span class="number">0</span>)  <span class="comment">//IP地址转换函数,把第二个参数对应的ip地址转换第三个参数里边去，固定写法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;调用inet_pton()失败，退出！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;serv_addr,<span class="built_in">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;调用connect()失败，退出！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> recvline[<span class="number">1000</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(( n = <span class="built_in">read</span>(sockfd,recvline,<span class="number">1000</span>)) &gt; <span class="number">0</span>) <span class="comment">//仅供演示，非商用，所以不检查收到的宽度，实际商业代码，不可以这么写</span></span><br><span class="line">    &#123;</span><br><span class="line">        recvline[n] = <span class="number">0</span>; <span class="comment">//实际商业代码要判断是否收取完毕等等，所以这个代码只有学习价值，并无商业价值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;收到的内容为：%s\n&quot;</span>,recvline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd); <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序执行完毕，退出!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/04/20/network_programming/ch1-%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/20/network_programming/ch1-%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">ch1-基于TCP的服务器实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-20 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-20T00:00:00+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-17 20:08:02" itemprop="dateModified" datetime="2023-11-17T20:08:02+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230414100114373.png" alt="image-20230414100114373"></p>
<h1 id="一、创建socket"><a href="#一、创建socket" class="headerlink" title="一、创建socket"></a>一、创建socket</h1><p>作用为确定连接的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数：</p>
<ul>
<li><p>domain：协议族，协议族决定了socket的地址类型,在通信中必须采用相应的地址。</p>
<ul>
<li>PF_INET：ipv4互联网协议族</li>
<li>PF_INET6：ipv6互联网协议族</li>
<li>PF_LOCAL</li>
<li>PF_PACKET</li>
<li>PF_IPX</li>
</ul>
</li>
<li><p>type: 指定socket的数据传输方式（因为domain的协议族也可能有多个传输方式）:</p>
<ul>
<li><p>SOCK_STREAM：基于TCP的流格式套接字，不存在数据边界（<strong>因为该套接字有缓冲</strong>，发送方发多少次，接收方可以只收一次）</p>
<blockquote>
<p>缓冲会不会满？会，如果read的速度比收数据的速度满，缓冲会满，但不会丢失数据，因为如果缓冲满了，套接字会停止传输。</p>
</blockquote>
</li>
<li><p>SOCK_DGRAM：基于UDP的数据报格式套接字，存在数据边界（发送方发多少次，接收方收多少次）</p>
</li>
</ul>
</li>
<li><p>protocol：实际的传输协议，第一个参数决定第三个参数可选范围。</p>
<ul>
<li>常见的协议有IPPROTO_TCP、IPPROTO_UDP、 IPPROTO_SCTP、IPPROTO_TIPC他们分别对应这TCP传输协议,UDP传输协议,STCP传输协议,TIPC传输协议。当protocol为0时，会自动选择type类型对应的默认协议。</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：成功时返回一个唯一整数【文件描述符】，失败时返回-1</p>
</li>
<li><p>注意事项<br>第三个参数大多数时候传0，即保持默认，除非遇到下面的情况：<br><code>同一协议族中存在多个 数据传输方式 相同的协议（即指定了domain和type，仍不能确定某一协议）</code></p>
</li>
<li><p>例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPv4家族中面向连接的套接字， IPPROTO_TCP可省略填0</span></span><br><span class="line"><span class="type">int</span> tcp_socket = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP)</span><br><span class="line"><span class="comment">// IPv4家族中面向消息的套接字，同样可省略</span></span><br><span class="line"><span class="type">int</span> udp_socket = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, IPPROTO_UDP) </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二、-IP地址、端口信息存储"><a href="#二、-IP地址、端口信息存储" class="headerlink" title="二、 IP地址、端口信息存储"></a>二、 IP地址、端口信息存储</h1><p>用于存放要连接的<strong>IP地址</strong>和<strong>端口号</strong>，并指定地址族</p>
<p>此部分需要注意两种结构体<code>sockaddr</code>和<code>sockaddr_in</code>。</p>
<p>直接向<code>sockaddr</code>写入IP和端口信息较为麻烦，而设置<code>sockaddr_in</code>较为方便；但由于后续的传参要用到<code>sockaddr</code>，而两种类型是相似的，直接强制类型转换即可。</p>
<p>另外，<code>sockaddr_in</code>是表示IPv4的结构体，但为什么还要设置地址族<code>sin_family</code>。这是为了和<code>sockaddr</code>保持一致，而sockaddr并非只为IPv4设计。</p>
<h3 id="结构体成员细节"><a href="#结构体成员细节" class="headerlink" title="结构体成员细节"></a>结构体成员细节</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//早期的sockaddr，并非只为IPv4设计</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">sa_family_t</span> sa_family; <span class="comment">/* adress family: AF_XXX */</span> </span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];<span class="comment">/* 14 bytes of protocol */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IPv4的sockaddr</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family;                 <span class="comment">//地址族（Address Family），也就是地址类型</span></span><br><span class="line">    <span class="type">uint16_t</span>        sin_port;                   <span class="comment">//16位的端口号，以网络字节序保存</span></span><br><span class="line">    <span class="keyword">struct</span>            <span class="title class_">in_addr</span>  sin_addr;     <span class="comment">//32位IP地址</span></span><br><span class="line">    <span class="type">char</span>              sin_zero[<span class="number">8</span>];             <span class="comment">//不使用，一般用0填充，目的是与sockaddr结构体保持一致</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中in_addr</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">in_addr_t</span> s_addr; <span class="comment">/*32-bit IPV4 address*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>sin_family：地址族（Address Family）<ul>
<li>AF_INET：ipv4网络协议地址族</li>
<li>AF_INET6：ipv6</li>
<li>AF_LOCAL：</li>
</ul>
</li>
<li>sin_port：以<strong>网络字节序</strong>保存16位端口号</li>
<li>sin_addr：也是一个结构体，但内部只有一个32位的成员s_addr，存放的是IP地址的<strong>网络字节序</strong>。</li>
</ul>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230413123150638.png" alt="image-20230413123150638" style="zoom:50%;" />

<p>向sockaddr_in注入地址时，需要将<strong>ip地址的字符串形式</strong>和<strong>端口号的主机字节序形式</strong>转化为<strong>网络字节序</strong>的形式；而相反地，网络字节序也能转化回字符串形式和主机字节序形式。（字符串形式本质是ASCII码存储的形式，在主机也是以主机字节序存储，也要转化为网络字节序）</p>
<p><strong>值得注意的是，除了向sockaddr_in结构体填充数据外，其他情况无需考虑字节序问题。</strong></p>
<h3 id="sockaddr-in结构体设置例程"><a href="#sockaddr-in结构体设置例程" class="headerlink" title="sockaddr_in结构体设置例程"></a>sockaddr_in结构体设置例程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">serv_addr.sin_family = AF_INET; <span class="comment">//选择协议族为IPV4 </span></span><br><span class="line">serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT); <span class="comment">//绑定我们自定义的端口号，客户端程序和我们服务器程序通讯时，就要往这个端口连接和传送数据 </span></span><br><span class="line">serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"><span class="comment">// 一个服务器可能有多块网卡，每个网卡也可能配置多个IP地址，所以用INADDR_ANY，表示服务器的所有可用IP地址，这样监听到9000端口，无论是哪个IP地址都能收到</span></span><br></pre></td></tr></table></figure>

<h2 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h2><h3 id="1-大小端"><a href="#1-大小端" class="headerlink" title="1 大小端"></a>1 大小端</h3><p>假设主机字节序中，存储是数据是0x12345678</p>
<ul>
<li>大端模式（网络字节序）：高位字节存放在内存的低地址处</li>
</ul>
<table>
<thead>
<tr>
<th>数据</th>
<th>12</th>
<th>34</th>
<th>56</th>
<th>78</th>
</tr>
</thead>
<tbody><tr>
<td>地址</td>
<td>0x00</td>
<td>0x01</td>
<td>0x02</td>
<td>0x03</td>
</tr>
</tbody></table>
<p>大端适合网络传输（流方式或者缓冲区）一次读一个字节，然后解析字节，读下一个字节。</p>
<ul>
<li>小端模式：高位字节存放在内存的高地址处</li>
</ul>
<table>
<thead>
<tr>
<th>数据</th>
<th>78</th>
<th>56</th>
<th>34</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>地址</td>
<td>0x00</td>
<td>0x01</td>
<td>0x02</td>
<td>0x03</td>
</tr>
</tbody></table>
<p>小端适合逻辑电路</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/458844566/answer/2567243550">https://www.zhihu.com/question/458844566/answer/2567243550</a></p>
</blockquote>
<h3 id="端口号的网络字节序转换"><a href="#端口号的网络字节序转换" class="headerlink" title="端口号的网络字节序转换"></a>端口号的网络字节序转换</h3><p>然后介绍4种转化字节的方法。htons中h表示主机host，n表示网络network，s表示short，所以是h、to、n、s、l的排列组合，htons解释为把short型数据从主机字节序列转化为网络字节序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">htons</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">ntohs</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">htonl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">ntohl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>转化实例</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> host_port = <span class="number">0x1234</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> net_port;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> host_port_l = <span class="number">0x12345678</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> net_port_l;</span><br><span class="line">	</span><br><span class="line">	net_port = <span class="built_in">htons</span>(host_port);</span><br><span class="line">	net_port_l = <span class="built_in">htonl</span>(host_port_l);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Host ordered port short: %#x \n&quot;</span>, host_port);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Nerwork ordered port short: %#x \n&quot;</span>, net_port);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Host ordered port long: %#xl \n&quot;</span>, host_port_l);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Nerwork ordered port long: %#xl \n&quot;</span>, net_port_l);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图小端cpu的转化结果，若是在大端CPU上，则不会变化<br><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230413115930385.png" alt="image-20230413115930385"></p>
<h3 id="ip地址的网络字节序转换"><a href="#ip地址的网络字节序转换" class="headerlink" title="ip地址的网络字节序转换"></a>ip地址的网络字节序转换</h3><p>用到的函数分别inet_addr()、inet_aton()、inet_ntoa()、inet_pton()、inet_ntop()，转化的方向如下图。</p>
<p><img src="https://github.com/drinkwateronly/Image-Host/blob/main/iimage/image-20230413115034891.png?raw=true" alt="image-20230413115034891"></p>
<h4 id="2-1-inet-addr"><a href="#2-1-inet-addr" class="headerlink" title="2.1 inet_addr()"></a>2.1 inet_addr()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：是将一个点分十进制ipv4的IP地址转换32位大端网络字节序整数</li>
<li>参数：点分十进制的ip地址字符串ip</li>
<li>返回值：成功时返回32位大端整数，失败返回INADDR_NONE</li>
</ul>
<h4 id="2-2-inet-aton-和inet-ntoa"><a href="#2-2-inet-aton-和inet-ntoa" class="headerlink" title="2.2 inet_aton()和inet_ntoa()"></a>2.2 inet_aton()和inet_ntoa()</h4><p><code>inet_addr()</code>直接返回结果，而<code>inet_aton()</code>将转换结果直接写入传入的参数中，方便向sockaddr_in注入IP地址。<br>记法：ASCII to network &#x2F; network to ASCII</p>
<h5 id="inet-aton"><a href="#inet-aton" class="headerlink" title="inet_aton()"></a>inet_aton()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="keyword">struct</span> in_addr *addr)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：是将一个点分十进制的ipv4的IP地址转换32位大端网络字节序整数，结果直接填入in_addr中，使用频率比<code>inet_addr()</code>多。</li>
<li>参数：</li>
</ul>
<blockquote>
<ol>
<li>string: 点分十进制的ip地址字符串ip</li>
<li>addr: 属于sockaddr_in结构体的结构体in_addr地址</li>
</ol>
</blockquote>
<ul>
<li>返回值：成功时返回1，失败返回0</li>
</ul>
<h5 id="inet-ntoa"><a href="#inet-ntoa" class="headerlink" title="inet_ntoa()"></a>inet_ntoa()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr *addr )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：是将一个32位大端网络字节序整数转换为点分十进制的ipv4的IP地址。</li>
<li>参数：</li>
</ul>
<blockquote>
<ol>
<li>addr: 属于sockaddr_in结构体的结构体in_addr地址</li>
</ol>
</blockquote>
<ul>
<li>返回值：存放转化结果的首地址，char*指针，要提前分配空间。失败时返回-1。</li>
</ul>
<h4 id="2-3-inet-pton-inet-ntop"><a href="#2-3-inet-pton-inet-ntop" class="headerlink" title="2.3 inet_pton()inet_ntop()"></a>2.3 inet_pton()inet_ntop()</h4><p>前面的只适用于ipv4地址，这两个适用于ipv4和ipv6，因此使用时要指定地址族<br>记法：presentation to numeric &#x2F; numeric to presentation</p>
<h5 id="inet-pton"><a href="#inet-pton" class="headerlink" title="inet_pton()"></a>inet_pton()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *ip, <span class="type">void</span> *dst)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：将ipv4或者ipv6的字符串ip地址转换为大端网络字节序整数</li>
<li>参数：</li>
</ul>
<blockquote>
<ol>
<li>af: 地址族，取值为AF_INET和AF_INET6，分别ipv4和ipv6</li>
<li>ip：要转化的ip字符串首地址</li>
<li>dst：接收转化后大端网络字节序整数结果的地址，ipv4可以用sin_addr</li>
</ol>
</blockquote>
<ul>
<li>返回值：如果函数出错将返回一个负值，并将errno设置为EAFNOSUPPORT，如果参数af指定的地址族和ip格式不对，函数将返回0。</li>
</ul>
<h5 id="inet-ntop"><a href="#inet-ntop" class="headerlink" title="inet_ntop()"></a>inet_ntop()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> cnt)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：将为大端网络字节序整数转换为ipv4或者ipv6的字符串ip地址</li>
<li>参数：</li>
</ul>
<blockquote>
<ol>
<li>af: 地址族，取值为AF_INET和AF_INET6，分别ipv4和ipv6</li>
<li>src：大端网络字节序整数首地址地址，ipv4可以用sin_addr</li>
<li>dst：接收转化后的ip地址字符串首地址（缓冲区）</li>
<li>cnt：dst缓冲区大小</li>
</ol>
</blockquote>
<ul>
<li>返回值：<br>如果缓存区太小无法存储地址的值，则返回一个空指针，并将errno置为ENOSPC。若无错误发生，Inet_ntop()函数返回一个指向缓冲区的指针。</li>
</ul>
<h4 id="2-4例程"><a href="#2-4例程" class="headerlink" title="2.4例程"></a>2.4例程</h4><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">char</span> ip1[] = <span class="string">&quot;192.168.0.74&quot;</span>;  </span><br><span class="line">    <span class="type">char</span> fakeip[] = <span class="string">&quot;192.256.0.74&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_inet</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    inet_addr()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip %s converting\n&quot;</span>,ip1);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> net_ordered_addr = inet_addr(ip1);</span><br><span class="line">    <span class="keyword">if</span>(net_ordered_addr == INADDR_NONE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_addr() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_addr() success: network ordered integer addr: %#x \n\n&quot;</span>,</span><br><span class="line">            net_ordered_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fake ip</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake ip %s converting\n&quot;</span>, fakeip);</span><br><span class="line">    net_ordered_addr = inet_addr(fakeip);</span><br><span class="line">    <span class="keyword">if</span>(inet_aton(fakeip,&amp;addr_inet.sin_addr)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_addr() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_addr() success: network ordered integer addr: %#x \n\n&quot;</span>,</span><br><span class="line">            net_ordered_addr);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    inet_aton() and inet_ntoa()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip %s converting\n&quot;</span>,ip1);</span><br><span class="line">    <span class="keyword">if</span>(inet_aton(ip1,&amp;addr_inet.sin_addr)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_aton() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_aton() success: network ordered integer addr: %#x \n\n&quot;</span>,</span><br><span class="line">            addr_inet.sin_addr.s_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;network odered addr %#x converting\n&quot;</span>,addr_inet.sin_addr.s_addr);</span><br><span class="line">    <span class="type">char</span> *ip_new;</span><br><span class="line">    ip_new = inet_ntoa(addr_inet.sin_addr);</span><br><span class="line">    <span class="keyword">if</span>(ip_new[<span class="number">0</span>]== <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_ntoa() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_ntoa() success: ip: %s \n\n&quot;</span>, ip_new);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    inet_pton() and inet_ntop()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">char</span> ip2[] = <span class="string">&quot;255.255.255.255&quot;</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip %s converting\n&quot;</span>, ip2);</span><br><span class="line">    <span class="keyword">if</span>(!inet_pton(AF_INET, ip2, (<span class="type">void</span> *) &amp;addr_inet.sin_addr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton() success: network ordered integer addr: %#x \n\n&quot;</span>,</span><br><span class="line">            addr_inet.sin_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> ip2_new[<span class="number">16</span>];  <span class="comment">//ipv4的字符串长度为16字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;network odered addr %#x converting\n&quot;</span>, addr_inet.sin_addr.s_addr);</span><br><span class="line">    <span class="keyword">if</span>(!inet_ntop(AF_INET, (<span class="type">void</span> *) &amp;addr_inet.sin_addr, ip2_new, <span class="keyword">sizeof</span>(ip2_new)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton() error\n\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton() success: ip: %s \n\n&quot;</span>, ip2_new);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><h1 id="三、向套接字分配网络地址"><a href="#三、向套接字分配网络地址" class="headerlink" title="三、向套接字分配网络地址"></a>三、向套接字分配网络地址</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：bind 能够将socket文件描述符、端口号和ip绑定到一起。因为socket只指明了协议。</li>
<li>返回值：成功时返回0，失败返回-1</li>
<li>参数：<ul>
<li>sockfd： 表示socket函数创建的通信文件描述符</li>
<li>addr： struct sockaddr_in或sockaddr的首地址，用于设定要绑定的ip和端口</li>
<li>addrlen： 表示所指定addr结构体的大小</li>
</ul>
</li>
</ul>
<h1 id="四、进入-等待连接请求-状态"><a href="#四、进入-等待连接请求-状态" class="headerlink" title="四、进入 等待连接请求 状态"></a>四、进入 等待连接请求 状态</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：<br>将套接字文件描述符从主动（<strong>主动向对方发送数据</strong>）转为被动文件描述符，然后用于被动监听客户端的连接</li>
<li>参数：<ul>
<li>sockfd：socket文件描述符</li>
<li>backlog：指定队列的容量，一般设置队列的容量为2，3即可。队列的最大容量需要小于30</li>
</ul>
</li>
<li>返回值：成功返回0，失败返回-1， errno被设置</li>
</ul>
<p><code>listen()</code>函数不会阻塞，它仅将该套接字和套接字对应的连接队列长度告诉 Linux 内核后结束。<strong>当客户端connect，内核自动完成TCP三次握手</strong>。然后建立好的连接会自动存储到<code>listen()</code>所创建的队列中。</p>
<p>注意，在<code>listen()</code>调用之前，客户端如果调用<code>connect()</code>会发生错误。</p>
<h2 id="4-1-listen队列剖析"><a href="#4-1-listen队列剖析" class="headerlink" title="4.1 listen队列剖析"></a>4.1 listen队列剖析</h2><h3 id="4-1-1-两个队列"><a href="#4-1-1-两个队列" class="headerlink" title="4.1.1 两个队列"></a>4.1.1 两个队列</h3><p>对于一个调用<code>listen</code>的套接字，OS会为其维护两个队列</p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230421101903025.png" alt="image-20230421101903025" style="zoom:50%;" />

<ul>
<li><p>未完成连接队列：</p>
<p>当客户端发送TCP握手第一次握手（SYN），服务器端会在未完成连接队列创建一个对应项，该项可以看作是一个半连接，状态从<code>LISTEN</code>变成<code>SYN_RCVD</code>，同时服务器向客户端第二次握手（SYN+ACK），等待来自客户端的第三次握手。</p>
</li>
<li><p>已完成连接队列</p>
<p>三次握手完成后，连接变成<code>ESTABLISHED</code>状态，放入已连接队列中</p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230421102441451.png" alt="image-20230421102441451" style="zoom: 67%;" />

<p>有两个RTT，分别针对客户端与服务器而言。三次握手需要大约187ms建立，比较慢。</p>
</li>
</ul>
<h3 id="4-1-2-出现的问题与如何避免"><a href="#4-1-2-出现的问题与如何避免" class="headerlink" title="4.1.2 出现的问题与如何避免"></a>4.1.2 出现的问题与如何避免</h3><p>可以看到客户端的<code>connect</code>是收到第二次握手包就返回了，如果客户端迟迟不发送第三个握手包，该半连接项约75s就会被OS删除。</p>
<p>如果队列已满，客户端发送来SYN请求，服务器不会回应，几次后客户端认为连接失败。</p>
<p>进而产生了一种攻击：SYN攻击，即客户端一直只发送第一个握手包，使得队列超过<code>backlog</code>，使得队列变满，正常用户无法连接。</p>
<ul>
<li>原本<code>listen</code>函数<code>backlog</code>参数的含义是以上两个队列之和</li>
<li>后来改成：<strong>指定套接字（服务器监听套接字）上内核为其排队的最大已完成连接数</strong>，也就是<code>ESTABLISHED</code>队列的长度，忽略了<code>SYN_RCVD</code>队列长度。此时程序员只需要关心尽快用<code>accept</code>（下一节内容）将连接取走腾出位置。但实际上仍有未完成连接队列，只不过OS会对他处理。</li>
</ul>
<h1 id="五、受理客户端请求"><a href="#五、受理客户端请求" class="headerlink" title="五、受理客户端请求"></a>五、受理客户端请求</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>函数功能：<br>从established 状态的连接队列头部取出一个已经完成的连接，<strong>产生用于数据IO的套接字（返回值）</strong>。</p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230414104357561.png" alt="image-20230414104357561" style="zoom: 67%;" />
</li>
<li><p>函数返回值：成功返回<strong>套接字描述符</strong>，失败返回-1</p>
</li>
<li><p>参数</p>
<ul>
<li>sockfd：表示socket创建的监听socket描述符</li>
<li>addr：用于存放发起连接请求的那个客户端的地址结构体sockaddr地址</li>
<li>addrlen：存放第二个参数addr的大小的变量地址</li>
</ul>
</li>
</ul>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul>
<li><p><strong>注意两个套接字，<code>socket()</code>生成的套接字是用于<code>bind</code>绑定和<code>listen</code>监听和<code>accept</code>受理请求，而<code>accept</code>生成的套接字用于和客户端交换数据。</strong></p>
</li>
<li><p>套接字文件描述符默认是阻塞的，即如果没有客户端请求连接的时候，此时accept会<strong>阻塞</strong>，直到有客户端连接；如果不想套接字文件描述符阻塞，则可以创建套接字 socket函数 时指定type为SOCK_NOBLOCK。</p>
</li>
<li><p>如果accept没来得及取走一个连接，由于三次握手已经完成，套接字已经创建，此时客户端发送数据过来，就会发送到套接字的接收缓冲区，缓冲区大小就是最大能接受的数据量。</p>
</li>
</ul>
<h1 id="六、数据传输"><a href="#六、数据传输" class="headerlink" title="六、数据传输"></a>六、数据传输</h1><p>此后就可以通过操作<code>accept</code>所返回套接字对客户端进行IO数据传输。可以使用系统I&#x2F;O直接对文件描述符操作，也可以将文件描述符转为FILE指针用C标准库IO操作。</p>
<h1 id="七、关闭连接"><a href="#七、关闭连接" class="headerlink" title="七、关闭连接"></a>七、关闭连接</h1><p>对客户端的服务结束后，调用<code>close</code>关闭套接字，即关闭了连接。流的概念是通过<strong>相互连接的套接字</strong>进入数据交换的状态，下图展示了TCP套接字的流。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415131850510.png" alt="image-20230415131850510"></p>
<p><code>close</code>意味着完全断开两个流，这样的关闭方式不够优雅。可以使用<code>shutdown</code>进行半关闭。这样的话在一端传递完数据半关闭连接后，另一端仍能传递数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> howto)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li>sock：要关闭的socket</li>
<li>howto：如何关闭<ul>
<li>SHUT_RD：断开输入流</li>
<li>SHUT_WR：断开输出流</li>
<li>SHUT_RDWR：同时断开</li>
</ul>
</li>
</ul>
</li>
<li>返回：成功0，失败-1</li>
</ul>
<h1 id="八、服务器代码例程"><a href="#八、服务器代码例程" class="headerlink" title="八、服务器代码例程"></a>八、服务器代码例程</h1><p>来自《C++新经典 Linux C++通信架构实战》</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9000  <span class="comment">//本服务器要监听的端口号，一般1024以下的端口很多都是属于周知端口，所以我们一般采用1024之后的数字做端口号</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">//这些演示代码的写法都是固定套路，一般都这么写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器的socket套接字【文件描述符】</span></span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>                  <span class="comment">//服务器的地址结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));        <span class="comment">//初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置本服务器要监听的地址和端口，这样客户端才能连接到该地址和端口并发送数据</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;                <span class="comment">//选择协议族为IPV4</span></span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);         <span class="comment">//绑定我们自定义的端口号，客户端程序和我们服务器程序通讯时，就要往这个端口连接和传送数据</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">//监听本地所有的IP地址；INADDR_ANY表示的是一个服务器上所有的网卡（服务器可能不止一个网卡）多个本地ip地址都进行绑定端口号，进行侦听。</span></span><br><span class="line"></span><br><span class="line">    bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));<span class="comment">//绑定服务器地址结构体</span></span><br><span class="line">    listen(listenfd, <span class="number">32</span>);     <span class="comment">//参数2表示服务器可以积压的未处理完的连入请求总个数，客户端来一个未连入的请求，请求数+1，连入请求完成，c/s之间进入正常通讯后，请求数-1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> connfd;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pcontent = <span class="string">&quot;I sent sth to client!&quot;</span>; <span class="comment">//指向常量字符串区的指针</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//卡在这里，等客户单连接，客户端连入后，该函数走下去【注意这里返回的是一个新的socket——connfd，后续本服务器就用connfd和客户端之间收发数据，而原有的lisenfd依旧用于继续监听其他连接】        </span></span><br><span class="line">        connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据包给客户端</span></span><br><span class="line">        write(connfd,pcontent,<span class="built_in">strlen</span>(pcontent)); <span class="comment">//注意第一个参数是accept返回的connfd套接字</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只给客户端发送一个信息，然后直接关闭套接字连接；</span></span><br><span class="line">        close(connfd); </span><br><span class="line">    &#125; <span class="comment">//end for</span></span><br><span class="line">    close(listenfd);     <span class="comment">//实际本简单范例走不到这里，这句暂时看起来没啥用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/04/20/network_programming/ch4-IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E5%9F%9F%E5%90%8D%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/20/network_programming/ch4-IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E5%9F%9F%E5%90%8D%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">ch4-IP地址与域名转换</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-20 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-20T00:00:00+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-17 20:08:22" itemprop="dateModified" datetime="2023-11-17T20:08:22+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-DNS"><a href="#1-DNS" class="headerlink" title="1 DNS"></a>1 DNS</h1><p>DNS（Domain Name System），即IP和域名相互转换的系统，核心是DNS服务器。</p>
<p>ISP服务提供者维护IP地址时可能会变更IP地址，而域名一旦注册通常不会变化，<strong>因此利用域名编写程序就不会依赖某个服务器IP地址</strong>。</p>
<p>查看本机的DNS服务器地址</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; nslookup</span><br></pre></td></tr></table></figure>

<h1 id="2-通过域名获取IP地址gethostbyname"><a href="#2-通过域名获取IP地址gethostbyname" class="headerlink" title="2 通过域名获取IP地址gethostbyname()"></a>2 通过域名获取IP地址gethostbyname()</h1><h2 id="2-1-使用方法"><a href="#2-1-使用方法" class="headerlink" title="2.1 使用方法"></a>2.1 使用方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hostname)</span></span><br></pre></td></tr></table></figure>
<p>成功返回hostent结构体地址，失败返回null指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> * h_name; </span><br><span class="line">    <span class="type">char</span> ** h_aliases;</span><br><span class="line">    <span class="type">int</span> h_addrtype;</span><br><span class="line">    <span class="type">int</span> h_length;</span><br><span class="line">    <span class="type">char</span> ** h_addr_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>h_name：官方域名</li>
<li>h_aliases：除官方域名外同样能访问的其他域名</li>
<li>h_addrtype：ip地址族类型</li>
<li>h_length：ip地址长度（IPv4是4字节，IPv6是16字节</li>
<li>h_addr_list：<strong>最重要的成员</strong>。用户多的网站会分配多个IP给一个域名，利用多个服务器进行负载均衡，所以存放多个IP地址。</li>
</ul>
</blockquote>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415154631974.png" alt="image-20230415154631974" style="zoom:67%;" />

<p>注意，<code>h_addr_list</code>是一个char指针数组（字符串地址构成的数组），但数组元素实际保存的是<code>in_addr</code>结构体变量地址值，结构体如下，s_addr保存一个网络字节序（大端）的IP整型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr; <span class="comment">/*32-bit IPV4 address*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>原因是hostent结构体并非只是为ipv4准备的（sockaddr和sockaddr_in也是有类似的关系，sockaddr并非只为ipv4准备）。</strong></p>
</li>
<li><p><strong>看起来声明为void指针数组更合适，而<code>hostent</code>结构体是在void指针标准化前就定义的，当时无法明确指出指针类型时采用char指针。</strong></p>
</li>
</ul>
<h2 id="2-2-例程"><a href="#2-2-例程" class="headerlink" title="2.2 例程"></a>2.2 例程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;addr&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取ip地址信息</span></span><br><span class="line">    host = gethostbyname(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(!host)</span><br><span class="line">        error_handling(<span class="string">&quot;gethostbyname() error&quot;</span>);</span><br><span class="line">    <span class="comment">// 其他附带的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Official name: %s \n&quot;</span>, host-&gt;h_name);      </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; host-&gt;h_aliases[i]; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Official name: %s \n&quot;</span>, host-&gt;h_aliases[i]);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address type: %s \n&quot;</span>,</span><br><span class="line">                (host-&gt;h_addrtype==AF_INET?<span class="string">&quot;AF_INET&quot;</span>:<span class="string">&quot;AF_INET6&quot;</span>));    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IP length: %d \n&quot;</span>, host-&gt;h_length);    </span><br><span class="line">    <span class="comment">// ip地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> *<span class="title">inaddr</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; host-&gt;h_addr_list[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 强制类型转化</span></span><br><span class="line">        <span class="comment">// h_addr_list是一个char指针数组（字符串地址构成的数组），但数组元素实际保存的是in_addr结构体变量地址值</span></span><br><span class="line">        inaddr = (<span class="keyword">struct</span> in_addr *)host-&gt;h_addr_list[i];</span><br><span class="line">        <span class="comment">// 查看网络字节序ip地址的整数形式</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in_addr.s_addr: %d \n&quot;</span>,inaddr-&gt;s_addr);</span><br><span class="line">        <span class="comment">// inet_ntoa转化网络字节序为字符串IP地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP address: %s \n&quot;</span>, inet_ntoa(*inaddr));  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-运行结果"><a href="#2-3-运行结果" class="headerlink" title="2.3 运行结果"></a>2.3 运行结果</h2><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415152343436.png" alt="image-20230415152343436"><br>结果中得到了<a href="http://www.baidu.com域名的ip地址信息，一个值得关注的点是，在in_addr结构体中的s_addr整数存放的是网络字节序（大端）的整数形式的IP地址。IP地址大小端存放方式与对应十进制整数的转化方式如下：">www.baidu.com域名的ip地址信息，一个值得关注的点是，在in_addr结构体中的s_addr整数存放的是网络字节序（大端）的整数形式的IP地址。IP地址大小端存放方式与对应十进制整数的转化方式如下：</a></p>
<h3 id="小端"><a href="#小端" class="headerlink" title="小端"></a>小端</h3><p>小端存放的IP地址转十进制整数的方式为：</p>
<table>
<thead>
<tr>
<th>十进制</th>
<th>182</th>
<th>61</th>
<th>200</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>二进制</td>
<td>10110110</td>
<td>00111101</td>
<td>11001000</td>
<td>00000111</td>
</tr>
<tr>
<td>地址顺序</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>串联二进制10110110001111011100100000000111 -&gt; 转为十进制3057502215</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="大端"><a href="#大端" class="headerlink" title="大端"></a>大端</h3><p>in_addr存放IP地址的方式是网络字节序（大端），即高位数据在低地址，地址顺序如上表。而电脑（小端）读取顺序从低地址开始读，先读到的是这个数的最低字节，所以读取到数据为：</p>
<table>
<thead>
<tr>
<th>7</th>
<th>200</th>
<th>61</th>
<th>182</th>
</tr>
</thead>
<tbody><tr>
<td>00000111</td>
<td>11001000</td>
<td>00111101</td>
<td>10110110</td>
</tr>
</tbody></table>
<p>串联二进制00000111110010000011110110110110-&gt; 转为十进制130563510，所以in_addr.s_addr的整数形式是130563510。</p>
<h1 id="3-通过IP获取域名信息gethostbyaddr"><a href="#3-通过IP获取域名信息gethostbyaddr" class="headerlink" title="3 通过IP获取域名信息gethostbyaddr()"></a>3 通过IP获取域名信息gethostbyaddr()</h1><h2 id="3-1-使用方法"><a href="#3-1-使用方法" class="headerlink" title="3.1 使用方法"></a>3.1 使用方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* addr, <span class="type">socklen_t</span> len, <span class="type">int</span> family)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数<ul>
<li>addr：IP地址的网络字节序，一般是存放在in_addr结构体，并在传参的时候(char*)对结构体地址强制类型转换。（实际测试时，似乎也不需要强制类型转换）</li>
<li>len：IP地址字节长度</li>
<li>family：IP地址协议族（AF_INET或者AF_INET6）</li>
</ul>
</li>
<li>返回值：成功返回hostent结构体地址，失败返回null</li>
</ul>
<h2 id="3-2-例程"><a href="#3-2-例程" class="headerlink" title="3.2 例程"></a>3.2 例程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>,stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hostent</span> *host;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ip转为网络字节序</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sockaddr;</span><br><span class="line">    <span class="comment">/* 方法1</span></span><br><span class="line"><span class="comment">    // ip地址转网络字节序并存放在sockaddr_in的in_addr结构体</span></span><br><span class="line"><span class="comment">    sockaddr.sin_addr.s_addr = inet_addr(argv[1]);</span></span><br><span class="line"><span class="comment">    memset(&amp;sockaddr, 0, sizeof(sockaddr));</span></span><br><span class="line"><span class="comment">    host = gethostbyaddr((char*)&amp;sockaddr.sin_addr, 4, AF_INET);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 方法2</span></span><br><span class="line">    <span class="comment">// ip地址转网络字节序并存放在单独的in_addr结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> inaddr1;</span><br><span class="line">    inaddr1.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 注意(char*)</span></span><br><span class="line">    host = <span class="built_in">gethostbyaddr</span>((<span class="type">char</span>*)&amp;inaddr1, <span class="number">4</span>, AF_INET);</span><br><span class="line">    <span class="keyword">if</span>(!host)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;gethostbyname() error&quot;</span>);</span><br><span class="line">    <span class="comment">// 其他附带的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Official name: %s \n&quot;</span>, host-&gt;h_name);      </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; host-&gt;h_aliases[i]; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Official name: %s \n&quot;</span>, host-&gt;h_aliases[i]);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address type: %s \n&quot;</span>,</span><br><span class="line">                (host-&gt;h_addrtype==AF_INET?<span class="string">&quot;AF_INET&quot;</span>:<span class="string">&quot;AF_INET6&quot;</span>));    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IP length: %d \n&quot;</span>, host-&gt;h_length);    </span><br><span class="line">    <span class="comment">// ip地址信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> *inaddr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; host-&gt;h_addr_list[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        inaddr = (<span class="keyword">struct</span> in_addr *)host-&gt;h_addr_list[i];</span><br><span class="line">        <span class="comment">// 查看in_addr.s_addr的网络字节序ip地址，整数存放</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in_addr.s_addr: %u \n&quot;</span>,inaddr-&gt;s_addr);</span><br><span class="line">        <span class="comment">// inet_ntoa转化网络字节序为字符串IP地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP address: %s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(*inaddr));  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-结果"><a href="#3-3-结果" class="headerlink" title="3.3 结果"></a>3.3 结果</h2><p> <img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415153656086.png" alt="image-20230415153656086"><br>通过2小节的gethostbyname获取了baidu.com的ip地址，但对ip地址获取时出现了获取不了host信息，并不是代码出错，看到网上不少人也出现这样的问题。一个猜测是：</p>
<blockquote>
<p>gethostbyname可以通过DNS服务器通过域名获取ip地址等信息。但是gethostbyaddr输入参数时ip地址，这样无需经过dns转换，无法获取域名等信息，但是可以在hosts文件中增加一个映射，它应该会检查hosts文件。所以在host文件添加ip和域名的映射即可。<br><a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/391815602">https://bbs.csdn.net/topics/391815602</a></p>
</blockquote>
<p>而获取电信dns服务器114.114.114.114的host信息是可以的<br><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415153750412.png" alt="image-20230415153750412"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/04/20/network_programming/ch3-%E5%9F%BA%E4%BA%8EUDP%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/20/network_programming/ch3-%E5%9F%BA%E4%BA%8EUDP%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/" class="post-title-link" itemprop="url">ch3-基于UDP的服务器实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-20 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-20T00:00:00+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-17 20:08:14" itemprop="dateModified" datetime="2023-11-17T20:08:14+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、UDP"><a href="#一、UDP" class="headerlink" title="一、UDP"></a>一、UDP</h1><ul>
<li>UDP不会像TCP那样发送ACK，或者对包进行SEQ排序，可靠性虽然不及TCP，但在性能有时会更好，因为数据损毁的情况并没有想象中那么容易发生。所以在追求性能而非可靠性时UDP是更好的选择。</li>
<li>TCP为了提供可靠性，在不可靠的IP层进行<strong>流控制</strong>；UDP正是缺少流控制机制。这也是区分它们的重要标志。</li>
<li>UDP最重要的作用是根据端口号，将传输到目标主机的数据包交付给最终的UDP套接字。而主机A到主机B的传送由IP层完成。</li>
<li>TCP不存在数据边界：即数据传输过程中调用I&#x2F;O次数不具有任何意义；UDP数据边界：输入函数的调用次数和输出函数调用次数完全一致。</li>
</ul>
<h1 id="二、实现UDP服务器-客户端"><a href="#二、实现UDP服务器-客户端" class="headerlink" title="二、实现UDP服务器&#x2F;客户端"></a>二、实现UDP服务器&#x2F;客户端</h1><p>UDP服务器没有TCP的<code>listen</code>和<code>accept</code>，即没有连接过程，<strong>只有创建socket和数据交换过程。</strong></p>
<p>TCP服务器中套接字应该是一对一，除了监听的那个套接字，若要向10个客户端提供服务，还需要10个套接字。UDP中服务器只需要一个套接字，收发都是通过这个套接字。</p>
<p>某种意义上，无法区分TCP服务器和客户端。</p>
<h2 id="2-1基于UDP的IO函数"><a href="#2-1基于UDP的IO函数" class="headerlink" title="2.1基于UDP的IO函数"></a>2.1基于UDP的IO函数</h2><h3 id="2-1-1-sendto"><a href="#2-1-1-sendto" class="headerlink" title="2.1.1 sendto()"></a>2.1.1 sendto()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sock, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">struct</span> sockaddr *to, <span class="type">socklen_t</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：向目标IP的端口以UDP方式传输数据</li>
<li>参数：<ul>
<li>sock：客户端套接字</li>
<li>buff：待传输数据的缓冲区地址</li>
<li>nbytes：待传输数据的字节数</li>
<li>flags：可选参数，暂未深入，设为0即可</li>
<li>to：目标的sockaddr结构体地址</li>
<li>addrlen：目标的sockaddr结构体的字节长度</li>
</ul>
</li>
<li>返回值：失败返回-1，成功返回发送的字节数</li>
</ul>
<h3 id="2-1-2-recvfrom"><a href="#2-1-2-recvfrom" class="headerlink" title="2.1.2 recvfrom()"></a>2.1.2 recvfrom()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sock, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">struct</span> sockaddr *to, <span class="type">socklen_t</span> *addrlen)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：接收UDP方式传来的数据，并获取发送方地址信息的sockaddr结构体</li>
<li>参数：<ul>
<li>sock：客户端套接字</li>
<li>buff：接收数据的缓冲区地址</li>
<li>nbytes：缓冲区的字节数</li>
<li>flags：可选参数，暂未深入，设为0即可</li>
<li>from：来自发送方的sockaddr结构体（额外存放，并非接收方的sockaddr结构体）</li>
<li>addrlen：存放来自发送方的sockaddr结构体长度的地址</li>
</ul>
</li>
<li>返回值：失败返回-1，成功返回接收的字节数</li>
</ul>
<h2 id="2-2-回声服务器-客户端例程"><a href="#2-2-回声服务器-客户端例程" class="headerlink" title="2.2 回声服务器&#x2F;客户端例程"></a>2.2 回声服务器&#x2F;客户端例程</h2><h3 id="2-2-1-服务器"><a href="#2-2-1-服务器" class="headerlink" title="2.2.1 服务器"></a>2.2.1 服务器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 20</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意是生成UDP的socket</span></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_sock == <span class="number">-1</span>) </span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="comment">// 有bind()</span></span><br><span class="line">    <span class="keyword">if</span>(bind(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    <span class="comment">// 数据交换</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        <span class="comment">// recvfrom</span></span><br><span class="line">        str_len = recvfrom(serv_sock, message, BUF_SIZE, <span class="number">0</span>, </span><br><span class="line">                    (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">        <span class="comment">// sendto</span></span><br><span class="line">        sendto(serv_sock, message, str_len,<span class="number">0</span>,</span><br><span class="line">                    (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, clnt_adr_sz);</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-2-2-客户端"><a href="#2-2-2-客户端" class="headerlink" title="2.2.2 客户端"></a>2.2.2 客户端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">from_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock == <span class="number">-1</span>) </span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="type">socklen_t</span> from_adr_len;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input message Q to quit: &quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">        fgets(message, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// printf(&quot;%d&quot;, strlen(message));</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(message,<span class="string">&quot;q\n&quot;</span>)||!<span class="built_in">strcmp</span>(message,<span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        sendto(sock, message, <span class="keyword">sizeof</span>(message),<span class="number">0</span>,</span><br><span class="line">                    (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line"></span><br><span class="line">        from_adr_len = <span class="keyword">sizeof</span>(from_adr);</span><br><span class="line">        str_len = recvfrom(sock,message, BUF_SIZE, <span class="number">0</span>,</span><br><span class="line">                    (<span class="keyword">struct</span> sockaddr *)&amp;from_adr, &amp;from_adr_len);</span><br><span class="line">        </span><br><span class="line">        message[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-sendto-中的地址分配与注册"><a href="#2-3-sendto-中的地址分配与注册" class="headerlink" title="2.3 sendto()中的地址分配与注册"></a>2.3 sendto()中的地址分配与注册</h2><h3 id="2-3-1-本机套接字地址分配"><a href="#2-3-1-本机套接字地址分配" class="headerlink" title="2.3.1 本机套接字地址分配"></a>2.3.1 本机套接字地址分配</h3><p>可以看到UDP服务器使用了<code>bind</code>分配<strong>本机</strong>的IP和端口（必须指定，否则客户端无法访问），而<code>bind</code>不区分TCP和UDP。而UDP客户端没有。</p>
<p>在UDP，如果在<code>sendto()</code>时，发现没有分配地址信息，则在首次调用<code>sendto</code>时自动给套接字分配本机IP和端口直到程序结束（自动完成，和TCP客户端的<code>connect()</code>一样）。</p>
<h3 id="2-3-2目标套接字地址注册"><a href="#2-3-2目标套接字地址注册" class="headerlink" title="2.3.2目标套接字地址注册"></a>2.3.2目标套接字地址注册</h3><h4 id="未连接套接字（默认）"><a href="#未连接套接字（默认）" class="headerlink" title="未连接套接字（默认）"></a>未连接套接字（默认）</h4><p>UDP套接字socket无需<strong>注册</strong>目标IP和端口号，也就是一个套接字并不和一个目标地址绑定，每次传输是一个新的socket，因为<code>sendto</code>的内部传输过程为三步</p>
<ol>
<li>向UDP套接字注册目标IP和端口号</li>
<li>传输数据</li>
<li>删除UDP套接字中的目标地址信息</li>
</ol>
<p>每次调用<code>sendto</code>都会重复上述过程，因此可以<strong>只用一个套接字向不同目标传输数据</strong>。这种套接字称为<strong>未连接套接字</strong>。</p>
<h4 id="已连接套接字"><a href="#已连接套接字" class="headerlink" title="已连接套接字"></a>已连接套接字</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* server_addr, <span class="type">socklen_t</span> addrlen)</span></span><br></pre></td></tr></table></figure>

<p>但如果只向一个目标发送数据，每次都重复上述的过程显得低效，所以可以使用<code>connect</code>建立<strong>有连接套接字</strong>。</p>
<blockquote>
<p>注意，这里的有连接并不是指UDP是有连接的，只是针对套接字而言是有连接。</p>
</blockquote>
<p>此时可以用<code>write</code>和<code>read</code>代替<code>sendto</code>和<code>recvfrom</code>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/04/20/network_programming/ch5-socket%E5%8F%AF%E9%80%89%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/20/network_programming/ch5-socket%E5%8F%AF%E9%80%89%E9%A1%B9/" class="post-title-link" itemprop="url">ch5-Socket可选项</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-20 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-20T00:00:00+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-17 20:05:33" itemprop="dateModified" datetime="2023-11-17T20:05:33+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-设置和读取套接字可选项"><a href="#1-设置和读取套接字可选项" class="headerlink" title="1 设置和读取套接字可选项"></a>1 设置和读取套接字可选项</h1><p>套接字可以设置出不同的特性，这里给出一部分较为重要的可选项含义与设置方法。</p>
<h2 id="1-1-使用方法"><a href="#1-1-使用方法" class="headerlink" title="1.1 使用方法"></a>1.1 使用方法</h2><h3 id="1-1-1-getsockopt"><a href="#1-1-1-getsockopt" class="headerlink" title="1.1.1 getsockopt"></a>1.1.1 getsockopt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：读取套接字可选项</li>
<li>参数<ul>
<li>sock: 套接字</li>
<li>level：查看可选项的协议层</li>
<li>optname：查看可选项的名称</li>
<li>optval：保存读取结果的缓冲地址</li>
<li>optlen：缓冲区大小，调用后保存可选信息的字节数</li>
</ul>
</li>
<li>返回值：成功0，失败-1</li>
</ul>
<h3 id="1-1-2-setsockopt"><a href="#1-1-2-setsockopt" class="headerlink" title="1.1.2 setsockopt"></a>1.1.2 setsockopt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：设置套接字可选项</li>
<li>参数<ul>
<li>sock: 套接字</li>
<li>level：要更改的可选项的协议层</li>
<li>optname：要更改的可选项的名称</li>
<li>optval：保存要更改信息的缓冲区地址</li>
<li>optlen：缓冲区大小</li>
</ul>
</li>
<li>返回值：成功0，失败-1</li>
</ul>
<h2 id="1-2-例程：查看TCP和UDP的套接字类型"><a href="#1-2-例程：查看TCP和UDP的套接字类型" class="headerlink" title="1.2 例程：查看TCP和UDP的套接字类型"></a>1.2 例程：查看TCP和UDP的套接字类型</h2><p>level： <code>SOL_SOCKET</code></p>
<p>optname： <code>SO_TYPE</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tcp_sock, udp_sock;</span><br><span class="line">    <span class="comment">// 存放getsockopt()返回结果</span></span><br><span class="line">    <span class="type">int</span> sock_type;</span><br><span class="line">    <span class="type">socklen_t</span> optlen;</span><br><span class="line">    optlen = <span class="keyword">sizeof</span>(sock_type);</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    tcp_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    udp_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建时指定的套接字类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SOCK_STREAM: %d \n&quot;</span>, SOCK_STREAM);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SOCK_DGRAM: %d \n&quot;</span>, SOCK_DGRAM);</span><br><span class="line">    <span class="comment">// 查看tcp的套接字类型</span></span><br><span class="line">    state = getsockopt(tcp_sock, SOL_SOCKET, SO_TYPE, (<span class="type">void</span>*)&amp;sock_type, &amp;optlen);</span><br><span class="line">    <span class="keyword">if</span>(state) <span class="comment">// getsockopt成功0，失败-1</span></span><br><span class="line">        error_handling(<span class="string">&quot;getsockopt() error&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket type one: %d\n&quot;</span>, sock_type);</span><br><span class="line">    <span class="comment">// 查看udp套接字类型</span></span><br><span class="line">    state = getsockopt(udp_sock, SOL_SOCKET, SO_TYPE, (<span class="type">void</span>*)&amp;sock_type, &amp;optlen);</span><br><span class="line">    <span class="keyword">if</span>(state) <span class="comment">// getsockopt成功0，失败-1</span></span><br><span class="line">        error_handling(<span class="string">&quot;getsockopt() error&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket type two: %d\n&quot;</span>, sock_type);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1-3-例程：设置和读取输入输出缓冲区"><a href="#1-3-例程：设置和读取输入输出缓冲区" class="headerlink" title="1.3 例程：设置和读取输入输出缓冲区"></a>1.3 例程：设置和读取输入输出缓冲区</h2><p>level： <code>SOL_SOCKET</code></p>
<p>optname：<code>SO_SNDBUF</code> &amp; <code>SO_RCVBUF</code></p>
<h3 id="1-3-1-代码"><a href="#1-3-1-代码" class="headerlink" title="1.3.1 代码"></a>1.3.1 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> snd_buf, recv_buf;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="type">int</span> tcp_sock, udp_sock;</span><br><span class="line">    tcp_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    udp_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看tcp套接字的IO缓冲区大小</span></span><br><span class="line">    state = getsockopt(tcp_sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;snd_buf, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TCP send/Output buffer size: %d\n&quot;</span>, snd_buf);</span><br><span class="line">    state = getsockopt(tcp_sock, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;recv_buf, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TCP receive/Input buffer size: %d\n&quot;</span>, recv_buf);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 查看udp套接字的IO缓冲区大小</span></span><br><span class="line">    state = getsockopt(udp_sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;snd_buf, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP send/Output buffer size: %d\n&quot;</span>, snd_buf);</span><br><span class="line">    state = getsockopt(udp_sock, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;recv_buf, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP receive/Input buffer size: %d\n&quot;</span>, recv_buf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置tcp套接字的IO缓冲区大小</span></span><br><span class="line">    <span class="type">int</span> set_recv_buf = <span class="number">1024</span>*<span class="number">3</span>, set_snd_buf = <span class="number">1024</span>*<span class="number">4</span>;</span><br><span class="line">    state = setsockopt(tcp_sock, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;set_recv_buf, <span class="keyword">sizeof</span>(set_recv_buf));</span><br><span class="line">    state = setsockopt(tcp_sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;set_snd_buf, <span class="keyword">sizeof</span>(set_snd_buf));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看设置后tcp套接字的IO缓冲区大小</span></span><br><span class="line">    state = getsockopt(tcp_sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;snd_buf, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After setsockopt: TCP send/Output buffer size: %d\n&quot;</span>, snd_buf);</span><br><span class="line">    state = getsockopt(tcp_sock, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;recv_buf, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After setsockopt: TCP receive/Input buffer size: %d\n&quot;</span>, recv_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-结果"><a href="#1-3-2-结果" class="headerlink" title="1.3.2 结果"></a>1.3.2 结果</h3><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415222338145.png" alt="image-20230415222338145"></p>
<p>8192和6144并不是我们代码中4*1024和3*1024的大小设置，因为不会完全按照我们的要求设置，防止缓冲区被错误设置。</p>
<blockquote>
<p> 任何UDP套接字都有发送缓冲区大小，但<strong>实际上不存在UDP发送缓冲区</strong>，其大小仅仅是可写到套接字的UDP数据报的大小上限。如果一个应用进程写一个大于套接字发送缓冲区大小的数据报，内核将返回该进程一个EMSGSIZE错误。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/legend050709/article/details/128437143">(19条消息) udp缓冲区_legend050709ComeON的博客-CSDN博客</a></p>
</blockquote>
<h2 id="1-4-地址再分配：SO-REUSEADDR"><a href="#1-4-地址再分配：SO-REUSEADDR" class="headerlink" title="1.4 地址再分配：SO_REUSEADDR"></a>1.4 地址再分配：SO_REUSEADDR</h2><h3 id="1-4-1-time-wait"><a href="#1-4-1-time-wait" class="headerlink" title="1.4.1 time-wait"></a>1.4.1 time-wait</h3><p>先前的只能接入一个用户的回声服务器中，服务器可以有两种中止方式：</p>
<ul>
<li>若客户端输入q后，客户端主动发送<strong>FIN</strong>断开服务器，服务器终止。这种情况下，立刻重启服务器，继续绑定上一个端口，服务器能够继续运行。</li>
<li>按ctrl+z强制关闭也会向服务器传递<strong>FIN</strong>。但如果马上在同一端口运行服务器，会出现bind() error消息。这是因为：实际上，主动断开的套接字会经过time-wait过程，而<strong>time-wait</strong>状态会占用端口号。（但无需考虑客户端的，因为客户端套接字端口号是任意指定）</li>
</ul>
<p>为什么要有time-wait状态：</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415224608984.png" alt="image-20230415224608984"></p>
<p>因为如果主机A向B传输ACK消息（<strong>上图红框</strong>）后立即消除套接字，但这条消息丢失了，B会认为自己的FIN消息没达到主机A，试图重传，而主机A已经关闭，B永远无法得到A传来的ACK消息。因此基于，先发送FIN的主机，要经过time-wait状态。</p>
<p>time-wait看似重要，但也会出问题：<br>1、若服务器紧急停止，若需要尽快重启提供服务，需要等待<br>2、Time-wait延长：</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415224946329.png" alt="image-20230415224946329"></p>
<p>解决方式就是设置套接字可选项的SO_REUSEADDR为true：</p>
<h3 id="1-3-1-SO-REUSEADDR-地址再分配"><a href="#1-3-1-SO-REUSEADDR-地址再分配" class="headerlink" title="1.3.1 SO_REUSEADDR 地址再分配"></a>1.3.1 SO_REUSEADDR 地址再分配</h3><p>level： <code>SOL_SOCKET</code></p>
<p>optname：<code>SO_REUSEADDR </code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> option = TRUE;</span><br><span class="line">optlen = <span class="keyword">sizeof</span>(option);</span><br><span class="line">setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, (<span class="type">void</span>*)&amp;option, optlen);</span><br></pre></td></tr></table></figure>

<p>SO_REUSEADDR&#x3D;true时，允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的IP地址即可。也就是说本机服务器如果有多个地址，可以在不同地址上使用相同的端口提供服务。</p>
<p>下图为21端口的socketA在time-wait时，设置SO_REUSEADDR，然后绑定21端口给socketB的所有情况。0.0.0.0表示本机所有地址</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415225250543.png" alt="image-20230415225250543"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14388706/how-do-so-reuseaddr-and-so-reuseport-differ/14388707#14388707">linux - How do SO_REUSEADDR and SO_REUSEPORT differ? - Stack Overflow</a></p>
</blockquote>
<h2 id="1-5-启用Nagle算法：TCP-NODELAY"><a href="#1-5-启用Nagle算法：TCP-NODELAY" class="headerlink" title="1.5 启用Nagle算法：TCP_NODELAY"></a>1.5 启用Nagle算法：TCP_NODELAY</h2><p>level： <code>IPPROTO_TCP</code></p>
<p>optname：<code>TCP_NODELAY</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置禁用/启用Nagle算法，因为默认是启用的，所以opt_val = 0表示启用，1表示禁用。</span></span><br><span class="line">state = setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (<span class="type">void</span> *)&amp;opt_val, <span class="keyword">sizeof</span>(opt_val))</span><br></pre></td></tr></table></figure>

<p>Nagle算法：防止数据包过多导致网络过载，<strong>收到前一个包的ACK，才发送下一个数据。</strong></p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415225429654.png" alt="image-20230415225429654"></p>
<ul>
<li>实际上是控制发送方发送使得缓冲区存到一定程度再发生。若发送方产生数据太慢，这种方式可以让发送方的数据进入缓冲区一部分再发送，不至于一字节一字节发送而数据包泛滥（数据包头）。当然这是一种极端情况。</li>
<li>在发送大文件时，缓冲区也会很快被填满然后发送，不会无端增加数据包数量，不使用Nagle算法会更快。</li>
<li><strong>TCP套接字默认使用Nagle算法</strong>，未判断数据特性时，不应禁用Nagle算法。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2023/04/20/network_programming/ch6-%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/20/network_programming/ch6-%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/" class="post-title-link" itemprop="url">ch6-并发服务器实现——多进程服务器端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-20 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-20T00:00:00+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-17 20:06:22" itemprop="dateModified" datetime="2023-11-17T20:06:22+08:00">2023-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>几种并发服务器端的实现方式</p>
<ul>
<li><strong>多进程服务器：通过创建多个进程提供服务（本章内容）</strong></li>
<li>多路复用服务器：通过捆绑并统一管理I&#x2F;O对象提供服务</li>
<li>多线程服务器：通过生成与客户端等量的线程提供服务</li>
</ul>
<h1 id="一、多进程前置知识"><a href="#一、多进程前置知识" class="headerlink" title="一、多进程前置知识"></a>一、多进程前置知识</h1><h2 id="1-进程与fork"><a href="#1-进程与fork" class="headerlink" title="1 进程与fork"></a>1 进程与fork</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 成功返回进程ID，失败返回-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> gval = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> lval = <span class="number">20</span>;</span><br><span class="line">    gval++, lval+=<span class="number">5</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        gval+=<span class="number">2</span>, lval+=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        gval-=<span class="number">2</span>, lval-=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child: [gval,lval]=[%d,%d] \n&quot;</span>,gval,lval);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent: [gval,lval]=[%d,%d] \n&quot;</span>,gval,lval);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230415231151489.png" alt="image-20230415231151489"></p>
<p>fork后，父进程复制出子进程，父子进程只是共享同一代码，各自拥有完全独立的内存结构。</p>
<h2 id="2-进程和僵尸进程"><a href="#2-进程和僵尸进程" class="headerlink" title="2 进程和僵尸进程"></a>2 进程和僵尸进程</h2><h3 id="2-1-产生僵尸进程的原因"><a href="#2-1-产生僵尸进程的原因" class="headerlink" title="2.1 产生僵尸进程的原因"></a>2.1 产生僵尸进程的原因</h3><blockquote>
<p><strong>子进程终止时，其返回值会返回给OS，该子进程会作为僵尸进程存在，直到返回值被父进程接收为止。</strong></p>
</blockquote>
<p>子进程可以有两种返回方式：<strong>传递参数调用exit()<strong>或</strong>main中执行return并返回值</strong>。</p>
<p>这些值和参数会传递给OS，但OS不会终止子进程，直到这些值被传到这些子进程的父进程。换言之，若父进程未主动要求获得子进程的结束状态，子进程将长期处在僵尸状态。</p>
<h4 id="例程zombie-c"><a href="#例程zombie-c" class="headerlink" title="例程zombie.c"></a>例程zombie.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is child process\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is parent process, chile PID %d\n&quot;</span>,pid);</span><br><span class="line">        sleep(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行后会显示子进程pid，通过<code>ps au | grep pid</code>或<code>ps au</code>可以观察到子进程的僵尸状态。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230416143951444.png" alt="image-20230416143951444"></p>
<h3 id="2-2-销毁僵尸进程"><a href="#2-2-销毁僵尸进程" class="headerlink" title="2.2 销毁僵尸进程"></a>2.2 销毁僵尸进程</h3><h4 id="2-2-1-方式1-wait函数"><a href="#2-2-1-方式1-wait函数" class="headerlink" title="2.2.1 方式1 wait函数"></a>2.2.1 方式1 wait函数</h4><p>注意，调用wait函数时，如果没有已终止的进程，程序会阻塞，直到有，谨慎使用！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statloc)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数：</p>
<ul>
<li><p>statloc：存放状态的地址，要用宏分离信息</p>
<ul>
<li><p><code>WIFEXITED</code>  子进程是否正常终止</p>
</li>
<li><p><code>WEXITSTATUS</code>子进程终止返回值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WIFEXITED(statloc);  </span><br><span class="line"><span class="comment">// 子进程正常终止返回真</span></span><br><span class="line">WEXITSTATUS(statloc);</span><br><span class="line"><span class="comment">// 返回子进程返回值（exit或return的）</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：成功返回子进程pid，失败返回-1</p>
</li>
</ul>
<h5 id="例程wait-c"><a href="#例程wait-c" class="headerlink" title="例程wait.c"></a>例程wait.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;this is child process 1&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;child process 1 end&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>); <span class="comment">// 子进程调用exit返回值3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is parent process, chile 1 PID %d\n&quot;</span>,pid);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;this is child process 2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;this is parent process, chile 2 PID %d\n&quot;</span>,pid);</span><br><span class="line">            <span class="type">pid_t</span> returnpid;</span><br><span class="line">            <span class="type">int</span> state;</span><br><span class="line">            returnpid = wait(&amp;state);</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(state))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;the PID %d return value: %d\n&quot;</span>,returnpid ,WEXITSTATUS(state));</span><br><span class="line">            returnpid = wait(&amp;state);</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(state))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;the PID %d return value: %d\n&quot;</span>,returnpid ,WEXITSTATUS(state));  </span><br><span class="line">            sleep(<span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;child process 2 end&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;parent process end&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 子进程2的在main中return返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230416144735514.png" alt="image-20230416144735514"></p>
<h4 id="2-2-2-方式2-waitpid函数"><a href="#2-2-2-方式2-waitpid函数" class="headerlink" title="2.2.2 方式2 waitpid函数"></a>2.2.2 方式2 waitpid函数</h4><p>wait()导致进程阻塞，waitpid()不会阻塞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pit_t</span> pid, <span class="type">int</span>* statloc, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数<ul>
<li>pid：等待终止的目标子进程pid，若为-1，则是任意子进程pid。</li>
<li>statloc：存放状态的地址，要用用宏<code>WIFEXITED(statloc);</code>  和<code>WEXITSTATUS(statloc);</code>分离信息，得知进程是否正常终止以及进程终止返回值</li>
<li>options：传递头文件sys&#x2F;wait.h的<code>WNOHANG</code>，即使没有终止子进程也不会阻塞，而是返回0退出函数。</li>
<li>返回值：成功返回终止的子进程pid，失败-1。options传递<code>WNOHANG</code>时，若没有子进程终止，则返回0。</li>
</ul>
</li>
</ul>
<h5 id="例程waitpid-c"><a href="#例程waitpid-c" class="headerlink" title="例程waitpid.c"></a>例程waitpid.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">15</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!waitpid(<span class="number">-1</span>, &amp;status, WNOHANG))</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;sleep 3sec.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child exit with %d \n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每3秒调用一次<code>waitpid</code>查看有没有子进程终止，而子进程运行15s后终止，所以循环了5次<code>waitpid</code>。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230416151109123.png" alt="image-20230416151109123"></p>
<h2 id="3-信号处理"><a href="#3-信号处理" class="headerlink" title="3 信号处理"></a>3 信号处理</h2><p>子进程终止的识别者是操作系统，父进程往往非常繁忙，不能经常调用waitpid等待子进程终止，所以操作系统可以通过<strong>信号</strong>告知父进程，父进程再调用waitpid。</p>
<h3 id="3-1-信号与signal函数"><a href="#3-1-信号与signal函数" class="headerlink" title="3.1 信号与signal函数"></a>3.1 信号与signal函数</h3><h4 id="3-1-1-signal"><a href="#3-1-1-signal" class="headerlink" title="3.1.1 signal"></a>3.1.1 signal</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signo, <span class="type">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>函数名：signal</li>
<li>功能：<strong>信号注册</strong>。即遇到特殊情况signo时（操作系统告知），调用func函数处理，<strong>该signo会被作为参数传入func中</strong>。</li>
<li>参数：<ul>
<li>signo：特殊情况信息<ul>
<li>SIGALRM：已经通过调用<code>alarm</code>函数注册的时间</li>
<li>SIGINT：输入CTRL+C</li>
<li>SIGCHLD：子进程终止</li>
</ul>
</li>
<li>void(* func)(int)：参数为int，返回值为void的函数指针</li>
</ul>
</li>
<li>返回值：参数为int，返回值为void的函数指针。</li>
</ul>
<p>使用方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子进程结束，调用mychild函数</span></span><br><span class="line">signal(SIGCHLD, mychild);</span><br><span class="line"><span class="comment">// 已到alarm函数注册的时间，调用timeout函数</span></span><br><span class="line">signal(SIGALRM, timeout);</span><br><span class="line"><span class="comment">// 输入了CTRL+C，调用keyctrl函数</span></span><br><span class="line">signal(SIGINT, keyctrl);</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-alarm"><a href="#3-1-2-alarm" class="headerlink" title="3.1.2 alarm"></a>3.1.2 alarm</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">unsgigned <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span><br></pre></td></tr></table></figure>
<p>根据参数seconds，相应时间后将产生SIGALRM信号。如果seconds为0，则之前对SIGALRM信号的预约取消。</p>
<blockquote>
<p>若未指定信号处理函数，则（通过调用signal函数）终止进程，无任何处理。</p>
</blockquote>
<h4 id="3-1-3-例程-signal-c"><a href="#3-1-3-例程-signal-c" class="headerlink" title="3.1.3 例程 signal.c"></a>3.1.3 例程 signal.c</h4><ul>
<li>例程<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timeout</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sig == SIGALRM)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;time out!&quot;</span>);</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">keyctrl</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sig == SIGINT)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;ctrl pressed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    signal(SIGALRM,timeout);</span><br><span class="line">    signal(SIGINT,keyctrl);</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wait......&quot;</span>);</span><br><span class="line">        sleep(<span class="number">100</span>); <span class="comment">// 100 sec.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
代码中main里循环了3次，每次100s，但实际上程序的执行大约6秒。</li>
</ul>
<p>这是因为alarm(2)只预约了2秒，2秒到达后信号到达，进入timeout()处理函数。而进程处于睡眠时，是无法调用处理函数的，所以当信号来到，进程会被立马唤醒，不会再进入先前的睡眠状态，程序继续运行（进入下一次睡眠）。若连续ctrl+z，程序会更快结束。</p>
<h3 id="3-2-sigaction函数"><a href="#3-2-sigaction函数" class="headerlink" title="3.2 sigaction函数"></a>3.2 sigaction函数</h3><p>sigaction函数完全可以替代signal，且更稳定。</p>
<blockquote>
<p>signal函数在UNIX系列不同OS可能存在区别，sigaction则完全相同</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signo, <span class="type">const</span> <span class="keyword">struct</span> sigaction *acr, <span class="keyword">struct</span> sigaction* oldact)</span> </span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数</p>
<ul>
<li>signo：传递信号信息</li>
<li>act：根据signo需要调用的<strong>信号处理函数</strong>信息</li>
<li>oldact：获取之前注册的<strong>信号处理函数</strong>信息，不需要则传0</li>
</ul>
</li>
<li><p>成功返回0，失败返回-1</p>
<p>信号处理函数信息都在<code>sigaction</code>结构体中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">    <span class="type">int</span> sa_flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>成员<ul>
<li>sa_handler：信号处理函数指针</li>
<li>sa_mask, sa_flags用于指定信号相关的选项和特性，暂时用不到，置为0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="例程-remove-zombie-c"><a href="#例程-remove-zombie-c" class="headerlink" title="例程 remove_zombie.c"></a>例程 remove_zombie.c</h4><p> 利用信号处理技术消灭僵尸进程（回收子进程），具体流程是，注册子进程结束信号SIGCHLD，子进程结束时调用处理函数read_childproc，该函数内使用waitpid回收子进程。<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 处理终止子进程，读取其pid和返回值信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_childproc</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> id = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);</span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;remove proc id: %d\n&quot;</span>, id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child send: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// struct sigaction赋值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = read_childproc; <span class="comment">// 注册信号处理函数信息</span></span><br><span class="line">    sigemptyset(&amp;act.sa_mask); <span class="comment">// sa_mask置为0</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>; <span class="comment">// sa_flags置为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册信号</span></span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;this is child proc&quot;</span>);</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12</span>; <span class="comment">// 返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child proc id: %d\n&quot;</span>,pid);</span><br><span class="line">        pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;this is child proc&quot;</span>);</span><br><span class="line">            sleep(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">24</span>;  <span class="comment">// 返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child proc id: %d\n&quot;</span>,pid);</span><br><span class="line">            <span class="keyword">for</span>(i =<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">                sleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>父进程等待25秒结束，子进程1和2都sleep10秒结束。过程中，子进程结束时，产生SIGCHLD信号，父进程（若在sleep，会立刻唤醒）调用信号处理函数获取子进程结束返回值。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230416171834676.png" alt="image-20230416171834676"></p>
<h1 id="二、多进程服务器端"><a href="#二、多进程服务器端" class="headerlink" title="二、多进程服务器端"></a>二、多进程服务器端</h1><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230417091705079.png" alt="image-20230417091705079" style="zoom:67%;" />

<p>从上图可以看出任务被分离：父进程负责建立与客户端的连接，子进程负责与客户端通信。若同时有5个客户端接入，服务器端一共会有一个父进程和五个子进程处理。</p>
<h2 id="echo-mpserv-c-代码："><a href="#echo-mpserv-c-代码：" class="headerlink" title="echo_mpserv.c 代码："></a>echo_mpserv.c 代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有子进程退出的信号时的调用函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_childproc</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> id = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG); <span class="comment">// waitpid</span></span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;remove proc id: %d\n&quot;</span>, id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child send: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = read_childproc;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_sock == <span class="number">-1</span>) </span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(listen(serv_sock, <span class="number">5</span>)==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        clnt_sock = accept(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">        <span class="keyword">if</span>(clnt_sock==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;new client connected...\n&quot;</span>);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123; <span class="comment">// fork()失败</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;fork() error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">// 子进程进行数据传递</span></span><br><span class="line">        &#123;</span><br><span class="line">            close(serv_sock); <span class="comment">// 子进程后续不需要接入新客户端(不归该子进程管)，关闭serv_socket</span></span><br><span class="line">            <span class="keyword">while</span>((str_len=read(clnt_sock, message, BUF_SIZE))!=<span class="number">0</span>) </span><br><span class="line">                write(clnt_sock, message, str_len);</span><br><span class="line">            close(clnt_sock); <span class="comment">// 只要ste_len=0，说明客户端发送了EOF断开连接</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;client disconnected...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            close(clnt_sock);  <span class="comment">// 父进程不与客户端通信，关闭clnt_socket</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码上可以看出，</p>
<ul>
<li><p>子进程只负责通信，当客户端断开连接，子进程终止。</p>
</li>
<li><p>父进程只负责客户端连接，每当有一个客户端连接完成，fork一个子进程处理，自己继续下一次的连接。</p>
</li>
</ul>
<h2 id="通过fork函数复制文件描述符"><a href="#通过fork函数复制文件描述符" class="headerlink" title="通过fork函数复制文件描述符"></a>通过fork函数复制文件描述符</h2><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230417092935974.png" alt="image-20230417092935974"></p>
<p>fork后，子进程会拥有父进程的所有资源，包括文件描述符。其实子进程与父进程已经是两个不同的进程了，只是这两个进程都拥有相同的指向同一文件的文件描述符，因此如果不使用某个文件描述符，需要及时关闭。</p>
<p><strong>在多进程服务器中，处理数据传输的子进程关闭了<code>serv_sock</code>，处理客户端连接的父进程关闭了<code>clnt_sock</code>（他们都用不上）。</strong>因为复制的是socket文件描述符，一个socket可以有多个文件描述符，当这些文件描述符都终止时，socket才会被销毁。所以若忘记关闭，socket将会一直被占用。</p>
<h1 id="三、多进程客户端：分离TCP的I-O"><a href="#三、多进程客户端：分离TCP的I-O" class="headerlink" title="三、多进程客户端：分离TCP的I&#x2F;O"></a>三、多进程客户端：分离TCP的I&#x2F;O</h1><p>使用两个进程分割回声客户端的I&#x2F;O，优点：</p>
<ul>
<li><p>程序编写更简单，因为一个进程同时实现IO需要考虑更多细节</p>
</li>
<li><p>提高数据交换的效率。</p>
<p>（这里容易产生混淆，实际上回声客户端没有分离IO的必要）</p>
<ul>
<li>分离IO前，客户端的数据流动方式是，在收到上一条的回声后，下一条数据才发送，期待下一条的回声。这很符合回声的定义。</li>
<li>分离IO后，客户端不用等到上一条的回声，就可以发送下一条的数据，<strong>所以可以提高数据交换的效率</strong>。</li>
</ul>
<p>分离IO更适合场景是：不需要收到一方的数据也可以发送，比如聊天室，客户端A发送信息，服务器收到后，将该信息发给客户端BCD，此时客户端BCD若分离了IO，他不需要等到客户端A的信息，也可以发送信息）</p>
</li>
</ul>
<h2 id="echo-mpclient-c-代码"><a href="#echo-mpclient-c-代码" class="headerlink" title="echo_mpclient.c 代码"></a>echo_mpclient.c 代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_sockaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_sockaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_sockaddr));</span><br><span class="line">    serv_sockaddr.sin_family = AF_INET;</span><br><span class="line">    serv_sockaddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_sockaddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">if</span>(connect(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_sockaddr, <span class="keyword">sizeof</span>(serv_sockaddr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">// 父进程写、子进程读</span></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        write_routine(sock, buf);</span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">        read_routine(sock,buf);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> str_len = read(sock, buf, BUF_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(str_len==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        buf[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 从stdin输入流读取一行</span></span><br><span class="line">        fgets(buf, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(buf,<span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            shutdown(sock, SHUT_WR);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(sock, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h2><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230417092435698.png" alt="image-20230417092435698"></p>
<p>运行了 1个多进程回声服务器<code>echo_mpserv </code>和  2个多进程分离IO回声客户端<code>echo_mpclient</code>，进程的数量为7个。</p>
<h1 id="四、进程间通信"><a href="#四、进程间通信" class="headerlink" title="四、进程间通信"></a>四、进程间通信</h1><p>（与构建服务器端暂无关系，仅做拓展，此部分可以忽略）</p>
<p>若想完成进程间通信，OS应当提供两个进程可以同时访问的内存空间，而进程有完全独立的内存空间，fork中的父子进程也是如此，因此需要以特殊的方式通信。</p>
<blockquote>
<p>这让我想到上一节的echo_mpclient，将IO分离成两个进程，只是这两个进程不需要通信，因为他们处理的数据无关；如果是echo_mpserv分离IO，应该是需要的，因为输入进程读取到的数据，要发送给输出进程。</p>
</blockquote>
<h2 id="4-1-管道PIPE"><a href="#4-1-管道PIPE" class="headerlink" title="4.1 管道PIPE"></a>4.1 管道PIPE</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> filedes[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数：<ul>
<li>filedes[0]：通过管道<strong>接收</strong>数据的文件描述符，管道<strong>出口</strong></li>
<li>filedes[1]：通过管道<strong>发送</strong>数据的文件描述符，管道<strong>入口</strong></li>
</ul>
</li>
<li>成功返回0，失败返回-1。</li>
</ul>
<p>数据进入管道后会成为<strong>无主数据</strong>，也就是谁都可以读取，所以要注意编写进程读写的逻辑，自己写入后确保其他进程读取完毕，自己进程才有读的机会。有另一种解决方式：创建两个管道。</p>
<blockquote>
<p>管道属于IPC技术：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Linuxhus/article/details/125572872">深刻理解 Linux 进程间七大通信（IPC）_linux ipc_Linux服务器开发的博客-CSDN博客</a></p>
</blockquote>
<h3 id="4-1-1-例程-管道的单向通信"><a href="#4-1-1-例程-管道的单向通信" class="headerlink" title="4.1.1 例程 管道的单向通信"></a>4.1.1 例程 管道的单向通信</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;who are you&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    pipe(fds); <span class="comment">// 创建管道</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;this is parent proc.&quot;</span>);</span><br><span class="line">        write(fds[<span class="number">1</span>], str, <span class="keyword">sizeof</span>(str)); <span class="comment">// 父进程往管道入口写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is child proc: %d\n&quot;</span>, pid);</span><br><span class="line">        read(fds[<span class="number">0</span>], buf, BUF_SIZE); <span class="comment">// 子进程往管道出口读</span></span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230417103134796.png" alt="image-20230417103134796"></p>
<h3 id="4-1-2-例程-管道的双向通信"><a href="#4-1-2-例程-管道的双向通信" class="headerlink" title="4.1.2 例程 管道的双向通信"></a>4.1.2 例程 管道的双向通信</h3><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/image-20230417103406184.png" alt="image-20230417103406184"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;who are you&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;I&#x27;m Jimmy Mcnulty &quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    pipe(fds);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;this is parent proc.&quot;</span>);</span><br><span class="line">        write(fds[<span class="number">1</span>], str1, <span class="keyword">sizeof</span>(str1));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        若不sleep，由于管道数据是无主数据，</span></span><br><span class="line"><span class="comment">        如果父进程write后比子进程更快read，</span></span><br><span class="line"><span class="comment">        那么子进程会read不到，进而一直阻塞等待管道</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">        sleep(<span class="number">2</span>); </span><br><span class="line">        read(fds[<span class="number">0</span>], buf, BUF_SIZE);</span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is child proc: %d\n&quot;</span>, pid);</span><br><span class="line">        read(fds[<span class="number">0</span>], buf, BUF_SIZE);</span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">        write(fds[<span class="number">1</span>], str2, <span class="keyword">sizeof</span>(str2));</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-保存消息的回升服务器端"><a href="#4-2-保存消息的回升服务器端" class="headerlink" title="4.2 保存消息的回升服务器端"></a>4.2 保存消息的回升服务器端</h2><p>比之前的回升服务器多了个功能：新建一个子进程将来自（一个或多个）回声客户端的数据保存在echmsg.txt中。需要用到管道，因为接收来自客户端数据是由另一个进程完成的且，只用到了单向的管道。</p>
<ul>
<li><input disabled="" type="checkbox"> 问题是负责写文件的子进程无法关闭管道与文件，暂未处理。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_childproc</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> id = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);</span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;remove proc id: %d\n&quot;</span>, id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child send: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = read_childproc;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_sock == <span class="number">-1</span>) </span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(listen(serv_sock, <span class="number">5</span>)==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pipe(fds);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="comment">// 写入文件的子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fds[<span class="number">1</span>]);</span><br><span class="line">        close(serv_sock);</span><br><span class="line">        FILE *fp = fopen(<span class="string">&quot;echmsg.txt&quot;</span>, <span class="string">&quot;wt&quot;</span>);</span><br><span class="line">        <span class="type">char</span> msgbuf[BUF_SIZE];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">// 往文件写入保存来自客户端的数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            len = read(fds[<span class="number">0</span>], msgbuf, BUF_SIZE);</span><br><span class="line">            fwrite((<span class="type">void</span>*)msgbuf, <span class="number">1</span>, len, fp);</span><br><span class="line">            fflush(fp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有bug，因为下面的语句无法运行</span></span><br><span class="line">        close(fds[<span class="number">0</span>]);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        clnt_sock = accept(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">        <span class="keyword">if</span>(clnt_sock==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;new client connected...\n&quot;</span>);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fds[<span class="number">0</span>]);</span><br><span class="line">            close(serv_sock);</span><br><span class="line">            <span class="keyword">while</span>((str_len=read(clnt_sock, message, BUF_SIZE))!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                write(clnt_sock, message, str_len);</span><br><span class="line">                write(fds[<span class="number">1</span>], message, str_len); <span class="comment">// 只多了这一句</span></span><br><span class="line">            &#125;</span><br><span class="line">            close(clnt_sock);</span><br><span class="line">            close(fds[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;client disconnected...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            close(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="comment">// 最后再关闭管道</span></span><br><span class="line">    close(fds[<span class="number">0</span>]);</span><br><span class="line">    close(fds[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Wallnut</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"drinkwateronly/comments","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
