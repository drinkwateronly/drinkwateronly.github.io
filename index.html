<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"drinkwateronly.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Wallnut">
<meta property="og:url" content="https://drinkwateronly.github.io/index.html">
<meta property="og:site_name" content="Wallnut">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wallnut">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://drinkwateronly.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Wallnut</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Wallnut</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wallnut"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Wallnut</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/drinkwateronly" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;drinkwateronly" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2024/04/e739a5dffcff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/e739a5dffcff/" class="post-title-link" itemprop="url">mysql联表总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-08 14:14:00" itemprop="dateCreated datePublished" datetime="2024-04-08T14:14:00+08:00">2024-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-22 21:15:56" itemprop="dateModified" datetime="2024-04-22T21:15:56+08:00">2024-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="各种联表操作"><a href="#各种联表操作" class="headerlink" title="各种联表操作"></a>各种联表操作</h2><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222114473.png" alt="img" style="zoom:67%;" />

<p>上图中最后两种<code>FULL OUTER JOIN</code>再oracle支持，而在mysql不支持。</p>
<p>假设有两个表，可在<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/replace-employee-id-with-the-unique-identifier/">1378. 使用唯一标识码替换员工ID</a>试题中尝试使用</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222114050.png" alt="image-20240406224312730"></p>
<h3 id="1、LETF-OUTER-JOIN-RIGHT-OUTER-JOIN"><a href="#1、LETF-OUTER-JOIN-RIGHT-OUTER-JOIN" class="headerlink" title="1、LETF OUTER JOIN &#x2F; RIGHT OUTER JOIN"></a>1、<code>LETF OUTER JOIN</code> &#x2F; <code>RIGHT OUTER JOIN</code></h3><p>或者直接使用<code>LETF JOIN</code> &#x2F; <code>RIGHT JOIN</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.*, B.* FROM Employees AS A LEFT JOIN EmployeeUNI AS B ON A.id = B.id ORDER BY A.id;</span><br><span class="line">SELECT A.*, B.* FROM EmployeeUNI AS B RIGHT JOIN Employees AS A ON A.id = B.id ORDER BY A.id;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222114417.png" alt="image-20240406225315361" style="zoom:67%;" />

<p>这两种都是获取A表所有数据，B表关联数据，没有关联上的A表记录则以NULL填充</p>
<p>记忆方式：LEFT时表示左边的表为主表，右边为关联表；RIGHT时表示右边为主表，左表为关联表。</p>
<h3 id="2、INNER-JOIN-内联"><a href="#2、INNER-JOIN-内联" class="headerlink" title="2、INNER JOIN 内联"></a>2、INNER JOIN 内联</h3><p>或者直接使用<code>JOIN</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.*, B.* FROM Employees AS A INNER JOIN EmployeeUNI AS B ON A.id = B.id ORDER BY A.id;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222114024.png" alt="image-20240406233542247"></p>
<p>内联时，获取A表的数据，B表关联数据，没有关联上的A表记录则忽略。也可以说是，获取B表的数据，A表关联数据，没有关联上的B表记录则忽略。『内联没有左右的说法』。</p>
<h3 id="3、带WHERE过滤的LEFT-JOIN-RIGHT-JOIN"><a href="#3、带WHERE过滤的LEFT-JOIN-RIGHT-JOIN" class="headerlink" title="3、带WHERE过滤的LEFT JOIN/RIGHT JOIN"></a>3、带<code>WHERE</code>过滤的<code>LEFT JOIN/RIGHT JOIN</code></h3><p>第四、五种为联表后进行WHERE条件过滤，较好理解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.*, B.* FROM Employees AS A LEFT JOIN EmployeeUNI AS B ON A.id = B.id WHERE B.id IS NULL ORDER BY A.id ;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222115667.png" alt="image-20240407001012588"></p>
<p>可见获取了A表对B表的差集，即<code>A LEFT JOIN B</code>时没有被B表关联到的A表数据。因此，从集合的角度来看，可以认为<code>LEFT JOIN</code> &#x3D; <code>INNER JOIN</code> +  <code>LEFT JOIN WHERE</code>。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/customer-who-visited-but-did-not-make-any-transactions/description/?envType=study-plan-v2&envId=sql-free-50">1581. 进店却未进行过交易的顾客 - 力扣（LeetCode）</a></p>
<h3 id="笛卡尔积？"><a href="#笛卡尔积？" class="headerlink" title="笛卡尔积？"></a>笛卡尔积？</h3><p>当JOIN两个表不使用ON联接条件时，表的记录数量为两个表记录数的笛卡尔积len(A) * len(B)。</p>
<p>即每条A表记录都会与B表的所有记录关联一次（也可以反过来说）。</p>
<p>此外，重复的数据进行JOIN后也会重复，需要用<code>DISTINCT</code>去重。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43024834/article/details/132613091">https://blog.csdn.net/weixin_43024834/article/details/132613091</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2024/04/143c09e76597/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/143c09e76597/" class="post-title-link" itemprop="url">MySQL底层原理：chapter6内存篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-02 00:00:00" itemprop="dateCreated datePublished" datetime="2024-04-02T00:00:00+08:00">2024-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-22 21:13:29" itemprop="dateModified" datetime="2024-04-22T21:13:29+08:00">2024-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">底层原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mysql日志"><a href="#Mysql日志" class="headerlink" title="Mysql日志"></a>Mysql日志</h1><p>执行一条<code>update</code>语句，执行流程如何？</p>
<ol>
<li>TCP连接</li>
<li>server层词法分析，语法分析</li>
<li>判断表和字段是否存在</li>
<li>优化器确定执行计划</li>
<li>执行语句</li>
</ol>
<p>该过程还会涉及</p>
<ul>
<li>undo log 回滚日志：InnoDB存储引擎生成，记录的是事务『开始前』的数据状态，实现事务的『原子性』，用于回滚和MVCC。</li>
<li>redo log 重做日志：InnoDB存储引擎生成，记录的是事务『完成后』的数据状态，实现事务的『持久性』，用于掉电和故障恢复。</li>
<li>binlog 归档日志：Server层生成的日志，用于数据恢复和主从复制。</li>
</ul>
<h2 id="回滚日志-undo-log"><a href="#回滚日志-undo-log" class="headerlink" title="回滚日志 undo log"></a>回滚日志 undo log</h2><p>undo log有两大作用：事务回滚和实现MVCC.</p>
<h3 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚"></a>事务回滚</h3><p>在InnoDB引擎对记录的『增删改』操作信息记录到undo log里，在发生回滚时，按照日志进行相反操作就能恢复。</p>
<p>例如，回滚一条删除的记录，只需要插入被删除记录即可；回滚一条被更新的记录，只需要将其旧值更新回去即可。可见『增删改』的undo log格式是不同的。</p>
<h3 id="实现MVCC"><a href="#实现MVCC" class="headerlink" title="实现MVCC"></a>实现MVCC</h3><p>此外，undo log的另一个作用是结合 Read View 实现MVCC，即『读提交』和『可重复读』隔离级别，它们的实现是分别在不同的时机创建Read View，并根据Read View顺着版本链找到可见性记录。</p>
<p>一条记录有两个隐藏列：</p>
<ul>
<li>『trx_id』表明该记录由哪个事务修改或创建。</li>
<li>『roll_pointer』指向undo log版本链。</li>
</ul>
<blockquote>
<p>undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。</p>
<p>buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。</p>
</blockquote>
<h3 id="undo-log-刷盘时机"><a href="#undo-log-刷盘时机" class="headerlink" title="undo log 刷盘时机"></a>undo log 刷盘时机</h3><h2 id="重做日志-redo-log"><a href="#重做日志-redo-log" class="headerlink" title="重做日志 redo log"></a>重做日志 redo log</h2><p>由于Buffer Pool提高了读写效率，但其存放到内存的脏页可能在刷盘前就因为断电或故障而丢失。</p>
<p>因此需要进行WAL （Write-Ahead Logging），先将对某页的进行的操作记录为日志（日志在磁盘），此次更新就算完成，后台线程在适当时机刷盘即可。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/iimage/wal.png" alt="img"></p>
<p>注意，redo log仅仅将『做了什么修改』这一信息持久化到磁盘，使用的是『追加操作』，在磁盘中是『顺序写』，比数据页的『随机写』更高效。</p>
<p>个人认为可以理解为相当于对sql语句进行了持久化，因此不需要等脏页持久化到硬盘，即便脏页因崩溃丢失，也可以通过redo log重新执行一次。</p>
<h3 id="redo-log-buffer"><a href="#redo-log-buffer" class="headerlink" title="redo log buffer"></a>redo log buffer</h3><p>redo log也不是直接写入磁盘的，因为会造成大量的磁盘IO，因此有自己的缓存redo log buffer，默认大小16MB。</p>
<h3 id="redo-log刷盘时机："><a href="#redo-log刷盘时机：" class="headerlink" title="redo log刷盘时机："></a>redo log刷盘时机：</h3><ul>
<li><p>Mysql正常关闭</p>
</li>
<li><p>当redo log buffer中记录的写入量大于其内存空间的一半</p>
</li>
<li><p>后台线程每秒刷盘</p>
</li>
<li><p>事务提交时可能刷盘，由<code>innodb_flush_log_at_trx_commit </code>参数控制：</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222112834.png" alt="img"></p>
<ul>
<li><code>innodb_flush_log_at_trx_commit = 0</code>，每次提交事务，redo log留在redo log buffer中，不主动刷盘。<ul>
<li>后台线程每隔一秒调用write()写到操作系统Page Cache，然后调用fsync()持久化到磁盘。</li>
<li>一旦OS宕机或数据库崩溃，最多会丢失1s的数据，但写入性能最高。</li>
</ul>
</li>
<li><code>innodb_flush_log_at_trx_commit = 1</code>，每次提交事务，redo log主动刷盘，数据安全性最高，写性能最差。</li>
<li><code>innodb_flush_log_at_trx_commit = 2</code>，每次提交事务，缓存在『redo log buffer』的『redo log』写到『redo log文件』<ul>
<li>『redo log文件』是操作系统的文件缓存，即Page Cache，因此只要OS不宕机，即便数据库崩溃也不会丢失数据。</li>
<li>后台线程每隔一秒调用fsync()持久化到磁盘。</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h2><p>undo log和redo log都是『InnoDB存储引擎』生成的日志</p>
<p>MySQL 在完成一条更新操作后，『Server 层』还会生成一条 binlog，记录了所有『数据库表结构变更』和『表数据修改』的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p>
<p>事务提交 -&gt; 事务执行过程中产生的所有 binlog 统一写 入 binlog 文件。</p>
<h3 id="binlog和redo-log的区别？"><a href="#binlog和redo-log的区别？" class="headerlink" title="binlog和redo log的区别？"></a>binlog和redo log的区别？</h3><ol>
<li>适用对象不同<ul>
<li>binlog所有存储引擎都能用，</li>
<li>redo log只在Innodb有</li>
</ul>
</li>
<li>文件格式不同<ul>
<li>binlog有STATEMENT（默认格式）、ROW、 MIXED三种格式</li>
<li>redo log记录了在某页做了什么修改</li>
</ul>
</li>
<li>写入方式不同<ul>
<li>binlog是追加写，写满文件会创建新文件继续写，保存全量日志</li>
<li>redo log是循环写，日志空间大小固定</li>
</ul>
</li>
<li>用途不同<ul>
<li>binlog用于<ul>
<li>备份恢复，比如整个数据库删除时，也可以通过binlog恢复</li>
<li>主从复制（）</li>
</ul>
</li>
<li>redo log用于掉电等故障恢复</li>
</ul>
</li>
</ol>
<h3 id="binlog实现主从复制"><a href="#binlog实现主从复制" class="headerlink" title="binlog实现主从复制"></a>binlog实现主从复制</h3><p>『从数据库』就是建立一个和主数据库完全一样的数据库环境。主从复制即将Mysql中binlog数据从『主库』传输到『从库』。完成主从复制后，写数据库时只写主库，读数据库时只读从库，此时写请求若对表或记录加锁时也不影响读请求。</p>
<h4 id="主从复制过程"><a href="#主从复制过程" class="headerlink" title="主从复制过程"></a>主从复制过程</h4><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222112188.png" alt="MySQL 主从复制过程"></p>
<p>主从复制数据写入过程如下：</p>
<ol>
<li>写入binlog：客户端提交事务请求，主库先写binlog，再提交事务，最后更新主库存储引擎数据</li>
<li>同步binlog：从库创建I&#x2F;O线程，连接主库log dump线程，将binlog复制到从库的『中继日志』，然后返回响应。</li>
<li>回放binlog：从库新建SQL线程回放『中继日志』的binlog，更新从库存储引擎中的数据，最终实现主从数据一致性</li>
</ol>
<p>但从库不是越多越好，因为主库会创建更多的log dump线程，消耗资源，且受限于主库网络带宽。</p>
<h4 id="主从复制模式"><a href="#主从复制模式" class="headerlink" title="主从复制模式"></a>主从复制模式</h4><ul>
<li><p>同步复制：『主库提交事务的线程』要等待『所有』从库复制完成的响应，才返回客户端结果。性能差，可用性差，任一从库出问题都影响业务。</p>
</li>
<li><p>异步复制（默认）：『主库提交事务的线程』不等待从库复制完成的响应，直接返回客户端结果。一旦主库宕机，数据丢失。</p>
</li>
<li><p>半同步复制：『主库提交事务的线程』要等待『部分』从库复制完成的响应。5.7后的复制方式，介于两者之间，即便主机宕机，至少也有一个库有最新数据，不存在宕机风险。</p>
<h3 id="binlog-刷盘时机"><a href="#binlog-刷盘时机" class="headerlink" title="binlog 刷盘时机"></a>binlog 刷盘时机</h3></li>
</ul>
<p>重点有三个：binlog cache、page chache以及刷盘频率设置。</p>
<p>事务执行中，会将日志先写到server层的binlog cache；事务提交时，binlog cache才会写到binlog文件。值得注意的是，一个事务的binlog不能拆开，需要保证事务binlog的原子性写入。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222112477.png" alt="binlog cach"></p>
<p>mysql为每个线程分配一片内存binlog cache。刷盘过程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog cache  --write--&gt;  page cache  --fsync--&gt;  磁盘</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，日志会写到内核文件系统的page cache中，不涉及磁盘I&#x2F;O，速度较快</li>
<li>然后，fsync才将binlog持久化到磁盘中，频繁的fsync会导致较多I&#x2F;O。</li>
</ul>
<p><code>sync_binlog</code>控制刷盘频率</p>
<ul>
<li><code>sync_binlog = 0</code>，每次事务提交只write不fsync，交由OS决定何时持久化。风险大，故障会丢失数据。</li>
<li><code>sync_binlog = 1</code>，每次事务提交只write后立刻fsync。数据安全性高，I&#x2F;O频繁写入性能最差，最多丢失一个事务的binlog。</li>
<li><code>sync_binlog = N (N&gt;1，一般100~1000)</code>，每次事务提交都write，累计N个事务后才fsync。容许少量binlog丢失风险，提高写入性能。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2024/04/b1e0d2d10b11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/b1e0d2d10b11/" class="post-title-link" itemprop="url">MySQL底层原理：chapter7内存篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-02 00:00:00" itemprop="dateCreated datePublished" datetime="2024-04-02T00:00:00+08:00">2024-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-22 21:04:48" itemprop="dateModified" datetime="2024-04-22T21:04:48+08:00">2024-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">底层原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="内存篇——Buffer-Pool"><a href="#内存篇——Buffer-Pool" class="headerlink" title="内存篇——Buffer Pool"></a>内存篇——Buffer Pool</h2><p>Mysql数据存储到磁盘，为了提高查询效率会加个缓存。</p>
<ul>
<li><p>Server层：先前Mysql尝试过在在『Server层』设置缓冲，但缓存内容的是为『查询语句』-『查询结果』的键值对，且因命中率低被弃用。</p>
</li>
<li><p>存储引擎层缓存：而Buffer Pool是InnoDB在『存储引擎层』设计的缓冲池，是Mysql启动时申请的『连续内存空间』，默认大小为<code>128MB</code>。同样的，Buffer Pool的数据以16KB的『页为单位』进行交互，叫做缓存页。</p>
<ul>
<li><p>当读取数据时，如果数据所在页已经在Buffer Pool中，则直接从中读取，否则去硬盘读取。</p>
</li>
<li><p>当修改数据时，首先修改Buffer Pool中数据所在页，并将该页标记为『脏页』，最后由后台线程将脏页写入磁盘。</p>
<blockquote>
<p>因此在Mysql启动的时候，会发现程序虚拟内存很大，而物理内存空间很小。因为一些页还没命中。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>Buffer Pool包括『索引页、数据页、undo页、插入缓存和自适应哈希索引、锁信息』等。</p>
<p>为了管理这些缓存页，每个页都有一个『控制块』，存放信息包括『缓存页的表空间、页号、缓存页地址、链表节点』</p>
<h3 id="如何管理Buffer-Pool"><a href="#如何管理Buffer-Pool" class="headerlink" title="如何管理Buffer Pool"></a>如何管理Buffer Pool</h3><p>为了快速找到『空闲』的缓存页，使用链表结构将『空闲缓存页』的『控制块』作为链表节点，称为『free链表』。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/freelist.drawio.png" alt="img"></p>
<p>free链表头部还有一个头节点，包含该链表的头节点地址、尾节点地址以及节点数量。每当需要从磁盘加载一个页到Buffer Pool时，从free链表取出一个控制块，存入对应缓存页并填写控制块信息，最后将该控制块从free链表移除。</p>
<h3 id="如何管理脏页"><a href="#如何管理脏页" class="headerlink" title="如何管理脏页"></a>如何管理脏页</h3><p>类似空闲页链表的结构，同样有个Flush链表，链表各节点为脏页控制块。每当要将脏页刷到磁盘中时，后台线程从中获取一个控制块，将其对应脏页刷入磁盘，最后将该控制块从flush链表移除。</p>
<h4 id="脏页什么时候刷盘？"><a href="#脏页什么时候刷盘？" class="headerlink" title="脏页什么时候刷盘？"></a>脏页什么时候刷盘？</h4><p>Mysql采用了Write Ahead Log 策略，即先写日志，再写磁盘，redo log让Mysql拥有崩溃恢复能力。</p>
<ul>
<li>redo log满时会触发主动刷盘</li>
<li>Buffer Pool 淘汰的缓存页如果是脏页，也会触发刷盘</li>
<li>Mysql认为空闲时，后台线程定期将适量脏页刷盘</li>
<li>Mysql关闭时，所有脏页刷盘。</li>
</ul>
<p>因此，如果偶尔出现一些稍长的SQL，可能是因为脏页刷盘带来的性能抖动，可以通过调大Buffer Pool和redo log日志。</p>
<h3 id="如何提高缓存命中率？"><a href="#如何提高缓存命中率？" class="headerlink" title="如何提高缓存命中率？"></a>如何提高缓存命中率？</h3><p>缓存空间有限，少访问的页可以根据算法淘汰。</p>
<h4 id="简单LRU链表"><a href="#简单LRU链表" class="headerlink" title="简单LRU链表"></a>简单LRU链表</h4><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/lru.png" alt="img"></p>
<ul>
<li>当访问的页在Buffer Pool时，该页移到链表头部</li>
<li>当访问的页不在Buffer Pool时，从磁盘读取该页，将页移到链表头部，并淘汰末尾页。</li>
</ul>
<p>该算法在Mysql中没有被采用，因为LRU无法避免如下问题：</p>
<ul>
<li><p>预读失败</p>
<p>Mysql预读机制：Mysql在加载数据页的时候，会将其『相邻的页』加载到内存。</p>
<p>在LRU中，这些预读的页会放到LRU链表的头部，在Buffer Pool空间不够时，还会挤掉末尾的页。如果这些预读的页一直不被访问，预读白做了，即出现了预读失败。而可能频繁访问的页却被挤掉了。</p>
</li>
<li><p>Buffer Pool污染</p>
<p>当一个SQL语句扫描了大量数据时，若Buffer Pool空间有限，可能会将所有缓存页替换出去，导致大量热数据被淘汰，称为『Buffer Pool污染』。需要区分『扫描大量数据』和『读出大量数据』，因为一些sql语句可能进行的全表扫描，但可能读出少量结果，例如<code>SELECT * FROM t_test WHERE name like &quot;%123&quot;</code>。</p>
</li>
</ul>
<h4 id="如何改进LRU以避免预读失败和Buffer-Pool污染问题"><a href="#如何改进LRU以避免预读失败和Buffer-Pool污染问题" class="headerlink" title="如何改进LRU以避免预读失败和Buffer Pool污染问题"></a>如何改进LRU以避免预读失败和Buffer Pool污染问题</h4><p><img src="/image-20240407205728771.png" alt="image-20240407205728771"></p>
<p>为了避免『预读失败』，对LRU链表划分为『young区域』和『old区域』，分别在前半段和后半段。</p>
<ul>
<li>预读的页放到old区域头部，预读页被淘汰，不影响young区域。</li>
<li>页真正被访问时才将页插入到young区域头部（再改进后就不是了），当young区域的最后一个被挤出去时，会首先到old区域。</li>
</ul>
<p>此时还不足以避免『Buffer Pool污染』，因为当扫描大量数据时，仍然是会访问大量的页，这些缓存页会插入到young头部。因此接下来要提高进入young区域的门槛，即新增一个『停留在old区域的时间判断』</p>
<ul>
<li>若『本次old区域缓存页的访问时间』与其『第一次访问时间』在『某时间间隔内』，就不会被插入到young区域头部。</li>
<li>若『本次old区域缓存页的访问时间』与其『第一次访问时间』不在『某时间间隔内』，该页被插入到young区域头部。</li>
</ul>
<p>该时间由默认为1s的<code>innodb_old_blocks_time</code>控制，即同时满足『被访问』与『在old区域停留时间超过1s』这两个条件时，才会被插入到young区域。</p>
<p>『此外，young区域前1&#x2F;4被访问不会移动到链表头，只有后3&#x2F;4被访问才会，以避免节点频繁移动。』</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Buffer Pool中有三种页和三种链表：</p>
<ul>
<li>空闲页：该页未被使用，位于『free链表』。</li>
<li>干净页：该页被使用，但内容未被修改，位于『LRU链表』。</li>
<li>脏页：该页被使用且被修改，同时位于『LRU链表』和『Flush链表』。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222102603.png" alt="img"></p>
<p>注意，链表里存放的都是控制块。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222102443.png" alt="image-20240407220453796"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2024/03/ac70036be824/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/ac70036be824/" class="post-title-link" itemprop="url">MySQL底层原理：chapter1基础篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-29T00:00:00+08:00">2024-03-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-01 14:37:37" itemprop="dateModified" datetime="2024-04-01T14:37:37+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">底层原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><p>全文参考：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/mysql/">图解MySQL介绍 | 小林coding (xiaolincoding.com)</a></p>
</blockquote>
<h2 id="mysql执行流程"><a href="#mysql执行流程" class="headerlink" title="mysql执行流程"></a>mysql执行流程</h2><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="mysql查询流程"></p>
<p>两层：Server层+存储引擎层</p>
<ul>
<li>Server层：建立连接、解析sql语句、执行sql语句</li>
<li>存储引擎层：数据的存储和提取。不同存储引擎可共享一个Server层。</li>
</ul>
<p>两层之间以记录为最小单位传输数据。</p>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><ul>
<li>流程：TCP三次握手建立连接 -&gt; 用户密码输入 -&gt; 用户权限获取</li>
<li>查询连接情况：<code>show processlist</code>查看多少个客户端连接了mysql</li>
<li>最大连接数：<code>show variables like &#39;max_connections&#39; </code></li>
<li>最长空闲连接时长：<code>show variables like &#39;wait_timeout&#39;</code>定义了最长的空闲连接时长，超出则断开连接。（28880s&#x3D;8h）</li>
<li>长连接和短链接（和HTTP类似）<ul>
<li>短连接，每个sql语句执行需要TCP3握，执行完毕TCP4挥。</li>
<li>长连接，一个TCP连接可以执行多个sql语句。但会导致内存占用增多。<ul>
<li>解决方式1：服务器定期断开长连接</li>
<li>解决方式2：客户端主动重置长连接。虽然重置了，但不需要再重连和重新验证权限</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="查询sql缓存（废弃）"><a href="#查询sql缓存（废弃）" class="headerlink" title="查询sql缓存（废弃）"></a>查询sql缓存（废弃）</h3><p>先查缓存，以sql语句为key，结果为value。对于更新频繁的表命中率低，因此8.0版本后移除。</p>
<p>该缓存与buffer pool不同。</p>
<h3 id="解析sql"><a href="#解析sql" class="headerlink" title="解析sql"></a>解析sql</h3><p>词法分析 -&gt; 语法分析，构建语法树。此过程不会查看表或字段是否存在。</p>
<h3 id="执行sql"><a href="#执行sql" class="headerlink" title="执行sql"></a>执行sql</h3><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><ul>
<li>确定sql语句中的表&#x2F;字段是否存在</li>
<li>将<code>select *</code>的<code>*</code>扩展为全列</li>
</ul>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>基于查询成本，确认sql的执行计划。例如在多种索引时确定用哪个索引。</p>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>执行器开始与存储引擎交互，</p>
<ul>
<li>主键索引查询：计划中用到了主键索引，优化器决定访问类型为const。先查B+树，有记录时判断记录是否符合条件，符合发给客户端，否则跳过。</li>
<li>全表扫描：计划中没有用到索引，优化器决定访问类型为ALL进行查询。循环所有记录，符合条件发给客户端。</li>
<li>索引下推：能够减少【二级索引】查询时的回表操作。</li>
</ul>
<h3 id="索引下推？"><a href="#索引下推？" class="headerlink" title="索引下推？"></a>索引下推？</h3><p>5.6版本推出的机制，减少『二级索引』在查询时的『回表操作』。通常和联合索引有关？</p>
<p>叫『下推』的原因是，一些应该是Server层处理的事情，可『下推』到存储引擎层处理。</p>
<p>假设对<code>t_user</code>表建立了联合索引<code>(age, reward)</code>，并查询如下语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user  where age &gt; 20 and reward = 100000;</span><br></pre></td></tr></table></figure>

<h4 id="假设没有索引下推"><a href="#假设没有索引下推" class="headerlink" title="假设没有索引下推"></a>假设没有索引下推</h4><ul>
<li>首先，<code>InnoDB</code>根据<code>age</code>索引找到第一条<code>age&gt;20</code>的二级索引记录</li>
<li>然后，根据二级索引记录的主键值，回表查询该主键对应的记录</li>
<li>最后，该记录被返回到Server层，进一步判断<code>reward</code>是否等于100000</li>
</ul>
<p>如此循环</p>
<h4 id="假设有索引下推"><a href="#假设有索引下推" class="headerlink" title="假设有索引下推"></a>假设有索引下推</h4><p>因为<code>reward</code>和<code>age</code>是联合索引，在二级索引记录中会同时记录有<code>reward</code>和<code>age</code>的值。因此该查询语句可以在存储引擎中『提前过滤』不满足条件的二级索引记录，减少回表次数。</p>
<ul>
<li>首先，<code>InnoDB</code>根据<code>age</code>索引找到第一条<code>age&gt;20</code>的二级索引记录</li>
<li>然后，先判断<code>reward</code>字段条件是否成立，<ul>
<li>如果不成立，则跳过该二级索引记录，找下一条</li>
<li>如果成立，则根据该二级索引记录的主键值，回表查询主键对应记录</li>
</ul>
</li>
<li>最后，该记录被返回到Server层，进一步判断<code>reward</code>是否等于100000</li>
</ul>
<h2 id="mysql数据存储方式"><a href="#mysql数据存储方式" class="headerlink" title="mysql数据存储方式"></a>mysql数据存储方式</h2><p>一张数据库表的数据是保存在名为『表名字.ibd』 的『独占表空间文件』里。</p>
<p>此处主要讲InnoDB的结构，表空间由<strong>『段、区、页、行』</strong>（segment，extent，page，row）组成</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20240401143434916.png" alt="image-20240401143434916"></p>
<h3 id="各结构概览"><a href="#各结构概览" class="headerlink" title="各结构概览"></a>各结构概览</h3><h4 id="行-row"><a href="#行-row" class="headerlink" title="行 row"></a>行 row</h4><p>记录按行存放，不同的存储引擎有不同结构。</p>
<p>详见后续行结构细节</p>
<h4 id="页-page"><a href="#页-page" class="headerlink" title="页 page"></a>页 page</h4><p>问题：每次I&#x2F;O只读取一行，效率很差。</p>
<p>解决：多条记录存为一页，一次的I&#x2F;O以页为单位。即当读取一条记录时，会以页为单位从磁盘读到内存。</p>
<p>页是存储引擎管理的最小单位，为16KB，即最多能保证一页16KB的连续空间</p>
<h4 id="区-extent"><a href="#区-extent" class="headerlink" title="区 extent"></a>区 extent</h4><p>问题：InnoDB 存储引擎用 B+ 树存储数据，每个叶子通过双向链表链接，如果相邻两页距离很远，『对磁盘而言』需要大量的『随机I&#x2F;O』，速度较慢。</p>
<p>解决：多个相邻的页的物理位置也相邻，构成区，因此可以使用『顺序I&#x2F;O』，范围查询时的性能很高。数据大时，为索引分配空间是按照区，而不是按照页为单位分配。</p>
<p>区大小1MB &#x3D; 64 × 页大小16KB</p>
<h4 id="段-segment"><a href="#段-segment" class="headerlink" title="段 segment"></a>段 segment</h4><p>段由多个区组成，表空间则由多个段构成。段分为</p>
<ul>
<li>索引段：存放B+树非叶子节点的区</li>
<li>数据段：存放B+树叶子节点的区</li>
<li>回滚段：存放了回滚数据的区</li>
</ul>
<h3 id="行格式细节"><a href="#行格式细节" class="headerlink" title="行格式细节"></a>行格式细节</h3><p>行格式即存储记录的结构，InnoDB提供了4种格式：</p>
<ul>
<li>Redundant格式用于5.0之前，基本不使用。</li>
<li>Compact格式，紧凑行格式，5.0后。</li>
<li>Dynamic和Compressed，也是紧凑行格式，类似Compact。</li>
</ul>
<p>本节以Compact介绍，可通过Compact拓展到其他紧凑行格式。</p>
<p>具体而言，除了真实数据本身，Compact每一行记录的额外信息有：变长字段长度列表，NULL值列表、记录头信息、真实数据部分的隐藏字段。</p>
<h4 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h4><p>变长字段有：<code>varchar</code>，<code>TEXT</code>，<code>BLOB</code>等。</p>
<p>『变长字段长度列表』根据建表时『变长字段的逆序』存放『变长字段』的数据真正占用的字节数。</p>
<p>注意，『变长字段长度列表』中各元素的长度必须以字节为单位，由于mysql对记录大小的限制，因此每个元素最大为2字节。当表里没有变长字段时，该列表可以不存在。</p>
<h4 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h4><p>某些列可能有NULL值，将NULL值存为真实数据浪费空间。</p>
<p>『NULL值列表』根据建表时『允许NULL字段的逆序』存放表示字段是否为NULL的二进制位：0时为NULL；1时相反。</p>
<p>注意，NULL值列表长度必须以字节为单位，位数不足时『高位补0』。类似的，如果所有字段NOT NULL，则该列表可以不存在。</p>
<h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><p>内容较多，比较重要的是</p>
<ul>
<li><code>delete_mask</code>：软删除的数据标记为1</li>
<li><code>next_record</code>：下一条记录的位置，实际上指的是下一条记录的『记录头信息』和『真实数据』之间的位置。因此往右可以读到记录头信息，往左可以读到真实数据。</li>
<li><code>record_type</code>：0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录。</li>
</ul>
<h4 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h4><p>除了建表时定义的字段，还有一些隐藏字段。这些字段属于数据部分。</p>
<ul>
<li><code>row_id</code>：建表时没有指定主键，且表里没有UNIQUE约束的列时（即表内没有字段可以作为主键），会被作为隐藏主键使用，因此是非必需的。占用6字节。</li>
<li><code>trx_id</code>：指定该记录由哪个事务生成。必需，占用6字节。</li>
<li><code>roll_pointer</code>：指定上一个版本的指针。必需，占用7字节。</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>该例子主要展示InnoDB的COMPATCT行格式中的『变长字段长度列表』，『NULL值列表』如何记录信息。</p>
<p>例如：假设下表的字符集为ascii，其中<code>name</code>和<code>phone</code>为变长字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t_user` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `name` VARCHAR(20) DEFAULT NULL,  # --变长--</span><br><span class="line">  `phone` VARCHAR(20) DEFAULT NULL, # --变长--</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;</span><br></pre></td></tr></table></figure>

<p>并有如下记录</p>
<table>
<thead>
<tr>
<th>id主键</th>
<th>name</th>
<th>phone</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
<td>123</td>
<td>18</td>
</tr>
<tr>
<td>2</td>
<td>bb</td>
<td>1234</td>
<td>NULL</td>
</tr>
<tr>
<td>3</td>
<td>ccc</td>
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody></table>
<p>对于第一条记录</p>
<ul>
<li><code>name=&#39;a&#39;</code>占用字节数为<code>0x01</code>，<code>phone=&#39;123&#39;</code>占用字节数为<code>0x03</code>。因此『变长字段长度列表』内容是<code>[0x03 0x01]</code></li>
<li>所有字段非空，因此『NULL值列表』为<code>0000 0000</code>，即<code>0x00</code></li>
</ul>
<p>对于第二条记录</p>
<ul>
<li><code>name=&#39;bb&#39;</code>占用字节数为0x02，<code>phone=&#39;1234&#39;</code>占用字节数为0x04。因此变长字段长度列表内容是<code>[0x04 0x02]</code></li>
<li>第三个字段为空，因此『NULL值列表』为<code>[0 0 0 0 0 1 0 0]</code>，即<code>0x04</code></li>
</ul>
<p>对于第三条记录</p>
<ul>
<li><code>name=&#39;ccc&#39;</code>占用字节数为0x03，<code>phone=&#39;NULL&#39;</code>不记录其占用字节数。因此变长字段长度列表内容是<code>[0x03]</code></li>
<li>第二、三个字段为空，因此『NULL值列表』为<code>[0 0 0 0 0 1 1 0]</code>，即<code>0x05</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20240401143355298.png" alt="image-20240401143355298"></p>
<h3 id="为什么变长字段长度列表和NULL值列表以字段逆序存放"><a href="#为什么变长字段长度列表和NULL值列表以字段逆序存放" class="headerlink" title="为什么变长字段长度列表和NULL值列表以字段逆序存放"></a>为什么变长字段长度列表和NULL值列表以字段逆序存放</h3><ul>
<li><p>主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</p>
</li>
<li><p>【因为<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。】？？？？</p>
</li>
</ul>
<h3 id="varchar-n-的n最大取值"><a href="#varchar-n-的n最大取值" class="headerlink" title="varchar(n)的n最大取值"></a>varchar(n)的n最大取值</h3><p>mysql规定，除了<code>TEXT</code>和<code>BLOBs</code>大对象类型，其他所有列（不包括『隐藏列』和『记录头信息』，包括『变长字段长度列表』和『NULL值列表』）占用的字节长度不超过65535字节。</p>
<p>即满足式子：</p>
<blockquote>
<p>所有用户定义的字段长度（除了<code>TEXT</code>和<code>BLOBs</code>字段） + 变长字段长度列表所占字节数 + NULL值列表所占字节数 &lt;&#x3D; 65535</p>
</blockquote>
<p>例如下表，只创建一个varchar字段，那么n最大可取多大？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test ( </span><br><span class="line">`name` VARCHAR(n)  NULL</span><br><span class="line">) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;</span><br></pre></td></tr></table></figure>

<ul>
<li>『变长字段长度列表』所占字节数：2字节。因为varchar字段的长度应该是接近65535字节，因此需要2字节记录varchar字段长度。</li>
<li>『NULL值列表』所占字节数：1字节。因为可以只用1bit表示是否为null，且该列表要以字节为单位。</li>
</ul>
<p>因此，根据上式 <code>n + 2 + 1 &lt;= 65535</code>，即n最大取65532。</p>
<h3 id="行溢出处理方式"><a href="#行溢出处理方式" class="headerlink" title="行溢出处理方式"></a>行溢出处理方式</h3><p>一页大小为<code>16KB=16384</code>字节，小于<code>65535</code>字节，因此一些记录会发生『行溢出』。</p>
<ul>
<li>Compact：在记录真实数据的地方保存『该列的部分数据』，并将剩余数据放到『溢出页』，在部分数据后用20字节指针，指向该『溢出页』。</li>
<li>Compressed和Dynamic：不存部分数据，直接将数据放到『溢出页』，只存20字节的指针。</li>
</ul>
<p>一些暂未解决的问题：</p>
<ul>
<li>在Compact中，如果有两列共同导致行溢出，那么这两列分别保存多少部分数据？</li>
<li>溢出页如何存放？是否溢出页会构成一个区？</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2024/03/3fdc349d6971/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/3fdc349d6971/" class="post-title-link" itemprop="url">MySQL底层原理：chapter3 索引篇之2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-29T00:00:00+08:00">2024-03-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-22 21:11:48" itemprop="dateModified" datetime="2024-04-22T21:11:48+08:00">2024-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">底层原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数据页和B-树"><a href="#数据页和B-树" class="headerlink" title="数据页和B+树"></a>数据页和B+树</h1><p>mysql中记录是按行存储的，但从磁盘中的读取一次以页为单位，一页内有多行记录。快速查找到记录需要关注到两点：</p>
<ul>
<li>如何组织页，以快速定位到记录所在的页，避免多次磁盘I&#x2F;O读取页，并支持范围查找。</li>
<li>如何构建页内结构，以在记录所在页中快速定位到记录</li>
</ul>
<p>从自底向上的方式理解，先从数据页结构，再到B+树。</p>
<h2 id="页结构"><a href="#页结构" class="headerlink" title="页结构"></a>页结构</h2><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222109790.png" alt="图片" style="zoom:50%;" />

<ul>
<li>文件头：表示页的信息<ul>
<li>有两个指针，分别指向上一个和下一个数据页，这些页相当于一个双向链表（不需要物理上连续。</li>
</ul>
</li>
<li>页头：记录页的状态</li>
<li>最小和最大记录：虚拟的伪记录，分别表示页中的最小和最大记录</li>
<li>用户记录：存储行数据<ul>
<li>各记录按『主键』顺序组成单向链表</li>
</ul>
</li>
<li>空闲空间：页中未被使用的空间</li>
<li>页目录：存储用户记录的相对位置，可快速索引到记录</li>
<li>文件尾：校验页的完整性</li>
</ul>
<p>页目录如何创建：</p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222109518.png" alt="图片" style="zoom:50%;" />

<ul>
<li>所有记录按主键顺序以链表形式存放，</li>
<li>随后对所有记录分组（如何分？为什么分？），组内的记录也按照主键顺序以链表形式连接。这些记录不包括已删除的。</li>
<li>每个组『最后一条记录』是组内的『最大记录』，且其头信息存放了该组的『总记录数量』。</li>
<li>页目录存放的正是『各组最后一条记录』的『地址偏移量』，该偏移量也称为『槽（slot）』。页目录由多个槽构成，槽相当于各分组的索引&#x2F;指针。</li>
<li>由于各记录按主键顺序存放，因此能通过二分查找，根据槽指向的组内最大记录，快速定位要查询的记录在哪个槽，再通过遍历找到对应记录。</li>
<li>由于最后需要遍历组内记录，记录太多时时间复杂度为<code>O(n)</code>，因此InnoDB规定了各组的记录条数。<ul>
<li>第一个分组只有一条记录</li>
<li>最后一个分组有1~8条</li>
<li>其余分组有4~8条</li>
</ul>
</li>
</ul>
<p>数据页页内结构总结：</p>
<p>在mysql的innodb存储引擎中，一次IO读取一个大小为16KB的页。一个数据页的结构包含几部分内容。首先，文件头包括了连个指针，分别执行当前页的上一个和下一个页，不同的数据页以双向链表的形式存放；随后是页头，记录该页的状态信息；接着是两条虚拟的记录，分别记录着页内最大和最小的两条记录；然后是存储记录的区域，记录按照主键顺序以单向链表的形式存放；</p>
<p>由于记录是按链表存放，检索的效率不高。为了快速索引到页内的某条记录，还使用了页目录。其中，所有记录会被分组，组内的记录同样是以主键递增的顺序链接。每一组的最后一条记录为组内最大记录，并且这个最大记录还存放了当前组的记录数。页目录中就是存放了这些最大记录的指针，因此就能通过二分查找，很快能够定位到记录在哪一组。</p>
<p>此外，页中还有未被使用的空闲空间和用于校验页完整性的文件尾</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>页内可以通过页目录记录不同组的最大记录，再通过二分查找快速定位到『记录在哪个组』。</p>
<p>存储大量数据的时候需要多个数据页，此时要考虑如何建立索引快速定位到『记录在哪个数据页』。mysql的InnoDB采用了B+树作为索引。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222110002.png" alt="图片"></p>
<ul>
<li>每个节点都是一个数据页。</li>
<li>只有叶子节点存放了数据。</li>
<li>非叶子节点仅存放了目录项作为索引，该目录项存放了其孩子页的最小索引键 和 指向该孩子页的指针。</li>
<li>所有节点按『索引键』大小排序，构成双向链表，便于范围查询。</li>
<li>定位索引键为6的页：[1,7)  -&gt; [5,7) -&gt; 页16</li>
</ul>
<p>找到某条记录的过程：</p>
<ol>
<li>在B+树非叶子节点内二分查找，快速定位到B+树叶子节点</li>
<li>在B+树叶子节点内二分查找，快速定位到页内分组</li>
<li>在分组内遍历查找</li>
</ol>
<h2 id="mysql单表不要超过2000w行？"><a href="#mysql单表不要超过2000w行？" class="headerlink" title="mysql单表不要超过2000w行？"></a>mysql单表不要超过2000w行？</h2><p>两个原因：</p>
<p>根据一个16KB的页结构，约有1KB是用于存放File Header (38 byte)、Page Header (56 Byte)、Infimum + Supermum（26 byte）、File Trailer（8byte）以及页目录的固定的信息，剩余的15KB用于存放数据。</p>
<p>单个索引页和数据页能存多少数据：</p>
<ul>
<li>索引页：内部存放的是以索引值+页号（页指针）的行数据。<ul>
<li>假设索引页的一行的索引值用占用8byte的bigint存放，页号占用8byte，即一行索引页记录占用12B。此时索引页内最多存放<code>15×1024/12=1280</code>行数据。</li>
</ul>
</li>
<li>数据页：数据页存放的是真实行数据。<ul>
<li>假设数据页一行记录占用5KB时，数据页内最多存放3行数据。若B+树为3层时，能存储的数据行为<code>(1280^2)*3 ≈ 5百万</code>。</li>
<li>假设数据页一行记录占用1KB时，数据页内最多存放15行数据。因此，B+树为3层时，能存储的数据行为<code>(1280^2)*15 ≈ 2.5千万</code>。在超过时，B+树会到达4层，磁盘IO会增加。</li>
</ul>
</li>
</ul>
<p>此外，mysql还会将表的索引（各种索引页）提前装到内存中，以提高性能。如果表的数据达到某量级，内存存不下其索引，会产生额外的磁盘IO，因此会降低查询性能。</p>
<p>因此2000w行实际只是一个参考。因为影响查询性能的因素还有很多：数据库版本、服务器配置、sql语句等。</p>
<h2 id="索引失效？"><a href="#索引失效？" class="headerlink" title="索引失效？"></a>索引失效？</h2><p>sql语句中可能会索引失效，会引发效率极低的全表扫描。</p>
<h3 id="1-对索引进行左-或-左右模糊匹配"><a href="#1-对索引进行左-或-左右模糊匹配" class="headerlink" title="1 对索引进行左 或 左右模糊匹配"></a>1 对索引进行左 或 左右模糊匹配</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where name like &#x27;%a&#x27; ; # 匹配name字段后缀为&#x27;a&#x27;的，即左模糊匹配</span><br><span class="line">select * from t_user where name like &#x27;%a%&#x27; ; # 匹配name字段中间为&#x27;a&#x27;的，即左右模糊匹配</span><br></pre></td></tr></table></figure>

<p>因为B+树按『索引值』有序排列，『当进行索引值的比较时，只能根据前缀比较』。因为索引比较和字符串比较时的优先比较前缀是类似的。例如<code>abc &gt; ac &gt; ab &gt; a</code>，这些索引值因为前缀相同，因此索引值</p>
<ul>
<li>当使用右模糊匹配时，可以通过索引找到前缀为<code>a</code>的记录</li>
<li>查询中有左模糊匹配时，由于不知道前缀，是无法通过索引找到记录，只能全表扫描。</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/mysql/index/index_issue.html#mysql-%E4%BD%BF%E7%94%A8-like-x-%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%A4%B1%E6%95%88%E5%90%97">MySQL 使用 like “%x“，索引一定会失效吗？</a></p>
<p>个人认为上述情况略微极端，有些像考试题</p>
</blockquote>
<h3 id="2-对索引使用函数"><a href="#2-对索引使用函数" class="headerlink" title="2 对索引使用函数"></a>2 对索引使用函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where length(name)=6;</span><br></pre></td></tr></table></figure>

<p>因为索引保存的是『索引字段的原始值』，而函数计算后的值就无法被索引到。</p>
<h3 id="3-对索引进行表达式计算"><a href="#3-对索引进行表达式计算" class="headerlink" title="3 对索引进行表达式计算"></a>3 对索引进行表达式计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where id + 1 = 10;</span><br></pre></td></tr></table></figure>

<p>类似于上一条。</p>
<h3 id="4-对索引隐式类型转换"><a href="#4-对索引隐式类型转换" class="headerlink" title="4 对索引隐式类型转换"></a>4 对索引隐式类型转换</h3><p>假设表中的<code>phone</code>字段为<code>varchar</code>类型的索引字段，而条件查询时对该字段的where限定使用了整型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where phone = 1300000001;  # 全表扫描</span><br><span class="line">select * from t_user where phone = &#x27;1300000001&#x27;;  # 可用索引</span><br></pre></td></tr></table></figure>

<p>『因为mysql遇到字符串和数字的比较时，自动把字符串转化为数字再比较』，即隐式类型转换，对于上述情况而言，相当于对索引字段使用了<code>CAST</code>函数，因此索引失效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where CAST(phone AS signed int) = 1300000001;</span><br></pre></td></tr></table></figure>



<h3 id="5-联合索引非最左匹配（重点）"><a href="#5-联合索引非最左匹配（重点）" class="headerlink" title="5 联合索引非最左匹配（重点）"></a>5 联合索引非最左匹配（重点）</h3><p>创建多个字段构成『联合索引』时，不同的字段的创建顺序存在差别，例如<code>(a,b,c)</code>和<code>(c,a,b)</code>。这是因为『联合字段』索引时会按照最左优先的方式进行索引的匹配，即『最左匹配原则』。</p>
<p>例如，当创建的<code>(a,b,c)</code>的联合索引</p>
<p>下述条件查询可用到联合索引，因为它们符合最左匹配原则，即按照联合索引中各字段的顺序，以左优先的方式进行匹配。注意，由于查询优化器的存在，AND的顺序并不重要。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHERE a = 1 AND b = 2 AND c = 3</span><br><span class="line">WHERE b = 2 AND a = 1  # AND的顺序不重要</span><br><span class="line">WHERE a = 1</span><br></pre></td></tr></table></figure>

<p>因为下述条件查询中联合索引最左边的字段<code>a</code>不存在，即不符合最左匹配原则，因此联合索引失效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHERE b = 2 AND c = 3</span><br><span class="line">WHERE b = 2</span><br><span class="line">WHERE c = 3</span><br></pre></td></tr></table></figure>

<p>一个特殊的的联合索引为索引截断，因为没有字段<code>b</code>，实际上也能使用到索引<code>a</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE a = 1 AND c = 3</span><br></pre></td></tr></table></figure>

<ul>
<li>5.6版本前，字段a走索引（注意，<code>a</code>是联合索引而非主键索引，即便<code>a</code>本身是主键索引），根据联合索（二级索引）引查询到主键值，然后『回表』到主键索引查询真实记录。</li>
<li>5.6版本后，则有『索引下推』机制，即先判断联合索引中的字段是否满足条件，再决定是否回表或直接返回数据。例如上述将判断字段c是否满足条件，若满足则直接返回数据，减少『回表』次数。</li>
</ul>
<h3 id="6-WHERE子句中的OR"><a href="#6-WHERE子句中的OR" class="headerlink" title="6 WHERE子句中的OR"></a>6 WHERE子句中的OR</h3><p>where中如果<code>OR</code>前是索引列，而<code>OR</code>后不是索引列，则索引失效。因为条件可用满足任意，因此一列的索引没有意义。</p>
<h2 id="不同的count的区别"><a href="#不同的count的区别" class="headerlink" title="不同的count的区别"></a>不同的<code>count</code>的区别</h2><p><code>count()</code>函数用于统计，符合查询条件的记录中，函数入参不为NULL的记录条数。</p>
<ul>
<li><code>count(name)</code>查询表中name字段不为NULL的记录条数。</li>
<li><code>count(name != &#39;a&#39;)</code>查询表中满足表达式，即name字段不为<code>&#39;a&#39;</code>的记录条数。</li>
<li><code>count(1)</code>查询表中1这个表达式不为NULL的记录条数，它永远不为NULL，因此统计表中的记录条数。</li>
</ul>
<h3 id="count-主键字段-执行过程"><a href="#count-主键字段-执行过程" class="headerlink" title="count(主键字段)执行过程"></a><code>count(主键字段)</code>执行过程</h3><ol>
<li><p>server层维护一个变量<code>count</code></p>
</li>
<li><p>server层循环向InnoDB读取一条记录，若满足不为NULL，<code>count++</code></p>
<ul>
<li><p>如果只有主键索引（聚簇索引），InnoDB循环主键索引读取记录返回给server层。</p>
</li>
<li><p>如果有二级索引，InnoDB循环主键索引读取记录返回给server层。</p>
<blockquote>
<p>因为相同数量的二级索引的记录要比聚簇索引记录占用更少空间，即二级索引树要比聚簇索引树更小，因此IO成本更低。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>直到读完符合查询的全部记录，退出循环，返回<code>count</code>给客户端。</p>
</li>
</ol>
<h3 id="count-1-和count-执行过程"><a href="#count-1-和count-执行过程" class="headerlink" title="count(1)和count(*)执行过程"></a><code>count(1)</code>和<code>count(*)</code>执行过程</h3><p>执行过程与<code>count(主键字段)</code>类似，但在『第二步』时『server层』不会读取『任何字段的值』去判断是否为<code>NULL</code>。收到一条记录就<code>count++</code>，因此其速度比<code>count(主键字段)</code>稍快。</p>
<p>而<code>count(*)</code>中的*并不是所有字段的意思，在mysql中会将其优化为<code>count(0)</code>，因此执行过程和查询性能和<code>count(1)</code>『基本一致』。</p>
<h3 id="count-字段-执行过程"><a href="#count-字段-执行过程" class="headerlink" title="count(字段)执行过程"></a><code>count(字段)</code>执行过程</h3><p>全表扫描，性能最差。</p>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>性能排序：<code>count(*)</code>&#x3D;<code>count(1)</code>&gt;<code>count(主键字段)</code>&gt;<code>count(字段)</code>。</p>
<p>count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会优先选择二级索引进行扫描。因此尽量在数据表中建立二级索引以优化<code>count</code>。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>1 为什么InnoDB引擎不能为每个表分配一个存放记录条数的元信息，而需要遍历？</p>
<p>因为InnoDB引擎支持事务，由于MVCC的原因，当事务并发时，事务内返回多少记录条数是不确定的。而MyISAM不支持事务，因此维护了一个<code>row_count </code>变量存放记录条数。</p>
<p>2 如何优化count(*)</p>
<p>数据量大时，全表统计仍很慢，有两种方法</p>
<ul>
<li>近似值。对统计数量不需要很精确时，使用<code>show table status</code>或者<code>explain</code>命令对表数据量估算。它们不会真正去查询数据。</li>
<li>额外表保存计数值。用于对统计数量要求很精确时的情况，但在新增或删除记录时对该表操作。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2024/03/da64fbc5e739/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/da64fbc5e739/" class="post-title-link" itemprop="url">MySQL底层原理：chapter3 索引篇之1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-29T00:00:00+08:00">2024-03-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-22 21:11:46" itemprop="dateModified" datetime="2024-04-22T21:11:46+08:00">2024-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">底层原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li>
<li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li>
<li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li>
<li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li>
</ul>
<h3 id="按数据结构分类"><a href="#按数据结构分类" class="headerlink" title="按数据结构分类"></a>按数据结构分类</h3><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><h3 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h3><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>一张表只有一个『唯一』且『非空』字段可以是主键索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name  (</span><br><span class="line">  PRIMARY KEY (index_column_1) USING BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>仅要求字段为『唯一』，不要求『非空』</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name  (</span><br><span class="line">  UNIQUE KEY(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>既不要求字段『唯一』，又不要求字段为『非空』</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name  (</span><br><span class="line">  INDEX(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>对字符类型的字段（ char、varchar、binary、varbinary ）的前几个字符建立的索引，</p>
<p>目的是为了减少索引占用的存储空间，提高检索效率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name(</span><br><span class="line">    column_list,</span><br><span class="line">    INDEX(column_name(length))</span><br><span class="line">); </span><br></pre></td></tr></table></figure>



<h3 id="字段个数分类"><a href="#字段个数分类" class="headerlink" title="字段个数分类"></a>字段个数分类</h3><h4 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h4><p>单个字段作为索引，如主键索引</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>多个字段组成索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_product_no_name ON product(product_no, name);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.drawio.png" alt="联合索引"></p>
<ul>
<li>先比较product_no字段，product_no相同再比较name字段，</li>
<li>联合索引需要遵循「最左匹配原则」：<ul>
<li><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20240314094352819.png" alt="image-20240314094352819"></li>
<li><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%A1%88%E4%BE%8B.drawio.png" alt="img"></li>
<li>可以看出，a是全局有序，而b是局部有序（a相同时有序），全局无序的</li>
</ul>
</li>
</ul>
<p>InnoDB创建表时：</p>
<ul>
<li>有主键，使用主键作为聚簇索引的索引键</li>
<li>没有主键，选择第一个不含NULL的唯一列作为聚簇索引索引键</li>
<li>若都没有，则生成隐式自增id作为聚簇索引的索引键</li>
</ul>
<p>B+Tree特征：</p>
<ul>
<li>叶子节点才存放数据，非叶子节点只存放索引</li>
<li>所有节点的数据按主键顺序存放（）</li>
<li>父节点的索引值会出现在其子节点中</li>
<li>叶子节点有两个指针，分别指向上一个和下一个叶子节点，构成双向链表。</li>
</ul>
<p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I&#x2F;O，所以<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I&#x2F;O 依然维持在 3-4次。</strong></p>
<p>在主键索引B+Tree中查询数据时，根据查询的主键值以及父节点中主键值的区间向下找到叶子节点，数据就在叶子节点中。</p>
<p>根据二级索引查询数据时，实际上二级索引的B+Tree中的叶子节点只存放了主键值，没有数据。当查到主键值时，则会根据主键值再从主键索引B+Tree中查找数据。这个查询两个表的过程叫<strong>「回表」</strong>。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/%E5%9B%9E%E8%A1%A8.drawio.png" alt="回表"></p>
<p>当查询的数据就是根据二级索引的主键值，那么不需要查询两次，该过程叫<strong>「覆盖索引」</strong>。</p>
<h2 id="为什么选B-Tree"><a href="#为什么选B-Tree" class="headerlink" title="为什么选B+Tree"></a>为什么选B+Tree</h2><h3 id="与B树对比"><a href="#与B树对比" class="headerlink" title="与B树对比"></a>与B树对比</h3><ul>
<li>B树非叶子节点也要存数据，B+Tree单个节点数据量小，相同IO下能查到更多。</li>
<li>B+Tree叶子节点双链表连接，适合范围查询，B树则没有</li>
</ul>
<h3 id="二叉树对比"><a href="#二叉树对比" class="headerlink" title="二叉树对比"></a>二叉树对比</h3><ul>
<li>B+Tree搜索复杂度为<code>O(logdN)</code>，其中N为叶子节点数，d表示节点允许的最大子节点数，通常大于100，保证了即使千万级别，高度仍维持在3~4层。</li>
<li>二叉树搜索复杂度为<code>O(logN)</code>，搜索复杂度太高</li>
</ul>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><ul>
<li>hash只适合做等值查询，不适合范围查询。</li>
</ul>
<p>索引下推</p>
<p>索引区分度</p>
<p><strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2024/03/4f1acf6d0322/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/4f1acf6d0322/" class="post-title-link" itemprop="url">MySQL底层原理：chapter4事务篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-29T00:00:00+08:00">2024-03-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-22 21:07:27" itemprop="dateModified" datetime="2024-04-22T21:07:27+08:00">2024-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">底层原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="要实现事务必须遵守的四个特性？"><a href="#要实现事务必须遵守的四个特性？" class="headerlink" title="要实现事务必须遵守的四个特性？"></a>要实现事务必须遵守的四个特性？</h2><ul>
<li>原子性（<strong>Atomicity</strong>）：一个事务内的操作要么全部完成，要么全部不完成。由undo log保证。</li>
<li>持久性（<strong>Durability</strong>）：事务处理后，对数据的修改是永久的，不因故障而丢失。由redo log保证。</li>
<li>隔离性（<strong>Isolation</strong>）：数据库允许同时多个事务修改读写数据，各事务相互不干扰。由</li>
<li>一致性（<strong>Consistency</strong>）：事务操作前后，数据满足『完整性约束』，数据库保持一致性状态。</li>
</ul>
<h2 id="并行事务的出现的问题？"><a href="#并行事务的出现的问题？" class="headerlink" title="并行事务的出现的问题？"></a>并行事务的出现的问题？</h2><ul>
<li>脏读<strong>（dirty read）</strong>：即读到了其他事务未提交的数据</li>
<li>不可重复度<strong>（non-repeatable read）</strong>：一个事务内对一个事务不修改的数据的多次读取，结果不一样</li>
<li>幻读<strong>（phantom read）</strong>：一个事务多次读取出的数据数量不一样</li>
</ul>
<p>这三种的原因都是因为当前事务在执行时，其他事务对表数据进行修改、增删而被当前事务察觉，</p>
<h2 id="并行事务的隔离级别有哪些？"><a href="#并行事务的隔离级别有哪些？" class="headerlink" title="并行事务的隔离级别有哪些？"></a>并行事务的隔离级别有哪些？</h2><p>根据事务的并行时出现的脏读、不可重复读、幻读现象，SQL标准提出了4种隔离级别规避。隔离水平从高到低（性能从低到高）排序如下：</p>
<ul>
<li><strong>读未提交（read uncommitted）</strong>：事务能够read到其他事务未提交（uncommitted）的数据</li>
<li><strong>读提交（read committed）</strong>：事务提交后，对数据的变更才能被其他事务看到。</li>
<li><strong>可重复读（repeatable read）</strong>：事务执行过程中看到的数据一直保持一致。</li>
<li><strong>串行化（serializable ）</strong>：事务串行进行，由读写锁保证。</li>
</ul>
<p>在不同的隔离级别下，可能发生的现象：</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222105721.png" alt="图片"></p>
<h2 id="四种隔离级别如何实现？"><a href="#四种隔离级别如何实现？" class="headerlink" title="四种隔离级别如何实现？"></a>四种隔离级别如何实现？</h2><ul>
<li>读未提交：无需实现</li>
<li>「读未提交」与「读已提交」：Read View实现，可以理解为数据快照，只是快照的时机不同。下一章细说：<ul>
<li>「读未提交」：每个语句执行前都生成一个Read View</li>
<li>「读已提交」：启动事务时，整个事务用该Read View</li>
</ul>
</li>
<li>串行化：读写锁</li>
</ul>
<p>MVCC和Read View息息相关：</p>
<h3 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h3><p>首先，对于InnoDB存储引擎的数据表，一条记录有如下隐藏列</p>
<ul>
<li><code>trx_id</code>：一个事务对某条『聚簇索引』记录改动时，该列记录该事务的id</li>
<li><code>roll_pointer</code>：每次对某条『聚簇索引』记录改动时，把旧版本写入undo日志，该列为指向旧版本的指针。</li>
</ul>
<p>随后，ReadView有四个重要字段</p>
<ul>
<li><code>create_trx_id</code>：创建该ReadView的事务的id</li>
<li><code>m_ids</code>：创建该ReadView时，当前『活跃且未提交』的事务id列表。</li>
<li><code>min_trx_id</code>：创建该ReadView时，当前『活跃且未提交』的事务中最小的事务id。</li>
<li><code>min_trx_id</code>：创建该ReadView时，当前全局最大的活跃事务id+1，即数据库应该给分配下一个事务的id值。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222105920.png" alt="img"></p>
<p>由此可见，当一个事务访问记录时，有如下情况：</p>
<ul>
<li>如果该记录的<code>trix_id</code>小于当前Read View的<code>min_trix_id</code>，则表示这个版本的记录属于『已提交事务』，对当前事务『可见』。</li>
<li>如果该记录的<code>trix_id</code>大于当前Read View的<code>max_trix_id</code>，则表示这个版本的记录属于『未开启的事务』，对当前事务『可见』。</li>
<li>如果该记录的<code>trix_id</code>在<code>min_trix_id</code>和<code>max_trix_id</code>之间，则要判断<code>trix_id</code>是否在<code>m_ids</code>列表中。<ul>
<li>如果在，则表明生成该版本记录的事务仍然活跃，即未提交，因此对当前事务『不可见』</li>
<li>如果不在，则表明生成该版本记录的事务已经被提交，因此对当前事务『可见』</li>
</ul>
</li>
</ul>
<p>这种通过『版本链』控制并发事务访问同一个记录的行为叫MVCC（多版本并发控制）。</p>
<h3 id="『可重复读』如何依靠MVCC实现？"><a href="#『可重复读』如何依靠MVCC实现？" class="headerlink" title="『可重复读』如何依靠MVCC实现？"></a>『可重复读』如何依靠MVCC实现？</h3><p>『可重复读』的隔离级别是在事务『启动时』生成一个Read View，『整个事务期间』使用该Read View。</p>
<p>假设启动了id为51的事务A时，仅有A事务；随后启动了id为52的事务B。两个事务都对同一条数据进行读写。在『可重复读』的隔离级别下，这两个事务创建的Read View字段为：</p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222105740.png" alt="img" style="zoom:50%;" />

<p>并且有下述流程</p>
<ol>
<li><p>事务B对读取id&#x3D;1的记录，假设读取了balance &#x3D; 1000000</p>
<ul>
<li>这是因为id&#x3D;1的记录中<code>trx_id(50) &lt; B事务的min_trx_id(51)</code>，因此该记录对事务B『可见』</li>
</ul>
</li>
<li><p>事务A修改该记录，修改为balance &#x3D; 2000000，但『不提交事务』</p>
<ul>
<li><p>这是因为id&#x3D;1的记录中<code>trx_id(50) &lt; A事务的min_trx_id(51)</code>，因此该记录对事务A『可见』</p>
</li>
<li><p>修改后，id&#x3D;1的记录的<code>trx_id</code>修改为51，其<code>roll_pointer</code>指向了修改前的<code>trx_id=50</code>的记录</p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222105225.png" alt="image-20240407115038407" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>事务B再读取id&#x3D;1的记录，读到的仍然是balance &#x3D; 1000000</p>
<ul>
<li>此时id&#x3D;1的记录中<code>trx_id(51) &gt;= B事务的min_trx_id(51)</code>，因此<code>trix_id(51)</code>在B事务MVCC的<code>min_trix_id(51)</code>和<code>max_trix_id(52)</code>之间，则要判断<code>trix_id</code>是否在<code>m_ids</code>列表中。</li>
<li>由于在<code>trix_id(51)</code>在<code>m_ids([51, 52])</code>，因此该记录对事务B『不可见』</li>
<li>事务B将通过沿着<code>roll_pointer</code>指向的undo log版本链，向下找到第一条<code>trx_id</code>满足是的事务B『可见』的记录。因此找到了<code>balance=100000</code>的记录，实现了『可重复读』。</li>
</ul>
</li>
<li><p>事务A『提交事务』</p>
</li>
<li><p>事务B再读取id&#x3D;1的记录，读到的仍然是balance &#x3D; 1000000</p>
<ul>
<li>此时读取时的Read View仍然是是3.时读取时相同Read View，即使A提交了事务，但该记录对于当前Read View仍然不可见。</li>
</ul>
</li>
</ol>
<p>因此，在『可重复读』的隔离级别下，一个事务只能读到事务启动前的记录。</p>
<h3 id="『读提交』如何依靠MVCC实现？"><a href="#『读提交』如何依靠MVCC实现？" class="headerlink" title="『读提交』如何依靠MVCC实现？"></a>『读提交』如何依靠MVCC实现？</h3><p>『读提交』的隔离级别是『每次读取数据时』生成一个Read View。</p>
<ul>
<li><p>事务B对读取id&#x3D;1的记录，『生成一个Read View』，读取到了balance &#x3D; 1000000</p>
<ul>
<li>因为id&#x3D;1的记录中<code>trx_id(50) &lt; 当前Read View的min_trx_id(51)</code>，因此该记录对事务B『可见』</li>
</ul>
</li>
<li><p>事务A修改该记录，修改为balance &#x3D; 2000000，『但不提交事务』</p>
<ul>
<li><p>因为id&#x3D;1的记录中<code>trx_id(50) &lt; 当前Read View的min_trx_id(51)</code>，因此该记录对事务A『可见』</p>
</li>
<li><p>修改后，id&#x3D;1的记录的<code>trx_id</code>修改为51，其<code>roll_pointer</code>指向了修改前的<code>trx_id=50</code>的记录</p>
<img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222105754.png" alt="image-20240407115038407" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>事务B再读取id&#x3D;1的记录，『生成一个Read View』，读到的仍然是balance &#x3D; 1000000。</p>
<ul>
<li>此时id&#x3D;1的记录中<code>trx_id(51) = B事务的min_trx_id(51)</code>，因此<code>trix_id(51)</code>在B事务MVCC的<code>min_trix_id(51)</code>和<code>max_trix_id(52)</code>之间，则要判断<code>trix_id</code>是否在<code>m_ids</code>列表中。</li>
<li>由于在<code>trix_id(51)</code>在<code>m_ids([51, 52])</code>，因此该记录对事务B『不可见』</li>
<li>事务B将通过沿着<code>roll_pointer</code>指向的undo log版本链，向下找到第一条<code>trx_id</code>满足是的事务B『可见』的记录。因此找到了<code>balance=100000</code>的记录。</li>
</ul>
</li>
<li><p>事务A『提交事务』</p>
</li>
<li><p>事务B再读取id&#x3D;1的记录，『生成一个Read View』，读到不再是balance&#x3D;1000000，而是balance &#x3D; 2000000。</p>
<ul>
<li>由于id为52的事务A已经提交事务，此时生成的Read View中<code>min_trx_id=52</code>，因此该记录对事务B『可见』</li>
</ul>
</li>
</ul>
<p>因此，每次读数据都会生成一个Read View实现的『读提交』的隔离级别下，一个事务能够读到其他事务提交的数据。</p>
<h3 id="『读未提交』如何实现？"><a href="#『读未提交』如何实现？" class="headerlink" title="『读未提交』如何实现？"></a>『读未提交』如何实现？</h3><p>事务的并发天然就是读未提交，不需要实现。</p>
<h3 id="『串行化』如何实现？"><a href="#『串行化』如何实现？" class="headerlink" title="『串行化』如何实现？"></a>『串行化』如何实现？</h3><p>每次读写都加锁</p>
<h2 id="Mysql『可重复读』解决了幻读问题吗"><a href="#Mysql『可重复读』解决了幻读问题吗" class="headerlink" title="Mysql『可重复读』解决了幻读问题吗"></a>Mysql『可重复读』解决了幻读问题吗</h2><p>幻读：一个事务的同一个查询在不同时间产生了不同的结果集（数量上的不同），其直接没有执行其他任何语句。</p>
<p>上述的MVCC实现的『可重复读』能够很大程度地避免幻读，但不能完全解决幻读。</p>
<p><strong>首先要理解『快照读』和『当前读』的区别，mysql中除了普通查询Select是『快照读』，其他都是『当前读』。</strong></p>
<h3 id="快照读如何避免幻读？"><a href="#快照读如何避免幻读？" class="headerlink" title="快照读如何避免幻读？"></a>快照读如何避免幻读？</h3><p>就是MVCC中的Read View，查询会利用该Read View在undo log版本链中找到第一条可见的数据，因此事务执行过程中查询的数据是一样的。因此快照读通过MVCC能够很大程度避免幻读。</p>
<h3 id="当前读如何避免幻读？"><a href="#当前读如何避免幻读？" class="headerlink" title="当前读如何避免幻读？"></a>当前读如何避免幻读？</h3><p>『当前读』即读取的记录是数据库最新的记录。当前读的语句有<code>UPDATE</code>，<code>INSERT</code>，<code>DELETE</code>，因为这些操作都需要直到最新的数据，否则可能会与其他事务操作产生冲突。例如，如果这些操作是快照读，事务A已经删除某条数据并提交，另一个事务又更新该数据时没有意义。</p>
<p>此外，特殊的<code>SELECT ... FOR UPDATE</code>是当前读，每次执行都获取最新的数据。</p>
<p>『当前读』使用『间隙锁』在『可重复读』隔离级别避免幻读</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222105033.png" alt="img"></p>
<ul>
<li>事务A执行了语句后，加上id范围为<code>(2, +∞]</code>的next-key lock (即记录锁+间隙锁的组合)。</li>
<li>在事务B执行插入语句时，发现插入位置加入了next-key lock，因此事务B生成一个插入意向锁，阻塞等待A提交事务，避免因为B插入新记录而导致事务A幻读。</li>
</ul>
<h3 id="『可重复读』隔离级别下幻读场景1："><a href="#『可重复读』隔离级别下幻读场景1：" class="headerlink" title="『可重复读』隔离级别下幻读场景1："></a>『可重复读』隔离级别下幻读场景1：</h3><p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/202404222106105.png" alt="img"></p>
<ul>
<li>事务A『查询』一条<code>id=5</code>的不存在的记录，没有查询出来。</li>
<li>事务B随后『插入』一条<code>id=5</code>的不存在的记录，并『提交事务』。</li>
<li>事务A『更新』<code>id=5</code>的记录，虽然事务A由于MVCC的原因无法通过普通的<code>SELECT</code>查询记录，但是能更新该记录，因为<code>UPDATE</code>操作是『当前读』。</li>
<li>事务A『查询』一条<code>id=5</code>的不存在的记录，可以查询出来。</li>
</ul>
<p>数据从0到有，即幻读现象。</p>
<h3 id="『可重复读』隔离级别下幻读场景2："><a href="#『可重复读』隔离级别下幻读场景2：" class="headerlink" title="『可重复读』隔离级别下幻读场景2："></a>『可重复读』隔离级别下幻读场景2：</h3><ul>
<li>事务 A 先执行「快照读语句」：<code>select * from t_test where id &gt; 100</code> 得到了 3 条记录。</li>
<li>事务 B 往插入一个 <code>id= 200</code> 的记录并提交；</li>
<li>事务 A 再执行「当前读语句」<code> select * from t_test where id &gt; 100 for update</code> 就会得到 4 条记录，此时也发生了幻读现象。</li>
</ul>
<p>为了避免这种幻读情况，尽量在开启事务之后，马上执行 select … for update 这类当前读的语句。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2024/03/da5aedcdcc5e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/da5aedcdcc5e/" class="post-title-link" itemprop="url">MySQL底层原理：chapter5锁篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-29T00:00:00+08:00">2024-03-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-22 21:08:12" itemprop="dateModified" datetime="2024-04-22T21:08:12+08:00">2024-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">底层原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>执行后数据库处于『只读』，主要用于『全库逻辑备份』，但锁表时间花费较长影响业务。</p>
<p>在不支持事务的MyISAM中，只能开启全局锁进行备份。</p>
<p>而在InnoDB引擎中开启可重复读事务时，会创建Read View，仅需备份Read View的数据即可，即使其他事务修改了表也不会影响备份。</p>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul>
<li>读锁，也叫共享锁：<code>lock tables t_student read;</code></li>
<li>写锁，也叫独占锁：<code>lock tables t_student write;</code></li>
</ul>
<p>注意！两种表锁都会阻塞『包括本线程的所有线程』的相应操作。所以应该尽量避免使用表锁，影响并发性能。</p>
<h3 id="元数据锁MDL"><a href="#元数据锁MDL" class="headerlink" title="元数据锁MDL"></a>元数据锁MDL</h3><p>不需要显式使用，是数据库防止某线程在数据操作时其他线程修改了『表结构』。</p>
<p>其在事务提交后自动释放，事务执行期间一直持有。</p>
<ul>
<li>对表CRUD时，加的是MDL读锁。其他线程要CRUD时可以读。要修改表结构时阻塞。</li>
<li>对表结构变更时，加的是MDL写锁。其他线程要CRUD时阻塞。要修改表结构时阻塞。</li>
</ul>
<p>由于申请锁会申请一个队列，写锁优先级高于读锁，一旦出现写锁的长时间阻塞，会阻塞后续所有CRUD操作。</p>
<p>例如：A启动了一直不提交的长事务，加上了MDL读锁；随后线程B执行SELECT，但不阻塞；然后线程C修改表结构，但由于A事务的MDL读锁还未释放，因此进程C阻塞，后续的对表读写也因此阻塞。</p>
<p>因此表结构变更前可以考虑kill长事务的线程</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>在InnoDB中</p>
<ul>
<li>对表里某些记录加上『共享锁』时，需要先在表加『意向共享锁』</li>
<li>对表里某些记录加上『独占锁』时，需要先在表加『意向独占锁』。（插入更新删除）</li>
</ul>
<p>SELECT默认不加行级锁，使用的是MVCC实现一致性。也可以在语句中加锁。</p>
<blockquote>
<p>「意向锁」这种「表级锁」不会和「行级锁」冲突，「意向锁」之间也不会冲突，只和「共享表锁」和「独占表锁」之间冲突。</p>
</blockquote>
<p>例如，加独占表锁时，需要遍历表所有记录查询是否存在独占锁，效率慢。<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>，</p>
<h3 id="AUTO-INC锁"><a href="#AUTO-INC锁" class="headerlink" title="AUTO-INC锁"></a>AUTO-INC锁</h3><p>插入数据时，自增主键可以不指定值，数据库自动为其赋递增的值，这是由「AUTO-INC」锁实现的。</p>
<p>它是特殊的『表锁』，不再是一个事务提交后才释放，而是执行完插入语句就释放。但会出现大量插入时阻塞其他事务的插入。</p>
<p>因此InnoDB提供了一种轻量级锁实现自增，只对<code>AUTO_INCREMENT</code>修饰的『字段』加锁，然后为其赋自增值，就释放该锁，不需要等整个插入语句执行完。</p>
<ul>
<li>innodb_autoinc_lock_mode &#x3D; 0，AUTO-INC</li>
<li>innodb_autoinc_lock_mode &#x3D; 2，轻量锁。性能最高，但在『主从复制常见』发生数据不一致。</li>
<li>innodb_autoinc_lock_mode &#x3D; 1，</li>
<li>普通的单个<code>insert</code>时，使用轻量锁</li>
<li><code>insert...select</code>这种批量插入时，仍是AUTO-INC</li>
</ul>
<p>todo: 为什么？</p>
<blockquote>
<p>当 innodb_autoinc_lock_mode &#x3D; 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生<strong>数据不一致的问题</strong>。</p>
</blockquote>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁在InnoDB支持，在MyISAm不支持</p>
<p>普通SELECT默认不加锁，属于『快照读』。也可以加锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//对读取的记录加共享锁</span><br><span class="line">select ... lock in share mode;</span><br><span class="line"></span><br><span class="line">//对读取的记录加独占锁</span><br><span class="line">select ... for update;</span><br></pre></td></tr></table></figure>

<p>加锁语句一定要在事务中，因为事务提交了，锁才会被释放。</p>
<ul>
<li>共享锁（S），读读共享，读写互斥（只允许读）</li>
<li>独占锁（X），写写互斥，读写互斥（都互斥）</li>
</ul>
<p>行级别锁主要有如下三类：</p>
<h3 id="记录锁Record-Lock"><a href="#记录锁Record-Lock" class="headerlink" title="记录锁Record Lock"></a>记录锁Record Lock</h3><p>锁住一条记录，有S和X锁。</p>
<ul>
<li>加了S锁后，其他事务可以加S锁，但不能加X锁。</li>
<li>加了X锁后，其他事务即不可以S锁又不可以X锁。</li>
</ul>
<h3 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁 Gap Lock"></a>间隙锁 Gap Lock</h3><p>只在『可重复读』的隔离级别，为了解决该级别的幻读现象。</p>
<p>例如，在<code>(3, 5)</code>的『开区间』的范围加『间隙锁』，其他事务就无法插入id&#x3D;4这条记录，因此可以避免幻读。</p>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/gap%E9%94%81.drawio.png" alt="img"></p>
<p>间隙锁的S锁和X锁均无区别，不存在互斥关系，即两个事务可以拥有相同范围的间隙锁，因为目的只是不让在范围内插入，而拥有锁的事务不会阻塞，插入的事务才会阻塞。</p>
<h3 id="临键锁-Next-Key-Lock"><a href="#临键锁-Next-Key-Lock" class="headerlink" title="临键锁 Next-Key Lock"></a>临键锁 Next-Key Lock</h3><p>是Gap Lock和Record Lock的组合。锁定一个范围并锁定记录本身，即半开半闭区间。</p>
<p>例如，事务在<code>(3, 5]</code>的『半开半闭区间』的范围加『临键锁』，其他事务就无法插入id&#x3D;4记录，也无法修改id&#x3D;5记录。</p>
<p>因为临键锁包含了记录锁，因此需要考虑X锁和S锁。若一个事务获取了X型临键锁，另一个事务获取了相同范围内的X型临键锁就会阻塞。</p>
<h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><p>事务插入记录时，需要判断插入位置是否已被其他事务加了间隙锁&#x2F;临键锁</p>
<p>若有则阻塞，直到拥有该锁的事务提交，释放了锁。在此期间会生成一个插入意向锁，表明有事务想要在某区间插入新记录。</p>
<p>虽然叫意向锁，但并不是意向锁，而是特殊的间隙锁。</p>
<p>间隙锁锁住的是区间，而插入意向锁锁住的是一个点</p>
<p>且两个事务不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁。</p>
<p>共享锁：Shared Locks，简称 S 锁，属于行锁</p>
<p>排它锁：Exclusive Locks，简称 X 锁，属于行锁</p>
<p>意向共享锁：Intension Shared Locks，简称 IS 锁，属于表锁</p>
<p>意向排它锁：Intension Exclusive Locks，简称 IX 锁，属于表锁</p>
<ul>
<li>表锁：开销小、加锁快，不会发生死锁，锁定的粒度大，发生锁冲突的概率最高，并发度最低</li>
<li>行锁：开销大、加锁慢，会发生思索，锁定的粒度最小，发生锁冲突的概率最小，并发度最高</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2024/03/49fd9137ba4a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/49fd9137ba4a/" class="post-title-link" itemprop="url">Docker可视化工具Portainer安装</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-21 19:05:21" itemprop="dateCreated datePublished" datetime="2024-03-21T19:05:21+08:00">2024-03-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-26 20:13:14" itemprop="dateModified" datetime="2024-03-26T20:13:14+08:00">2024-03-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Docker可视化Portainer安装"><a href="#Docker可视化Portainer安装" class="headerlink" title="Docker可视化Portainer安装"></a>Docker可视化Portainer安装</h2><p>注意linux和windows安装的命令不同，安装错则连接不上docker</p>
<p>拉镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull portainer/portainer</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9000:9000 -p 8000:8000 --name portainer \</span><br><span class="line">--restart=always \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">-v /mydata/portainer/data:/data \</span><br><span class="line">-d portainer/portainer</span><br></pre></td></tr></table></figure>

<p>访问</p>
<p>localhose:9000</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ljq_up/article/details/135674495">https://blog.csdn.net/ljq_up/article/details/135674495</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://drinkwateronly.github.io/2024/03/0c11414048d7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Wallnut">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallnut">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Wallnut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/0c11414048d7/" class="post-title-link" itemprop="url">7-go标准库math包</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-03-13 12:00:00 / 修改时间：12:07:13" itemprop="dateCreated datePublished" datetime="2024-03-13T12:00:00+08:00">2024-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/go%E6%A0%87%E5%87%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">go标准库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Go标准库math包"><a href="#Go标准库math包" class="headerlink" title="Go标准库math包"></a>Go标准库math包</h1><p><font size=5><strong>注意：参与math包运算的输入与结果全为float64！</strong></font></p>
<h2 id="1、绝对值与取整"><a href="#1、绝对值与取整" class="headerlink" title="1、绝对值与取整"></a>1、绝对值与取整</h2><ul>
<li><code>Abs(x float64) float64</code>：返回x的绝对值</li>
<li><code>Ceil(x float64) float64</code>：返回不小于x的最小整数值。</li>
<li><code>Floor(x float64) float64</code>：返回不大于x的最大整数值。</li>
<li><code>Round(x float64) float64</code>：返回四舍五入到最接近的整数值。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/drinkwateronly/Image-Host/main/image/image-20240313120211549.png" alt="image-20240313120211549"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://frameimage.org/">Ceil And Floor In Python W3schools | Viewfloor.co (frameimage.org)</a></p>
</blockquote>
<p>对于负值而言，五入是向下入，相当于floor，即入了后数值更小；正数则是向上入，相当于ceil，即入了后数值更大。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 绝对值与取整</span></span><br><span class="line">	x := <span class="number">-1234.567</span></span><br><span class="line">	<span class="comment">// 返回x绝对值</span></span><br><span class="line">	fmt.Println(math.Abs(x)) <span class="comment">// 1234.567</span></span><br><span class="line">	<span class="comment">// 返回不小于x的最小正整数</span></span><br><span class="line">	fmt.Println(math.Ceil(x)) <span class="comment">// -1234</span></span><br><span class="line">	<span class="comment">// 返回不大于x的最大正整数</span></span><br><span class="line">	fmt.Println(math.Floor(x)) <span class="comment">// -1235</span></span><br><span class="line">	<span class="comment">// 返回四舍五入最接近的整数</span></span><br><span class="line">	fmt.Println(math.Round(x)) <span class="comment">// -1235</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、次方"><a href="#2、次方" class="headerlink" title="2、次方"></a>2、次方</h2><ul>
<li><code>Pow(x, y float64) float64</code>：返回x的y次幂。</li>
<li><code>Sqrt(x float64) float64</code>：返回x的平方根。</li>
<li><code>Exp(x float64) float64</code>：返回自然指数e的x次幂。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 次方</span></span><br><span class="line">	x := <span class="number">2.</span></span><br><span class="line">	y := <span class="number">4.</span></span><br><span class="line">	<span class="comment">// Pow(x,y) 返回x的y方</span></span><br><span class="line">	fmt.Println(math.Pow(x, y)) <span class="comment">// 16</span></span><br><span class="line">	<span class="comment">// Sqrt(x) 返回x的平方根（开方），等价于math.Pow(x, 0.5)</span></span><br><span class="line">	fmt.Println(math.Sqrt(x), math.Pow(x, <span class="number">0.5</span>))</span><br><span class="line">	<span class="comment">// Exp(x) 返回e的x次幂，等价于math.Pow(math.E, x)与math.SqrtE</span></span><br><span class="line">	fmt.Println(math.Exp(x), math.Pow(math.E, x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、对数"><a href="#3、对数" class="headerlink" title="3、对数"></a>3、对数</h2><ul>
<li><code>Log(x float64) float64</code>：返回x的自然对数。</li>
<li><code>math.Ln2</code>：2的自然对数。</li>
<li><code>math.Log2E</code>：以2为底的自然对数e的倒数。</li>
<li><code>math.Log10E</code>：以10为底的自然对数e的倒数。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 对数</span></span><br><span class="line">	<span class="comment">// 以自然数为底的对数</span></span><br><span class="line">	fmt.Println(math.Log(math.E)) <span class="comment">// 1</span></span><br><span class="line">	<span class="comment">// 以10为底的对数</span></span><br><span class="line">	fmt.Println(math.Log(<span class="number">100</span>) / math.Log(<span class="number">10</span>)) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、三角函数"><a href="#4、三角函数" class="headerlink" title="4、三角函数"></a>4、三角函数</h2><ul>
<li><code>math.Pi</code>：圆周率π。</li>
<li><code>Sin(x float64) float64</code>：返回x的正弦值（x以弧度为单位）。</li>
<li><code>Cos(x float64) float64</code>：返回x的余弦值（x以弧度为单位）。</li>
<li><code>Tan(x float64) float64</code>：返回x的正切值（x以弧度为单位）。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo4</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 三角函数</span></span><br><span class="line">	fmt.Println(math.Pi)</span><br><span class="line">	fmt.Println(math.Cos(math.Pi / <span class="number">2</span>))</span><br><span class="line">	fmt.Println(math.Sin(math.Pi / <span class="number">2</span>))</span><br><span class="line">	fmt.Println(math.Tan(math.Pi / <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、大小比较"><a href="#5、大小比较" class="headerlink" title="5、大小比较"></a>5、大小比较</h2><ul>
<li><code>Max(x, y float64) float64</code></li>
<li><code>Min(x, y float64) float64</code></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Wallnut</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>



    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"drinkwateronly/comments","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
